{% extends "base.html" %}

{% block title %}Source Browser - {{ config.title }}{% endblock %}

{% block extra_head %}
<style>
.browser-container {
    display: flex;
    gap: 1.5rem;
    min-height: calc(100vh - 200px);
}

.tree-panel {
    flex: 1;
    min-width: 300px;
    max-width: 400px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

.tree-header {
    padding: 1rem;
    border-bottom: 1px solid var(--border);
    background: var(--bg);
}

.tree-search {
    width: 100%;
    padding: 0.5rem 0.75rem;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-size: 0.9rem;
}

.tree-search:focus {
    outline: none;
    border-color: var(--accent-light);
}

.tree-content {
    flex: 1;
    overflow-y: auto;
    padding: 0.5rem;
}

.tree-stats {
    padding: 0.5rem 1rem;
    border-top: 1px solid var(--border);
    font-size: 0.8rem;
    color: var(--text-muted);
    background: var(--bg);
}

.detail-panel {
    flex: 2;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    padding: 1.5rem;
    overflow-y: auto;
}

/* Tree node styles */
.tree-node {
    user-select: none;
}

.tree-node-header {
    display: flex;
    align-items: center;
    padding: 0.35rem 0.5rem;
    border-radius: 4px;
    cursor: pointer;
    gap: 0.5rem;
}

.tree-node-header:hover {
    background: var(--bg);
}

.tree-node-header.selected {
    background: var(--accent);
}

.tree-toggle {
    width: 16px;
    height: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--text-muted);
    font-size: 0.7rem;
    transition: transform 0.15s;
}

.tree-toggle.expanded {
    transform: rotate(90deg);
}

.tree-toggle.empty {
    visibility: hidden;
}

.tree-icon {
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.9rem;
}

.tree-label {
    flex: 1;
    font-size: 0.9rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.tree-badge {
    background: var(--accent);
    padding: 0.1rem 0.4rem;
    border-radius: 8px;
    font-size: 0.7rem;
    color: var(--text-muted);
}

.tree-children {
    margin-left: 1.25rem;
    display: none;
}

.tree-children.expanded {
    display: block;
}

/* Node type colors */
.node-layer .tree-icon { color: #f39c12; }
.node-library .tree-icon { color: #3498db; }
.node-folder .tree-icon { color: #9b59b6; }
.node-file .tree-icon { color: #2ecc71; }

/* Detail panel styles */
.detail-empty {
    color: var(--text-muted);
    text-align: center;
    padding: 3rem 1rem;
}

.detail-header {
    margin-bottom: 1.5rem;
}

.detail-header h2 {
    color: var(--accent-light);
    margin: 0 0 0.5rem;
    display: flex;
    align-items: center;
    gap: 0.75rem;
}

.detail-header .breadcrumb {
    color: var(--text-muted);
    font-size: 0.85rem;
}

.detail-desc {
    color: var(--text-muted);
    margin: 0.75rem 0;
}

.detail-section {
    margin-top: 1.5rem;
}

.detail-section h3 {
    color: var(--text);
    font-size: 1rem;
    margin-bottom: 0.75rem;
    border-bottom: 1px solid var(--border);
    padding-bottom: 0.5rem;
}

.file-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 0.5rem;
}

.file-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: var(--bg);
    border-radius: 4px;
    font-size: 0.85rem;
    text-decoration: none;
    color: var(--text);
    transition: background 0.15s;
}

.file-item:hover {
    background: var(--accent);
}

.file-item .icon {
    color: #2ecc71;
}

.file-item.has-docs {
    border-left: 2px solid var(--accent-light);
}

/* Class cards */
.class-card {
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 1rem;
    margin-bottom: 0.75rem;
    cursor: pointer;
    transition: border-color 0.15s;
}

.class-card:hover {
    border-color: var(--accent-light);
}

.class-card.expanded {
    border-color: var(--accent-light);
}

.class-card-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 1rem;
}

.class-card h4 {
    margin: 0;
    color: var(--accent-light);
    font-size: 1rem;
}

.class-card-brief {
    color: var(--text-muted);
    font-size: 0.85rem;
    margin-top: 0.5rem;
}

.class-card-meta {
    display: flex;
    gap: 0.75rem;
    margin-top: 0.5rem;
    font-size: 0.75rem;
}

.class-card-meta span {
    background: var(--bg-secondary);
    padding: 0.2rem 0.5rem;
    border-radius: 4px;
    color: var(--text-muted);
}

.class-card-meta .has-algorithms {
    background: var(--accent);
    color: var(--text);
}

/* Algorithm section */
.algorithms-section {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
}

.algorithm-item {
    background: var(--bg-secondary);
    border-radius: 4px;
    padding: 0.75rem;
    margin-bottom: 0.5rem;
    font-size: 0.85rem;
}

.algorithm-name {
    color: var(--accent-light);
    font-weight: 500;
    margin-bottom: 0.5rem;
}

.algorithm-math {
    background: var(--code-bg);
    padding: 0.5rem;
    border-radius: 3px;
    font-family: monospace;
    overflow-x: auto;
    margin: 0.5rem 0;
}

.algorithm-complexity {
    color: var(--text-muted);
    font-size: 0.8rem;
}

/* Methods section */
.methods-section {
    margin-top: 1rem;
    padding-top: 1rem;
    border-top: 1px solid var(--border);
}

.methods-section h5 {
    margin: 0 0 0.75rem;
    color: var(--text);
    font-size: 0.9rem;
}

.method-item {
    background: var(--bg-secondary);
    border-radius: 4px;
    padding: 0.6rem 0.75rem;
    margin-bottom: 0.4rem;
    font-size: 0.85rem;
}

.method-signature {
    font-family: monospace;
    color: var(--accent-light);
    font-weight: 500;
    margin-bottom: 0.25rem;
    word-break: break-word;
}

.method-brief {
    color: var(--text-muted);
    font-size: 0.8rem;
}

.method-meta {
    display: flex;
    gap: 0.5rem;
    margin-top: 0.25rem;
    font-size: 0.75rem;
    color: var(--text-muted);
}

.method-meta span {
    background: var(--bg);
    padding: 0.1rem 0.4rem;
    border-radius: 3px;
}

/* Class detailed description */
.class-detailed {
    margin-top: 0.75rem;
    padding: 0.75rem;
    background: var(--bg);
    border-radius: 4px;
    font-size: 0.85rem;
    color: var(--text-muted);
    line-height: 1.5;
    max-height: 150px;
    overflow-y: auto;
}

/* Doc link button */
.doc-button {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: var(--accent);
    color: var(--text);
    text-decoration: none;
    padding: 0.5rem 1rem;
    border-radius: 4px;
    font-size: 0.85rem;
    transition: background 0.15s;
    border: none;
    cursor: pointer;
}

.doc-button:hover {
    background: var(--accent-light);
}

.doc-button.expanded {
    background: var(--accent-light);
}

/* Inline documentation panel */
.inline-docs {
    margin-top: 1rem;
    padding: 1rem;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    max-height: 500px;
    overflow-y: auto;
    display: none;
}

.inline-docs.visible {
    display: block;
}

.inline-docs-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 1rem;
    padding-bottom: 0.5rem;
    border-bottom: 1px solid var(--border);
}

.inline-docs-header h5 {
    margin: 0;
    color: var(--accent-light);
}

.inline-docs-close {
    background: none;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0.25rem;
}

.inline-docs-close:hover {
    color: var(--text);
}

.inline-docs-content {
    font-size: 0.9rem;
    line-height: 1.6;
}

.inline-docs-content h1,
.inline-docs-content h2,
.inline-docs-content h3 {
    color: var(--accent-light);
    margin-top: 1rem;
    margin-bottom: 0.5rem;
}

.inline-docs-content h1 { font-size: 1.2rem; }
.inline-docs-content h2 { font-size: 1.1rem; }
.inline-docs-content h3 { font-size: 1rem; }

.inline-docs-content pre {
    background: var(--code-bg);
    padding: 0.75rem;
    border-radius: 4px;
    overflow-x: auto;
    font-size: 0.85rem;
}

.inline-docs-content code {
    background: var(--code-bg);
    padding: 0.1rem 0.3rem;
    border-radius: 2px;
    font-size: 0.9em;
}

.inline-docs-content pre code {
    background: none;
    padding: 0;
}

.inline-docs-content ul, .inline-docs-content ol {
    padding-left: 1.5rem;
    margin: 0.5rem 0;
}

.inline-docs-content p {
    margin: 0.5rem 0;
}

.inline-docs-link {
    display: inline-flex;
    align-items: center;
    gap: 0.25rem;
    color: var(--accent-light);
    text-decoration: none;
    font-size: 0.85rem;
}

.inline-docs-link:hover {
    text-decoration: underline;
}

/* Loading state */
.loading {
    color: var(--text-muted);
    font-style: italic;
}

.child-list {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
}

.child-item {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.75rem 1rem;
    background: var(--bg);
    border-radius: 4px;
    cursor: pointer;
    transition: background 0.15s;
}

.child-item:hover {
    background: var(--accent);
}

.child-item .icon {
    font-size: 1.1rem;
}

.child-item .info {
    flex: 1;
}

.child-item .name {
    font-weight: 500;
}

.child-item .meta {
    font-size: 0.8rem;
    color: var(--text-muted);
}

/* Responsive */
@media (max-width: 768px) {
    .browser-container {
        flex-direction: column;
    }
    .tree-panel {
        max-width: none;
        max-height: 50vh;
    }
}

/* Filter highlight */
.tree-node.filtered-out {
    display: none;
}

.tree-label .highlight {
    background: var(--accent);
    border-radius: 2px;
}

/* Architecture Overview Styles */
.arch-overview {
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    margin-bottom: 1.5rem;
}

.arch-toggle {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 1rem 1.25rem;
    cursor: pointer;
    font-weight: 600;
    color: var(--accent-light);
    list-style: none;
}

.arch-toggle::-webkit-details-marker {
    display: none;
}

.arch-toggle-icon {
    transition: transform 0.2s;
    font-size: 0.8rem;
}

.arch-overview:not([open]) .arch-toggle-icon {
    transform: rotate(-90deg);
}

.arch-content {
    padding: 0 1.25rem 1.25rem;
    display: flex;
    flex-wrap: wrap;
    gap: 1.5rem;
}

.layer-stack {
    display: flex;
    flex-direction: column;
    gap: 0.25rem;
    flex: 1;
    min-width: 280px;
}

.layer-card {
    display: flex;
    align-items: center;
    gap: 0.75rem;
    padding: 0.6rem 1rem;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.15s;
}

.layer-card:hover {
    border-color: var(--accent-light);
    transform: translateX(4px);
}

.layer-num {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 0.8rem;
    font-weight: 700;
    flex-shrink: 0;
}

.layer-0 .layer-num { background: #3498db; color: white; }
.layer-1 .layer-num { background: #2ecc71; color: white; }
.layer-2 .layer-num { background: #9b59b6; color: white; }
.layer-3 .layer-num { background: #e74c3c; color: white; }
.layer-4 .layer-num { background: #f39c12; color: white; }

.layer-info {
    flex: 1;
}

.layer-title {
    font-weight: 500;
    font-size: 0.9rem;
}

.layer-libs {
    font-size: 0.8rem;
    color: var(--text-muted);
}

.layer-arrow {
    color: var(--text-muted);
    font-size: 0.9rem;
}

.arch-legend {
    display: flex;
    flex-direction: column;
    gap: 0.5rem;
    padding: 0.5rem 0;
    font-size: 0.8rem;
    color: var(--text-muted);
}

.legend-item {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.legend-arrow {
    opacity: 0.7;
}

.legend-note {
    font-style: italic;
}

.quick-nav {
    flex: 1;
    min-width: 280px;
}

.quick-nav-title {
    font-weight: 600;
    margin-bottom: 0.75rem;
    color: var(--text);
    font-size: 0.9rem;
}

.quick-nav-items {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
}

.quick-nav-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.4rem;
    padding: 0.5rem 0.75rem;
    background: var(--bg);
    border: 1px solid var(--border);
    border-radius: 4px;
    color: var(--text);
    font-size: 0.85rem;
    cursor: pointer;
    transition: all 0.15s;
}

.quick-nav-btn:hover {
    background: var(--accent);
    border-color: var(--accent-light);
}

@media (max-width: 600px) {
    .arch-content {
        flex-direction: column;
    }
    .layer-stack, .quick-nav {
        min-width: auto;
    }
}
</style>
{% endblock %}

{% block content %}
<article>
    <h1>Source Browser</h1>
    <p style="color: var(--text-muted); margin-bottom: 1.5rem;">
        Explore 814 header files across 30 libraries in the COIN-OR optimization stack.
        Click nodes to expand. Files with documentation are highlighted.
    </p>

    <!-- Architecture Overview -->
    <details class="arch-overview" open>
        <summary class="arch-toggle">
            <span class="arch-toggle-icon">‚ñº</span>
            Architecture Overview
        </summary>
        <div class="arch-content">
            <div class="layer-stack">
                <div class="layer-card layer-4" data-layer="4">
                    <div class="layer-num">4</div>
                    <div class="layer-info">
                        <div class="layer-title">Applications</div>
                        <div class="layer-libs">OS ¬∑ DyLP ¬∑ Vol ¬∑ SYMPHONY</div>
                    </div>
                    <div class="layer-arrow">‚Üë</div>
                </div>
                <div class="layer-card layer-3" data-layer="3">
                    <div class="layer-num">3</div>
                    <div class="layer-info">
                        <div class="layer-title">Global Optimization</div>
                        <div class="layer-libs">Couenne ¬∑ Bonmin</div>
                    </div>
                    <div class="layer-arrow">‚Üë</div>
                </div>
                <div class="layer-card layer-2" data-layer="2">
                    <div class="layer-num">2</div>
                    <div class="layer-info">
                        <div class="layer-title">Nonlinear Optimization</div>
                        <div class="layer-libs">Ipopt</div>
                    </div>
                    <div class="layer-arrow">‚Üë</div>
                </div>
                <div class="layer-card layer-1" data-layer="1">
                    <div class="layer-num">1</div>
                    <div class="layer-info">
                        <div class="layer-title">Linear/MIP Optimization</div>
                        <div class="layer-libs">Clp ¬∑ Cbc ¬∑ Cgl ¬∑ Osi</div>
                    </div>
                    <div class="layer-arrow">‚Üë</div>
                </div>
                <div class="layer-card layer-0" data-layer="0">
                    <div class="layer-num">0</div>
                    <div class="layer-info">
                        <div class="layer-title">Foundation</div>
                        <div class="layer-libs">CoinUtils ¬∑ SuiteSparse</div>
                    </div>
                </div>
            </div>
            <div class="arch-legend">
                <div class="legend-item">
                    <span class="legend-arrow">‚Üë</span>
                    <span>depends on</span>
                </div>
                <div class="legend-note">Click any layer to navigate</div>
            </div>
            <div class="quick-nav">
                <div class="quick-nav-title">Quick Navigation</div>
                <div class="quick-nav-items">
                    <button class="quick-nav-btn" data-lib="CoinUtils">üì¶ CoinUtils</button>
                    <button class="quick-nav-btn" data-lib="Clp">üìä Clp (LP)</button>
                    <button class="quick-nav-btn" data-lib="Cbc">üå≥ Cbc (MIP)</button>
                    <button class="quick-nav-btn" data-lib="Ipopt">üìà Ipopt (NLP)</button>
                    <button class="quick-nav-btn" data-lib="Bonmin">üîÄ Bonmin (MINLP)</button>
                    <button class="quick-nav-btn" data-lib="Couenne">üåê Couenne (Global)</button>
                </div>
            </div>
        </div>
    </details>

    <div class="browser-container">
        <div class="tree-panel">
            <div class="tree-header">
                <input type="text" class="tree-search" id="tree-search" placeholder="Filter files..." autocomplete="off">
            </div>
            <div class="tree-content" id="tree-content">
                <div class="detail-empty">Loading...</div>
            </div>
            <div class="tree-stats" id="tree-stats"></div>
        </div>

        <div class="detail-panel" id="detail-panel">
            <div class="detail-empty">
                <p>Select a node from the tree to view details</p>
                <p style="margin-top: 1rem; font-size: 0.85rem;">
                    Use the search box to filter by file name
                </p>
            </div>
        </div>
    </div>
</article>
{% endblock %}

{% block extra_js %}
<script>
(function() {
    const BASE_URL = '{{ config.base_url | safe }}';
    let treeData = null;
    let docsIndex = null;
    let classBriefs = null;
    let selectedNode = null;
    let classDataCache = {};

    // Icons
    const ICONS = {
        layer: 'üì¶',
        library: 'üìö',
        folder: 'üìÅ',
        file: 'üìÑ',
        documented: '‚úì',
        algorithm: '‚öôÔ∏è',
        method: 'üîß'
    };

    // Safe DOM clear helper
    function clearElement(el) {
        while (el.firstChild) {
            el.removeChild(el.firstChild);
        }
    }

    // Load data
    async function init() {
        try {
            const [treeResp, indexResp, briefsResp] = await Promise.all([
                fetch(BASE_URL + '/api/source-tree.json'),
                fetch(BASE_URL + '/api/coinutils/index.json').catch(() => ({ ok: false })),
                fetch(BASE_URL + '/api/class-briefs.json').catch(() => ({ ok: false }))
            ]);

            treeData = await treeResp.json();

            if (indexResp.ok) {
                const indexData = await indexResp.json();
                docsIndex = new Set(indexData.classes.map(function(c) {
                    return typeof c === 'string' ? c : c.name;
                }));
            } else {
                docsIndex = new Set();
            }

            if (briefsResp.ok) {
                classBriefs = await briefsResp.json();
            } else {
                classBriefs = {};
            }

            renderTree();
            updateStats();

            // Check for URL parameters to auto-navigate
            handleUrlParams();
        } catch (e) {
            console.error('Failed to load tree data:', e);
            var container = document.getElementById('tree-content');
            clearElement(container);
            var errorDiv = document.createElement('div');
            errorDiv.className = 'detail-empty';
            errorDiv.textContent = 'Failed to load source tree';
            container.appendChild(errorDiv);
        }
    }

    // Handle URL parameters for deep linking
    function handleUrlParams() {
        var params = new URLSearchParams(window.location.search);
        var library = params.get('library');
        var layer = params.get('layer');

        if (library) {
            // Find and expand to the specified library
            setTimeout(function() {
                expandToLibrary(library);
            }, 100);
        } else if (layer) {
            // Just expand the specified layer
            setTimeout(function() {
                expandToLayer(layer);
            }, 100);
        }
    }

    // Expand tree to show a specific library
    function expandToLibrary(libraryName) {
        var normalizedName = libraryName.toLowerCase();
        var nodes = document.querySelectorAll('.tree-node.node-library');

        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var label = node.querySelector('.tree-label');
            if (label && label.textContent.toLowerCase() === normalizedName) {
                // Expand parent layer first
                var parentLayer = node.closest('.tree-children');
                if (parentLayer) {
                    parentLayer.classList.add('expanded');
                    var parentToggle = parentLayer.previousElementSibling;
                    if (parentToggle) {
                        var toggle = parentToggle.querySelector('.tree-toggle');
                        if (toggle) toggle.classList.add('expanded');
                    }
                }

                // Click the library node to select it and expand
                var header = node.querySelector('.tree-node-header');
                if (header) {
                    header.click();
                    node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                return;
            }
        }
    }

    // Expand to a specific layer
    function expandToLayer(layerNum) {
        var layerName = 'layer-' + layerNum;
        var nodes = document.querySelectorAll('.tree-node.node-layer');

        for (var i = 0; i < nodes.length; i++) {
            var node = nodes[i];
            var id = node.dataset.id;
            if (id && id.toLowerCase().indexOf(layerName) !== -1) {
                var header = node.querySelector('.tree-node-header');
                if (header) {
                    header.click();
                    node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
                return;
            }
        }
    }

    function renderTree() {
        const container = document.getElementById('tree-content');
        clearElement(container);

        treeData.children.forEach(layer => {
            container.appendChild(createTreeNode(layer, 'layer'));
        });
    }

    function createTreeNode(data, type, path) {
        path = path || [];
        const node = document.createElement('div');
        node.className = 'tree-node node-' + type;
        node.dataset.id = data.id || data.name;
        node.dataset.type = type;

        const hasChildren = (data.children && data.children.length > 0) ||
                           (data.files && data.files.length > 0);

        // Header
        const header = document.createElement('div');
        header.className = 'tree-node-header';

        // Toggle
        const toggle = document.createElement('span');
        toggle.className = 'tree-toggle' + (hasChildren ? '' : ' empty');
        toggle.textContent = '‚ñ∂';
        header.appendChild(toggle);

        // Icon
        const icon = document.createElement('span');
        icon.className = 'tree-icon';
        icon.textContent = ICONS[type];
        header.appendChild(icon);

        // Label
        const label = document.createElement('span');
        label.className = 'tree-label';
        label.textContent = data.name;
        header.appendChild(label);

        // Badge (count)
        if (hasChildren) {
            const count = (data.children ? data.children.length : 0) +
                         (data.files ? data.files.length : 0);
            const badge = document.createElement('span');
            badge.className = 'tree-badge';
            badge.textContent = String(count);
            header.appendChild(badge);
        }

        // Doc indicator for files
        if (type === 'file' && docsIndex.has(data.name)) {
            const docBadge = document.createElement('span');
            docBadge.className = 'tree-badge';
            docBadge.style.background = 'var(--accent-light)';
            docBadge.textContent = 'doc';
            header.appendChild(docBadge);
        }

        node.appendChild(header);

        // Children container
        if (hasChildren) {
            const childContainer = document.createElement('div');
            childContainer.className = 'tree-children';

            // Sub-folders
            if (data.children) {
                data.children.forEach(child => {
                    const childType = type === 'layer' ? 'library' : 'folder';
                    childContainer.appendChild(createTreeNode(child, childType, path.concat([data.name])));
                });
            }

            // Files
            if (data.files) {
                data.files.forEach(file => {
                    childContainer.appendChild(createTreeNode(
                        { name: file, id: data.id + '/' + file },
                        'file',
                        path.concat([data.name])
                    ));
                });
            }

            node.appendChild(childContainer);
        }

        // Click handlers
        header.addEventListener('click', function(e) {
            e.stopPropagation();

            // Toggle expansion
            if (hasChildren) {
                toggle.classList.toggle('expanded');
                node.querySelector('.tree-children').classList.toggle('expanded');
            }

            // Select
            selectNode(node, data, type);
        });

        return node;
    }

    function selectNode(element, data, type) {
        // Update selection
        if (selectedNode) {
            selectedNode.querySelector('.tree-node-header').classList.remove('selected');
        }
        element.querySelector('.tree-node-header').classList.add('selected');
        selectedNode = element;

        // Update detail panel
        renderDetail(data, type);
    }

    function renderDetail(data, type) {
        var panel = document.getElementById('detail-panel');
        clearElement(panel);

        // Header
        var header = document.createElement('div');
        header.className = 'detail-header';

        var h2 = document.createElement('h2');
        var iconSpan = document.createElement('span');
        iconSpan.textContent = ICONS[type];
        h2.appendChild(iconSpan);
        h2.appendChild(document.createTextNode(data.name));
        header.appendChild(h2);

        if (data.id) {
            var breadcrumb = document.createElement('div');
            breadcrumb.className = 'breadcrumb';
            breadcrumb.textContent = data.id;
            header.appendChild(breadcrumb);
        }

        if (data.desc) {
            var desc = document.createElement('p');
            desc.className = 'detail-desc';
            desc.textContent = data.desc;
            header.appendChild(desc);
        }

        panel.appendChild(header);

        // For files, show classes defined in this file
        if (type === 'file') {
            renderFileClasses(panel, data.name);
            return;
        }

        // Children section (layers/libraries)
        if (data.children && data.children.length > 0) {
            var section = document.createElement('div');
            section.className = 'detail-section';

            var h3 = document.createElement('h3');
            h3.textContent = type === 'layer' ? 'Libraries' : 'Subdirectories';
            section.appendChild(h3);

            var list = document.createElement('div');
            list.className = 'child-list';

            data.children.forEach(function(child) {
                var item = document.createElement('div');
                item.className = 'child-item';

                var itemIcon = document.createElement('span');
                itemIcon.className = 'icon';
                itemIcon.textContent = type === 'layer' ? ICONS.library : ICONS.folder;
                item.appendChild(itemIcon);

                var info = document.createElement('div');
                info.className = 'info';

                var name = document.createElement('div');
                name.className = 'name';
                name.textContent = child.name;
                info.appendChild(name);

                // Show description if available
                if (child.desc) {
                    var descDiv = document.createElement('div');
                    descDiv.className = 'meta';
                    descDiv.textContent = child.desc;
                    info.appendChild(descDiv);
                } else {
                    var count = (child.children ? child.children.length : 0) +
                                 (child.files ? child.files.length : 0);
                    if (count > 0) {
                        var meta = document.createElement('div');
                        meta.className = 'meta';
                        meta.textContent = count + ' items';
                        info.appendChild(meta);
                    }
                }

                item.appendChild(info);

                // Click to navigate
                item.addEventListener('click', function() {
                    var childId = child.id;
                    var treeNode = document.querySelector('.tree-node[data-id="' + childId + '"]');
                    if (treeNode) {
                        // Expand parents
                        var parent = treeNode.parentElement;
                        while (parent && parent.classList.contains('tree-children')) {
                            parent.classList.add('expanded');
                            var prevSib = parent.previousElementSibling;
                            if (prevSib) {
                                var tog = prevSib.querySelector('.tree-toggle');
                                if (tog) tog.classList.add('expanded');
                            }
                            var grandParent = parent.parentElement;
                            parent = grandParent ? grandParent.parentElement : null;
                        }

                        treeNode.querySelector('.tree-node-header').click();
                        treeNode.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                });

                list.appendChild(item);
            });

            section.appendChild(list);
            panel.appendChild(section);
        }

        // Files section
        if (data.files && data.files.length > 0) {
            var section = document.createElement('div');
            section.className = 'detail-section';

            var h3 = document.createElement('h3');
            h3.textContent = 'Header Files (' + data.files.length + ')';
            section.appendChild(h3);

            var grid = document.createElement('div');
            grid.className = 'file-grid';

            data.files.forEach(function(file) {
                var hasDocs = docsIndex.has(file);
                var item = document.createElement('div');
                item.className = 'file-item' + (hasDocs ? ' has-docs' : '');
                item.style.cursor = 'pointer';

                var fileIcon = document.createElement('span');
                fileIcon.className = 'icon';
                fileIcon.textContent = ICONS.file;
                item.appendChild(fileIcon);

                item.appendChild(document.createTextNode(file));

                if (hasDocs) {
                    var docIcon = document.createElement('span');
                    docIcon.style.marginLeft = 'auto';
                    docIcon.style.color = 'var(--accent-light)';
                    docIcon.textContent = ICONS.documented;
                    item.appendChild(docIcon);
                }

                // Click to select file in tree
                item.addEventListener('click', function() {
                    var fileId = data.id + '/' + file;
                    var treeNode = document.querySelector('.tree-node[data-id="' + fileId + '"]');
                    if (treeNode) {
                        treeNode.querySelector('.tree-node-header').click();
                    }
                });

                grid.appendChild(item);
            });

            section.appendChild(grid);
            panel.appendChild(section);
        }
    }

    // Render classes for a given file
    function renderFileClasses(panel, fileName) {
        // Find classes that belong to this file
        var fileClasses = [];
        for (var className in classBriefs) {
            var info = classBriefs[className];
            if (info.file === fileName) {
                fileClasses.push({ name: className, info: info });
            }
        }

        if (fileClasses.length === 0) {
            var emptyMsg = document.createElement('p');
            emptyMsg.className = 'detail-desc';
            emptyMsg.textContent = 'No documented classes in this file.';
            panel.appendChild(emptyMsg);
            return;
        }

        var section = document.createElement('div');
        section.className = 'detail-section';

        var h3 = document.createElement('h3');
        h3.textContent = 'Classes (' + fileClasses.length + ')';
        section.appendChild(h3);

        fileClasses.forEach(function(cls) {
            var card = createClassCard(cls.name, cls.info);
            section.appendChild(card);
        });

        panel.appendChild(section);
    }

    // Create an expandable class card
    function createClassCard(className, info) {
        var card = document.createElement('div');
        card.className = 'class-card';

        var header = document.createElement('div');
        header.className = 'class-card-header';

        var title = document.createElement('h4');
        title.textContent = className;
        header.appendChild(title);

        // Docs button (loads inline instead of navigating)
        var docButton = null;
        if (docsIndex.has(className)) {
            docButton = document.createElement('button');
            docButton.className = 'doc-button';
            docButton.textContent = 'Docs ‚ñæ';
            docButton.addEventListener('click', function(e) { e.stopPropagation(); });
            header.appendChild(docButton);
        }

        card.appendChild(header);

        // Brief description
        if (info.brief) {
            var brief = document.createElement('div');
            brief.className = 'class-card-brief';
            brief.textContent = info.brief;
            card.appendChild(brief);
        }

        // Metadata badges
        var meta = document.createElement('div');
        meta.className = 'class-card-meta';

        if (info.algorithms > 0) {
            var algBadge = document.createElement('span');
            algBadge.className = 'has-algorithms';
            algBadge.textContent = info.algorithms + ' algorithm' + (info.algorithms > 1 ? 's' : '');
            meta.appendChild(algBadge);
        }

        if (info.methods > 0) {
            var methodBadge = document.createElement('span');
            methodBadge.textContent = info.methods + ' method' + (info.methods > 1 ? 's' : '');
            meta.appendChild(methodBadge);
        }

        card.appendChild(meta);

        // Inline docs section (for expanding docs in-pane)
        var inlineDocsSection = document.createElement('div');
        inlineDocsSection.className = 'inline-docs';
        card.appendChild(inlineDocsSection);

        // Expandable algorithms section
        var algSection = document.createElement('div');
        algSection.className = 'algorithms-section';
        algSection.style.display = 'none';
        card.appendChild(algSection);

        // Handle docs button click - load docs inline
        if (docButton) {
            docButton.addEventListener('click', function(e) {
                e.stopPropagation();
                if (inlineDocsSection.classList.contains('visible')) {
                    // Collapse
                    inlineDocsSection.classList.remove('visible');
                    docButton.classList.remove('expanded');
                    docButton.textContent = 'Docs ‚ñæ';
                } else {
                    // Expand and load
                    inlineDocsSection.classList.add('visible');
                    docButton.classList.add('expanded');
                    docButton.textContent = 'Docs ‚ñ¥';
                    loadInlineDocs(className, inlineDocsSection);
                }
            });
        }

        // Click to expand/load algorithms
        card.addEventListener('click', function() {
            if (card.classList.contains('expanded')) {
                card.classList.remove('expanded');
                algSection.style.display = 'none';
            } else {
                card.classList.add('expanded');
                algSection.style.display = 'block';
                loadClassAlgorithms(className, algSection);
            }
        });

        return card;
    }

    // Load and display inline documentation
    async function loadInlineDocs(className, container) {
        if (container.dataset.loaded) return;

        clearElement(container);

        // Add header with close button and link to full page
        var header = document.createElement('div');
        header.className = 'inline-docs-header';

        var headerTitle = document.createElement('h5');
        headerTitle.textContent = className + ' Documentation';
        header.appendChild(headerTitle);

        var headerRight = document.createElement('div');

        var fullPageLink = document.createElement('a');
        fullPageLink.href = BASE_URL + '/libraries/coinutils/' + className.toLowerCase() + '/';
        fullPageLink.className = 'inline-docs-link';
        fullPageLink.textContent = 'Open full page ‚Üó';
        fullPageLink.style.marginRight = '1rem';
        headerRight.appendChild(fullPageLink);

        var closeBtn = document.createElement('button');
        closeBtn.className = 'inline-docs-close';
        closeBtn.textContent = '√ó';
        closeBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            container.classList.remove('visible');
            var btn = container.parentElement.querySelector('.doc-button');
            if (btn) {
                btn.classList.remove('expanded');
                btn.textContent = 'Docs ‚ñæ';
            }
        });
        headerRight.appendChild(closeBtn);

        header.appendChild(headerRight);
        container.appendChild(header);

        // Loading indicator
        var content = document.createElement('div');
        content.className = 'inline-docs-content';
        content.innerHTML = '<div class="loading">Loading documentation...</div>';
        container.appendChild(content);

        try {
            // Fetch the HTML page
            var docUrl = BASE_URL + '/libraries/coinutils/' + className.toLowerCase() + '/';
            var resp = await fetch(docUrl);
            if (!resp.ok) throw new Error('Not found');

            var html = await resp.text();

            // Parse the HTML and extract main content
            var parser = new DOMParser();
            var doc = parser.parseFromString(html, 'text/html');
            var mainContent = doc.querySelector('main') || doc.querySelector('article') || doc.body;

            if (mainContent) {
                // Remove the h1 title (we have our own header)
                var h1 = mainContent.querySelector('h1');
                if (h1) h1.remove();

                // Remove breadcrumbs if present
                var breadcrumbs = mainContent.querySelector('.breadcrumbs');
                if (breadcrumbs) breadcrumbs.remove();

                content.innerHTML = mainContent.innerHTML;
                container.dataset.loaded = 'true';

                // Re-run syntax highlighting if Prism is available
                if (window.Prism) {
                    Prism.highlightAllUnder(content);
                }

                // Re-run KaTeX if available
                if (window.renderMathInElement) {
                    renderMathInElement(content, {
                        delimiters: [
                            {left: '$$', right: '$$', display: true},
                            {left: '$', right: '$', display: false}
                        ]
                    });
                }
            } else {
                content.innerHTML = '<div class="loading">Could not parse documentation.</div>';
            }
        } catch (e) {
            console.error('Failed to load docs:', e);
            content.innerHTML = '<div class="loading">Could not load documentation.</div>';
        }
    }

    // Load and display class details (algorithms + methods)
    async function loadClassAlgorithms(className, container) {
        if (container.dataset.loaded) return;

        clearElement(container);
        var loading = document.createElement('div');
        loading.className = 'loading';
        loading.textContent = 'Loading class details...';
        container.appendChild(loading);

        try {
            var data;
            if (classDataCache[className]) {
                data = classDataCache[className];
            } else {
                var resp = await fetch(BASE_URL + '/api/coinutils/' + className + '.json');
                if (!resp.ok) throw new Error('Not found');
                data = await resp.json();
                classDataCache[className] = data;
            }

            clearElement(container);
            container.dataset.loaded = 'true';

            // Show detailed description if available
            if (data.detailed && data.detailed.length > 50) {
                var detailedDiv = document.createElement('div');
                detailedDiv.className = 'class-detailed';
                detailedDiv.textContent = data.detailed;
                container.appendChild(detailedDiv);
            }

            // Show algorithms if available
            if (data.algorithms && data.algorithms.length > 0) {
                var algHeader = document.createElement('h5');
                algHeader.textContent = 'Algorithms (' + data.algorithms.length + ')';
                algHeader.style.marginTop = '1rem';
                algHeader.style.marginBottom = '0.5rem';
                algHeader.style.color = 'var(--accent-light)';
                container.appendChild(algHeader);

                data.algorithms.forEach(function(alg) {
                    var item = document.createElement('div');
                    item.className = 'algorithm-item';

                    var parts = parseAlgorithm(alg);

                    if (parts.name) {
                        var nameDiv = document.createElement('div');
                        nameDiv.className = 'algorithm-name';
                        nameDiv.textContent = parts.name;
                        item.appendChild(nameDiv);
                    }

                    if (parts.math) {
                        var mathDiv = document.createElement('div');
                        mathDiv.className = 'algorithm-math';
                        mathDiv.textContent = parts.math;
                        item.appendChild(mathDiv);
                        if (window.renderMathInElement) {
                            renderMathInElement(mathDiv, {
                                delimiters: [
                                    {left: '$$', right: '$$', display: true},
                                    {left: '$', right: '$', display: false}
                                ]
                            });
                        }
                    }

                    if (parts.complexity) {
                        var compDiv = document.createElement('div');
                        compDiv.className = 'algorithm-complexity';
                        compDiv.textContent = 'Complexity: ' + parts.complexity;
                        item.appendChild(compDiv);
                        if (window.renderMathInElement) {
                            renderMathInElement(compDiv, {
                                delimiters: [{left: '$', right: '$', display: false}]
                            });
                        }
                    }

                    container.appendChild(item);
                });
            }

            // Show methods if available
            if (data.methods && data.methods.length > 0) {
                var methodsSection = document.createElement('div');
                methodsSection.className = 'methods-section';

                var methodsHeader = document.createElement('h5');
                methodsHeader.textContent = 'Methods (' + data.methods.length + ')';
                methodsSection.appendChild(methodsHeader);

                // Filter to show only interesting methods (skip constructors, destructors, trivial getters)
                var interestingMethods = data.methods.filter(function(m) {
                    // Skip if name starts with ~ (destructor) or operator
                    if (m.name.startsWith('~') || m.name.startsWith('operator')) return false;
                    // Skip constructors (name same as class)
                    if (m.name === className) return false;
                    // Include if has brief or algorithm
                    return m.brief || m.algorithm;
                });

                // If no interesting methods, show first 10 anyway
                var methodsToShow = interestingMethods.length > 0 ? interestingMethods : data.methods.slice(0, 10);

                methodsToShow.slice(0, 15).forEach(function(method) {
                    var item = document.createElement('div');
                    item.className = 'method-item';

                    // Build signature
                    var sig = document.createElement('div');
                    sig.className = 'method-signature';
                    var sigText = '';
                    if (method.return_type) sigText += method.return_type + ' ';
                    sigText += method.name;
                    if (method.parameters && method.parameters.length > 0) {
                        sigText += '(' + method.parameters.map(function(p) {
                            return p.type + ' ' + p.name;
                        }).join(', ') + ')';
                    } else {
                        sigText += '()';
                    }
                    sig.textContent = sigText;
                    item.appendChild(sig);

                    // Brief description
                    if (method.brief) {
                        var brief = document.createElement('div');
                        brief.className = 'method-brief';
                        brief.textContent = method.brief;
                        item.appendChild(brief);
                    }

                    // Meta info (line number, algorithm)
                    if (method.source_line || method.algorithm) {
                        var meta = document.createElement('div');
                        meta.className = 'method-meta';
                        if (method.source_line) {
                            var lineSpan = document.createElement('span');
                            lineSpan.textContent = 'L' + method.source_line;
                            meta.appendChild(lineSpan);
                        }
                        if (method.algorithm) {
                            var algSpan = document.createElement('span');
                            algSpan.style.background = 'var(--accent)';
                            algSpan.textContent = '‚öôÔ∏è has algorithm';
                            meta.appendChild(algSpan);
                        }
                        item.appendChild(meta);
                    }

                    methodsSection.appendChild(item);
                });

                // Show "and X more" if truncated
                if (methodsToShow.length > 15 || (interestingMethods.length === 0 && data.methods.length > 10)) {
                    var moreDiv = document.createElement('div');
                    moreDiv.className = 'loading';
                    var remaining = data.methods.length - 15;
                    moreDiv.textContent = '... and ' + remaining + ' more methods';
                    methodsSection.appendChild(moreDiv);
                }

                container.appendChild(methodsSection);
            }

            // If nothing to show
            if ((!data.algorithms || data.algorithms.length === 0) &&
                (!data.methods || data.methods.length === 0) &&
                (!data.detailed || data.detailed.length <= 50)) {
                var emptyDiv = document.createElement('div');
                emptyDiv.className = 'loading';
                emptyDiv.textContent = 'No detailed documentation available.';
                container.appendChild(emptyDiv);
            }

        } catch (e) {
            clearElement(container);
            var errDiv = document.createElement('div');
            errDiv.className = 'loading';
            errDiv.textContent = 'Could not load class details.';
            container.appendChild(errDiv);
        }
    }

    // Parse @algorithm annotation string
    function parseAlgorithm(str) {
        var result = { name: '', math: '', complexity: '' };

        // Extract @algorithm name
        var algMatch = str.match(/@algorithm\s+([^@]+)/);
        if (algMatch) result.name = algMatch[1].trim();

        // Extract @math
        var mathMatch = str.match(/@math\s+([^@]+)/);
        if (mathMatch) result.math = mathMatch[1].trim();

        // Extract @complexity
        var compMatch = str.match(/@complexity\s+([^@]+)/);
        if (compMatch) result.complexity = compMatch[1].trim();

        return result;
    }

    function updateStats() {
        var stats = document.getElementById('tree-stats');
        var totalFiles = 0;
        var totalLibs = 0;

        treeData.children.forEach(function(layer) {
            totalLibs += layer.children.length;
            layer.children.forEach(function(lib) {
                totalFiles += lib.files ? lib.files.length : 0;
                if (lib.children) {
                    lib.children.forEach(function(sub) {
                        totalFiles += sub.files ? sub.files.length : 0;
                    });
                }
            });
        });

        stats.textContent = totalLibs + ' libraries ‚Ä¢ ' + totalFiles + ' headers ‚Ä¢ ' +
                           docsIndex.size + ' documented';
    }

    // Search/filter
    document.getElementById('tree-search').addEventListener('input', function(e) {
        var query = e.target.value.toLowerCase().trim();
        var nodes = document.querySelectorAll('.tree-node');

        if (!query) {
            nodes.forEach(function(n) { n.classList.remove('filtered-out'); });
            return;
        }

        nodes.forEach(function(node) {
            var label = node.querySelector('.tree-label').textContent.toLowerCase();
            var matches = label.indexOf(query) !== -1;
            var type = node.dataset.type;

            if (type === 'file') {
                node.classList.toggle('filtered-out', !matches);
                // If file matches, ensure parents are visible
                if (matches) {
                    var parent = node.parentElement;
                    while (parent) {
                        if (parent.classList.contains('tree-children')) {
                            parent.classList.add('expanded');
                            var prevSib = parent.previousElementSibling;
                            if (prevSib) {
                                var tog = prevSib.querySelector('.tree-toggle');
                                if (tog) tog.classList.add('expanded');
                            }
                        }
                        if (parent.classList.contains('tree-node')) {
                            parent.classList.remove('filtered-out');
                        }
                        parent = parent.parentElement;
                    }
                }
            } else {
                // Non-files: show if any child matches
                var hasVisibleChild = node.querySelector('.tree-node:not(.filtered-out)');
                node.classList.toggle('filtered-out', !matches && !hasVisibleChild);
            }
        });
    });

    // Architecture Overview: Setup after tree loads
    function setupArchOverview() {
        // Layer card clicks
        document.querySelectorAll('.layer-card').forEach(function(card) {
            card.addEventListener('click', function() {
                var layerNum = this.dataset.layer;
                if (!layerNum) return;

                // Find and click the corresponding layer in the tree
                var layerId = 'layer-' + layerNum;
                var nodes = document.querySelectorAll('.tree-node.node-layer');

                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    var id = node.dataset.id;
                    if (id && id.toLowerCase().indexOf(layerId) !== -1) {
                        var header = node.querySelector('.tree-node-header');
                        if (header) {
                            header.click();
                            node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        break;
                    }
                }
            });
        });

        // Quick nav button clicks
        document.querySelectorAll('.quick-nav-btn').forEach(function(btn) {
            btn.addEventListener('click', function() {
                var libName = this.dataset.lib;
                if (!libName) return;

                var normalizedName = libName.toLowerCase();
                var nodes = document.querySelectorAll('.tree-node.node-library');

                for (var i = 0; i < nodes.length; i++) {
                    var node = nodes[i];
                    var label = node.querySelector('.tree-label');
                    if (label && label.textContent.toLowerCase() === normalizedName) {
                        // Expand parent layer first
                        var parentLayer = node.closest('.tree-children');
                        if (parentLayer) {
                            parentLayer.classList.add('expanded');
                            var parentToggle = parentLayer.previousElementSibling;
                            if (parentToggle) {
                                var toggle = parentToggle.querySelector('.tree-toggle');
                                if (toggle) toggle.classList.add('expanded');
                            }
                        }

                        // Click the library node
                        var header = node.querySelector('.tree-node-header');
                        if (header) {
                            header.click();
                            node.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        break;
                    }
                }
            });
        });
    }

    // Init then setup arch overview handlers
    init().then(function() {
        setupArchOverview();
    }).catch(function() {
        // Still setup handlers even if init fails
        setupArchOverview();
    });
})();
</script>
{% endblock %}
