{
  "name": "CglProbing",
  "library": "Cgl",
  "layer": "layer-2",
  "header": "src/CglProbing/CglProbing.hpp",
  "brief": "Probing cut generator - variable fixing and implications\n\nProbing systematically tests setting integer variables to bounds,\npropagating implications to derive:\n- Variable fixings (column cuts)\n- Bound tightenings\n- Disaggregation cuts (row cuts)\n- Coefficient strengthening\n- Clique structures\n\nProbing outcomes when testing x_j = 0 vs x_j = 1:\n1. One direction infeasible \u2192 fix variable (column cut)\n2. Both infeasible \u2192 problem infeasible\n3. Both feasible, y fixed same way \u2192 y can be fixed\n4. Both feasible, y fixed opposite \u2192 can substitute y = 1-x_j\n5. Constraint went slack by c \u2192 strengthen coefficient\n\nKey structures:\n- disaggregationAction: What gets fixed when probing a variable\n- cutVector_: Stores implications for each integer\n- Clique arrays: oneFixStart_, zeroFixStart_ for clique membership\n\nModes:\n- mode_ 0: Only unsatisfied integers, use snapshot (fast, global)\n- mode_ 1: Unsatisfied integers with current bounds\n- mode_ 2: All integers with current bounds\n\nCglImplication (separate class):\n- Generates cuts directly from stored implication info\n- Uses CglTreeProbingInfo built during probing",
  "algorithms": [
    {
      "name": "Probing (Variable Fixing and Implication Analysis):\nFor each binary variable x_j, temporarily fix to 0 and 1, propagate bounds:\n1. If x_j = 0 infeasible \u2192 fix x_j = 1 (column cut)\n2. If x_j = 1 infeasible \u2192 fix x_j = 0 (column cut)\n3. If x_j = 0 \u2192 y_k fixed AND x_j = 1 \u2192 y_k fixed same \u2192 fix y_k\n4. If x_j = 0 \u2192 y_k = 1 AND x_j = 1 \u2192 y_k = 0 \u2192 record implication\n5. Coefficient strengthening: if constraint slack increases by c when\n   x_j = 1, tighten coefficient from a_j to (a_j + c)",
      "math": "Bound propagation logic for constraint \u03a3 a_i x_i \u2264 b:\nFor each variable x_j: compute min/max contribution from others\n- min_j = \u03a3_{i\u2260j} min(a_i L_i, a_i U_i)\n- max_j = \u03a3_{i\u2260j} max(a_i L_i, a_i U_i)\nNew bounds: x_j \u2264 (b - min_j)/a_j if a_j > 0, else x_j \u2265 (b - max_j)/a_j\n\nDisaggregation cuts from implications x_j = 1 \u2192 x_k = 0:\nValid cut: x_j + x_k \u2264 1 (clique inequality)",
      "complexity": "Per variable probed: O(nnz) for bound propagation where\nnnz = non-zeros in constraints containing the variable.\nTotal: O(n \u00b7 nnz \u00b7 maxPass) where n = integers, maxPass typically 1-3.\nRoot node: more aggressive (maxProbeRoot_, maxPassRoot_).",
      "ref": [
        "Savelsbergh (1994). \"Preprocessing and Probing Techniques for Mixed\n  Integer Programming Problems\". ORSA J. Computing 6(4):445-454.",
        "Achterberg (2007). \"Constraint Integer Programming\". PhD thesis,\n  TU Berlin. Chapter 3.6: Probing. [Modern treatment]"
      ]
    }
  ],
  "methods": [],
  "see": [
    "CglTreeProbingInfo for storing probing results",
    "CglClique for cliques discovered during probing",
    "CglKnapsackCover which also builds clique info"
  ]
}