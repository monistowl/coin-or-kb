{
  "name": "ClpSimplexPrimal",
  "library": "Clp",
  "layer": "layer-1",
  "header": "src/ClpSimplexPrimal.hpp",
  "brief": "Primal simplex algorithm implementation",
  "algorithms": [
    {
      "name": "Primal Simplex Method:\nSolves LP by maintaining primal feasibility (variables within bounds)\nwhile iterating toward dual feasibility (optimality). Each iteration:\n1. Choose entering variable (pivot column) - with negative reduced cost\n2. Compute pivot column of tableau: d = B^{-1} a_j (via FTRAN)\n3. Choose leaving variable (pivot row) - via ratio test on bounds\n4. Update basis: swap entering/leaving variables\n5. Update primal solution and reduced costs\n\nUses single-phase approach with infeasibilityCost_ weighting for handling\ninfeasible starting points. Steepest edge or Dantzig strategies for pivot\nselection. Anti-degeneracy via cost perturbation (OSL heritage).\n\nThree nested loops: outer handles fake bounds, middle handles refactorization,\ninner performs pivots until optimality or unboundedness detected.",
      "math": "min c^T x s.t. Ax=b, l\u2264x\u2264u\nBasic solution: x_B = B^{-1}b - B^{-1}N x_N, with x_N at bounds.\nReduced cost: s_j = c_j - c_B^T B^{-1} a_j (computed via BTRAN then dot product)\nRatio test: \u03b8* = min{(x_B[i]-l_i)/d_i, (u_i-x_B[i])/(-d_i)} for feasible step.\nPrimal feasible when l \u2264 x \u2264 u. Optimal when also s_j \u2265 0 for vars at lower bound.",
      "complexity": "O(m^2 n) per iteration typical (dominated by FTRAN/BTRAN).\nIteration count varies widely. Often slower than dual simplex but useful\nwhen starting from feasible solution or for problems with few constraints.",
      "ref": [
        "Dantzig, \"Linear Programming and Extensions\", Princeton (1963)",
        "Forrest & Goldfarb, \"Steepest-edge simplex algorithms for LP\",\n     Mathematical Programming 57 (1992) 341-374\n\nImplements the primal simplex method for LP. This is a \"mix-in\" class that\ninherits from ClpSimplex but adds no data - ClpSimplex objects are cast\nto this type when running primal simplex.\n\nThe primal simplex maintains primal feasibility (variables within bounds)\nwhile iterating toward dual feasibility (optimality). Useful when starting\nfrom a feasible solution or when dual simplex struggles.\n\nKey algorithmic features:\n- Single-phase approach with infeasibilityCost_ weighting\n- Explicit bounds on reduced costs for feasibility handling\n- Sparse data structures exploiting problem sparsity\n- Steepest edge or Dantzig pivot selection for entering variable\n- Anti-degeneracy via cost perturbation\n- Supports nonlinear costs (though not heavily tested)"
      ]
    }
  ],
  "methods": [],
  "see": [
    "ClpSimplex for the base simplex class",
    "ClpSimplexDual for dual simplex variant (often faster)",
    "ClpPrimalColumnPivot for pivot column selection strategies",
    "ClpPrimalColumnSteepest, ClpPrimalColumnDantzig for specific strategies"
  ]
}