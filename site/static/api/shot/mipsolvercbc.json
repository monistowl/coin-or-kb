{
  "name": "MIPSolverCbc",
  "library": "SHOT",
  "layer": "layer-4",
  "header": "src/MIPSolver/MIPSolverCbc.h",
  "brief": "COIN-OR Cbc implementation of IMIPSolver interface\n\nProvides open-source MIP solving using Cbc branch-and-cut solver.\n\n**MIPSolverCbc Class:**\n- Implements IMIPSolver interface\n- Uses OsiClpSolverInterface for LP subproblems\n- CbcModel for branch-and-cut\n- CoinModel for problem construction\n\n**Key Data Structures:**\n- osiInterface: OSI LP solver (Clp)\n- cbcModel: MIP solver model\n- coinModel: Problem builder\n- objectiveLinearExpression: CoinPackedVector\n\n**CbcMessageHandler:**\n- Custom message handler for SHOT logging\n- Routes Cbc output through SHOT's Output system\n\n**Limitations:**\n- supportsQuadraticObjective(): No\n- supportsQuadraticConstraints(): No\n- LP/MIP only (no MIQP/QCQP)\n\n@note Default open-source MIP solver, no license required",
  "algorithms": [
    {
      "name": "MIP Solution Pool (getAllVariableSolutions):\n  CBC can return multiple feasible integer solutions.\n  SHOT uses these as candidate points for NLP evaluation:\n  - More solutions = more chances to find primal feasible point\n  - Controlled by setSolutionLimit()",
      "math": "For binary x with solution x\u0302 \u2208 {0,1}\u207f:\n        \u2211(x_j : x\u0302_j=1) - \u2211(x_j : x\u0302_j=0) <= |{j: x\u0302_j=1}| - 1\n  Prevents cycling when NLP subproblem fails or solution is infeasible.",
      "complexity": "Each MIP solve is NP-hard; CBC uses B&C with CGL cuts",
      "ref": [
        "Duran & Grossmann (1986) - Outer Approximation for MINLP",
        "Kronqvist et al. (2019) - SHOT solver description",
        "Kelley's cutting-plane method (1960)",
        "Solution pool heuristics in MIP solvers"
      ]
    }
  ],
  "methods": [],
  "see": [
    "Cbc branch-and-cut library"
  ]
}