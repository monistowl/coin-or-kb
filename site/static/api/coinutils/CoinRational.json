{
  "name": "CoinRational",
  "qualified_name": "CoinRational",
  "brief": "Simple rational number class with numerator and denominator.",
  "detailed": "Stores a rational number as a ratio of two 64-bit integers. Can be constructed directly from numerator/denominator or by finding the nearest rational approximation to a floating-point value.",
  "header_file": "layer-0/CoinUtils/src/CoinRational.hpp",
  "source_file": "layer-0/CoinUtils/src/CoinRational.hpp",
  "library": "CoinUtils",
  "layer": 0,
  "algorithms": [
    "@algorithm Stern-Brocot tree / mediant search for best rational approximation @math Given lower bound a/b and upper bound c/d, the mediant (a+c)/(b+d) is the simplest rational between them. Binary search narrows to the best approximation within tolerance. @complexity O(log(maxdnom)) iterations Stern (1858), Brocot (1861). See also: Graham, Knuth, Patashnik \"Concrete Mathematics\" Ch. 4.5 for Stern-Brocot tree theory.",
    "@algorithm Stern-Brocot mediant search @math Maintains interval [a/b, c/d] containing val. Each step computes mediant m = (a+c)/(b+d) and narrows interval. Terminates when |val - m| <= maxdelta or denominator exceeds maxdnom. @complexity O(log(maxdnom)) - each step at least doubles denominator"
  ],
  "base_classes": [],
  "derived_classes": [],
  "methods": [
    {
      "name": "getDenominator",
      "brief": "Get the denominator of this rational.",
      "detailed": "",
      "return_type": "int64_t",
      "return_desc": "The denominator value",
      "parameters": [],
      "source_file": "layer-0/CoinUtils/src/CoinRational.hpp",
      "source_line": 42,
      "source_code": "",
      "algorithm": "",
      "complexity": "",
      "math": "",
      "refs": [],
      "access": "public"
    },
    {
      "name": "getNumerator",
      "brief": "Get the numerator of this rational.",
      "detailed": "",
      "return_type": "int64_t",
      "return_desc": "The numerator value",
      "parameters": [],
      "source_file": "layer-0/CoinUtils/src/CoinRational.hpp",
      "source_line": 48,
      "source_code": "",
      "algorithm": "",
      "complexity": "",
      "math": "",
      "refs": [],
      "access": "public"
    },
    {
      "name": "CoinRational",
      "brief": "Default constructor creating rational 0/1.",
      "detailed": "",
      "return_type": "",
      "return_desc": "",
      "parameters": [],
      "source_file": "layer-0/CoinUtils/src/CoinRational.hpp",
      "source_line": 53,
      "source_code": "",
      "algorithm": "",
      "complexity": "",
      "math": "",
      "refs": [],
      "access": "public"
    },
    {
      "name": "CoinRational",
      "brief": "Construct rational from explicit numerator and denominator.",
      "detailed": "",
      "return_type": "",
      "return_desc": "",
      "parameters": [
        {
          "name": "n",
          "type": "int64_t",
          "description": "Numerator",
          "default": ""
        },
        {
          "name": "d",
          "type": "int64_t",
          "description": "Denominator (must not be zero)",
          "default": ""
        }
      ],
      "source_file": "layer-0/CoinUtils/src/CoinRational.hpp",
      "source_line": 63,
      "source_code": "",
      "algorithm": "",
      "complexity": "",
      "math": "",
      "refs": [],
      "access": "public"
    },
    {
      "name": "CoinRational",
      "brief": "Construct by finding nearest rational to a double value.",
      "detailed": "Finds a rational p/q such that |val - p/q| <= maxdelta and q <= maxdnom. If no such rational exists within constraints, sets value to 0/1.\n@algorithm Stern-Brocot tree / mediant search for best rational approximation @math Given lower bound a/b and upper bound c/d, the mediant (a+c)/(b+d) is the simplest rational between them. Binary search narrows to the best approximation within tolerance. @complexity O(log(maxdnom)) iterations Stern (1858), Brocot (1861). See also: Graham, Knuth, Patashnik \"Concrete Mathematics\" Ch. 4.5 for Stern-Brocot tree theory.",
      "return_type": "",
      "return_desc": "",
      "parameters": [
        {
          "name": "val",
          "type": "double",
          "description": "The floating-point value to approximate",
          "default": ""
        },
        {
          "name": "maxdelta",
          "type": "double",
          "description": "Maximum allowed absolute error",
          "default": ""
        },
        {
          "name": "maxdnom",
          "type": "int64_t",
          "description": "Maximum allowed denominator",
          "default": ""
        }
      ],
      "source_file": "layer-0/CoinUtils/src/CoinRational.hpp",
      "source_line": 85,
      "source_code": "",
      "algorithm": "@algorithm Stern-Brocot tree / mediant search for best rational approximation @math Given lower bound a/b and upper bound c/d, the mediant (a+c)/(b+d) is the simplest rational between them. Binary search narrows to the best approximation within tolerance. @complexity O(log(maxdnom)) iterations Stern (1858), Brocot (1861). See also: Graham, Knuth, Patashnik \"Concrete Mathematics\" Ch. 4.5 for Stern-Brocot tree theory.",
      "complexity": "",
      "math": "",
      "refs": [],
      "access": "public"
    },
    {
      "name": "nearestRational_",
      "brief": "Find nearest rational approximation to a double.",
      "detailed": "@algorithm Stern-Brocot mediant search @math Maintains interval [a/b, c/d] containing val. Each step computes mediant m = (a+c)/(b+d) and narrows interval. Terminates when |val - m| <= maxdelta or denominator exceeds maxdnom. @complexity O(log(maxdnom)) - each step at least doubles denominator",
      "return_type": "bool",
      "return_desc": "true if a valid approximation was found, false otherwise",
      "parameters": [
        {
          "name": "val",
          "type": "double",
          "description": "Value to approximate",
          "default": ""
        },
        {
          "name": "maxdelta",
          "type": "double",
          "description": "Maximum error tolerance",
          "default": ""
        },
        {
          "name": "maxdnom",
          "type": "int64_t",
          "description": "Maximum denominator allowed",
          "default": ""
        }
      ],
      "source_file": "layer-0/CoinUtils/src/CoinRational.hpp",
      "source_line": 111,
      "source_code": "",
      "algorithm": "@algorithm Stern-Brocot mediant search @math Maintains interval [a/b, c/d] containing val. Each step computes mediant m = (a+c)/(b+d) and narrows interval. Terminates when |val - m| <= maxdelta or denominator exceeds maxdnom. @complexity O(log(maxdnom)) - each step at least doubles denominator",
      "complexity": "",
      "math": "",
      "refs": [],
      "access": "private"
    }
  ],
  "members": [],
  "source_code": "",
  "_schema_version": "1.0",
  "_generator": "transform-doxygen.py"
}