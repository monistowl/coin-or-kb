{
  "name": "CoinFloatEqual",
  "library": "CoinUtils",
  "layer": "layer-0",
  "header": "src/CoinFloatEqual.hpp",
  "brief": "Function objects for testing equality of real numbers\n\nTwo objects are provided; one tests for equality to an absolute tolerance,\none to a scaled tolerance. The tests will handle IEEE floating point, but\nnote that infinity == infinity. Mathematicians are rolling in their graves,\nbut this matches the behaviour for the common practice of using\n<code>DBL_MAX</code> (<code>numeric_limits<double>::max()</code>, or similar\nlarge finite number) as infinity.",
  "algorithms": [
    {
      "name": "Floating-Point Comparison:\n  CoinAbsFltEq: |f1 - f2| < \u03b5 (absolute tolerance)\n  CoinRelFltEq: |f1 - f2| \u2264 \u03b5(1 + max(|f1|, |f2|)) (relative tolerance)\n\n  Special cases:\n  - NaN: never equal to anything (including itself)\n  - Infinity: inf == inf returns true (practical choice)\n  - Exact equality: checked first to handle \u00b10",
      "math": "Absolute: suitable when values are O(1) magnitude\n  Relative: suitable when values span orders of magnitude\n  Default \u03b5 = 1e-10 (double), 1e-6 (float)",
      "complexity": "O(1) per comparison\n\n<p>\nExample usage:\n@verbatim\n  double d1 = 3.14159 ;\n  double d2 = d1 ;\n  double d3 = d1+.0001 ;\n\n  CoinAbsFltEq eq1 ;\n  CoinAbsFltEq eq2(.001) ;\n\n  assert(  eq1(d1,d2) ) ;\n  assert( !eq1(d1,d3) ) ;\n  assert(  eq2(d1,d3) ) ;\n@endverbatim\nCoinRelFltEq follows the same pattern.",
      "ref": ""
    }
  ],
  "methods": [],
  "see": [
    "CoinFinite.hpp for infinity/NaN handling utilities"
  ]
}