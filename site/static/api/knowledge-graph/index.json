{
  "version": "1.0",
  "concepts": {
    "linear_programming": {
      "id": "linear_programming",
      "name": "Linear Programming",
      "category": "problem_class",
      "definition": "Optimization with linear objective and linear constraints. min c^T x  s.t.  Ax \u2264 b, x \u2265 0",
      "intuition": "Find the best point in a convex polytope. Optimal solution always at a vertex.",
      "aliases": [
        "LP"
      ],
      "key_equations": [
        "min c^T x",
        "Ax \u2264 b",
        "x \u2265 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexity"
          }
        ],
        "generalizes": [
          {
            "id": "quadratic_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "SHOT/src/Model/Problem.h",
            "meta": {
              "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
            }
          }
        ]
      }
    },
    "quadratic_programming": {
      "id": "quadratic_programming",
      "name": "Quadratic Programming",
      "category": "problem_class",
      "definition": "Optimization with quadratic objective and linear constraints. min (1/2)x^T Q x + c^T x  s.t.  Ax \u2264 b",
      "intuition": "LP plus a bowl-shaped or saddle-shaped objective. Convex if Q is positive semidefinite.",
      "aliases": [
        "QP"
      ],
      "key_equations": [
        "min (1/2)x^T Q x + c^T x",
        "Ax \u2264 b"
      ],
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          }
        ],
        "generalizes": [
          {
            "id": "nonlinear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblem.hpp",
            "meta": {
              "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
            "meta": {
              "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
            }
          }
        ]
      }
    },
    "nonlinear_programming": {
      "id": "nonlinear_programming",
      "name": "Nonlinear Programming",
      "category": "problem_class",
      "definition": "Optimization with nonlinear objective or constraints. min f(x)  s.t.  g(x) \u2264 0, h(x) = 0",
      "intuition": "General smooth optimization. Find local optima; global optimality only guaranteed if convex.",
      "aliases": [
        "NLP"
      ],
      "key_equations": [
        "min f(x)",
        "g(x) \u2264 0",
        "h(x) = 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "quadratic_programming"
          },
          {
            "id": "KKT_conditions"
          }
        ],
        "implemented_in": [
          {
            "id": "SHOT/src/Model/Problem.h",
            "meta": {
              "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
            }
          }
        ]
      }
    },
    "mixed_integer_programming": {
      "id": "mixed_integer_programming",
      "name": "Mixed-Integer Programming",
      "category": "problem_class",
      "definition": "Linear programming with some integer-constrained variables. min c^T x  s.t.  Ax \u2264 b, x_i \u2208 Z for i \u2208 I",
      "intuition": "LP with discrete choices. NP-hard in general; solved via branch-and-bound with LP relaxations.",
      "aliases": [
        "MIP",
        "MILP"
      ],
      "key_equations": [
        "min c^T x",
        "Ax \u2264 b",
        "x_i \u2208 Z"
      ],
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          },
          {
            "id": "LP_relaxation"
          }
        ],
        "generalizes": [
          {
            "id": "mixed_integer_nonlinear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "mixed_integer_nonlinear_programming": {
      "id": "mixed_integer_nonlinear_programming",
      "name": "Mixed-Integer Nonlinear Programming",
      "category": "problem_class",
      "definition": "Nonlinear programming with some integer-constrained variables. min f(x,y)  s.t.  g(x,y) \u2264 0, y \u2208 Z^m",
      "intuition": "Combines discrete choices with nonlinear physics. Convex MINLP is tractable; nonconvex needs global methods.",
      "aliases": [
        "MINLP"
      ],
      "key_equations": [
        "min f(x,y)",
        "g(x,y) \u2264 0",
        "y \u2208 Z^m"
      ],
      "relationships": {
        "requires": [
          {
            "id": "nonlinear_programming"
          },
          {
            "id": "mixed_integer_programming"
          }
        ]
      }
    },
    "convex_optimization": {
      "id": "convex_optimization",
      "name": "Convex Optimization",
      "category": "problem_class",
      "definition": "Optimization where objective and feasible region are convex. Any local minimum is global minimum.",
      "intuition": "The \"easy\" class of optimization. Polynomial-time algorithms exist; no need to worry about local optima.",
      "relationships": {
        "requires": [
          {
            "id": "convexity"
          }
        ],
        "contains": [
          {
            "id": "linear_programming"
          },
          {
            "id": "quadratic_programming"
          }
        ]
      }
    },
    "nonconvex_optimization": {
      "id": "nonconvex_optimization",
      "name": "Nonconvex Optimization",
      "category": "problem_class",
      "definition": "Optimization where convexity does not hold. Local optima may not be global; exhaustive search or clever bounding required.",
      "intuition": "The \"hard\" class. Must actively search for global optimum or prove bounds.",
      "aliases": [
        "global optimization"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexification"
          }
        ]
      }
    },
    "simplex_method": {
      "id": "simplex_method",
      "name": "Simplex Method",
      "category": "algorithm",
      "definition": "Iteratively moves between adjacent vertices of the feasible polytope, improving objective at each step until optimal vertex reached.",
      "intuition": "Walk along edges of the polytope, always going \"downhill\". Worst-case exponential but fast in practice.",
      "aliases": [
        "simplex algorithm"
      ],
      "key_equations": [
        "Select entering variable: max reduced cost",
        "Select leaving variable: min ratio test",
        "Pivot: update basis"
      ],
      "relationships": {
        "requires": [
          {
            "id": "LU_factorization"
          },
          {
            "id": "basis"
          }
        ],
        "solves": [
          {
            "id": "linear_programming"
          }
        ],
        "contains": [
          {
            "id": "dual_simplex"
          },
          {
            "id": "primal_simplex"
          }
        ],
        "alternative_to": [
          {
            "id": "interior_point_method"
          },
          {
            "id": "interior_point_method"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinBronKerbosch.hpp",
            "meta": {
              "brief": "Bron-Kerbosch Algorithm for maximal clique enumeration"
            }
          },
          {
            "id": "CoinUtils/src/CoinSimpFactorization.hpp",
            "meta": {
              "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
            }
          },
          {
            "id": "CoinUtils/src/CoinFactorization.hpp",
            "meta": {
              "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
            }
          },
          {
            "id": "CoinUtils/src/CoinDenseFactorization.hpp",
            "meta": {
              "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
            }
          },
          {
            "id": "CoinUtils/src/CoinSort.hpp",
            "meta": {
              "brief": "Sorting utilities for pairs, triples, and parallel arrays\n\nProvides CoinPair, CoinTriple, and sort functions for sorting\nmultiple related arrays together (e.g., indices and values)."
            }
          },
          {
            "id": "CoinUtils/src/CoinWarmStartBasis.hpp",
            "meta": {
              "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
            }
          },
          {
            "id": "SuiteSparse/AMD/Include/amd.h",
            "meta": {
              "brief": "Approximate Minimum Degree ordering for sparse matrix factorization\n\nAMD computes a fill-reducing permutation P for sparse Cholesky or LU\nfactorization. Given a symmetric matrix A (or A+A' if A is unsymmetric),\nAMD finds P such that P*A*P' has fewer nonzeros in its Cholesky factor\nthan A would."
            }
          },
          {
            "id": "SuiteSparse/UMFPACK/Include/umfpack.h",
            "meta": {
              "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
            }
          },
          {
            "id": "SuiteSparse/KLU/Include/klu.h",
            "meta": {
              "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
            "meta": {
              "brief": "Simplex algorithm for Lift-and-Project cut generation"
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkDual.h",
            "meta": {
              "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
            }
          }
        ]
      }
    },
    "dual_simplex": {
      "id": "dual_simplex",
      "name": "Dual Simplex Method",
      "category": "algorithm",
      "definition": "Simplex variant that maintains dual feasibility (optimality) while working toward primal feasibility.",
      "intuition": "Start with optimal-but-infeasible solution, pivot to restore feasibility. Great for re-optimization.",
      "relationships": {
        "requires": [
          {
            "id": "simplex_method"
          },
          {
            "id": "LP_duality"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/ClpDualRowSteepest.hpp"
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          }
        ]
      }
    },
    "primal_simplex": {
      "id": "primal_simplex",
      "name": "Primal Simplex Method",
      "category": "algorithm",
      "definition": "Classic simplex that maintains primal feasibility while improving toward optimality.",
      "intuition": "Start with feasible solution, pivot to improve objective.",
      "relationships": {
        "requires": [
          {
            "id": "simplex_method"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/ClpPrimalColumnSteepest.hpp"
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          }
        ]
      }
    },
    "interior_point_method": {
      "id": "interior_point_method",
      "name": "Interior Point Method",
      "category": "algorithm",
      "definition": "Solves optimization by traversing the interior of the feasible region, using barrier functions to stay away from boundaries.",
      "intuition": "Stay inside constraints using a \"force field\" (barrier). Follow the central path as barrier weakens.",
      "aliases": [
        "IPM",
        "barrier method"
      ],
      "key_equations": [
        "min f(x) - \u03bc \u03a3 log(s_i)",
        "Central path: \u03bc \u2192 0",
        "Newton step for KKT system"
      ],
      "relationships": {
        "requires": [
          {
            "id": "newton_method"
          },
          {
            "id": "barrier_function"
          },
          {
            "id": "KKT_conditions"
          }
        ],
        "solves": [
          {
            "id": "linear_programming"
          },
          {
            "id": "nonlinear_programming"
          }
        ],
        "alternative_to": [
          {
            "id": "simplex_method"
          },
          {
            "id": "simplex_method"
          }
        ],
        "implemented_in": [
          {
            "id": "Ipopt/IpIpoptAlg.hpp"
          },
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Gravity/include/gravity/IpoptProgram.h",
            "meta": {
              "brief": "Ipopt solver interface implementing TNLP callbacks\n\nAdapts Gravity models to Ipopt's TNLP (Templated NLP) interface.\n\n**IpoptProgram<type> Class:**\n- Inherits from Ipopt::TNLP and Program<type>\n- _model: Pointer to Gravity Model\n\n**Required TNLP Callbacks:**\n- get_nlp_info(): Return problem dimensions (n, m, nnz_jac, nnz_hess)\n- get_bounds_info(): Variable and constraint bounds\n- get_starting_point(): Initial x, z_L, z_U, lambda\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint values\n- eval_jac_g(): Jacobian values and structure\n- eval_h(): Hessian of Lagrangian\n- finalize_solution(): Copy solution back to model\n\n**Sparsity Pattern:**\n- First call to eval_jac_g/eval_h: return structure (iRow, jCol)\n- Subsequent calls: return values only\n- Gravity tracks via _first_call_jac, _first_call_hess\n\n**Solution Recovery:**\n- finalize_solution() copies x values to model variables\n- Retrieves dual values (lambda) for constraints\n- Retrieves bound multipliers (z_L, z_U)"
            }
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem.\n\n**DualSolver Class:**\n- MIPSolver: Backend MIP solver (CPLEX/Gurobi/CBC/HiGHS)\n- generatedHyperplanes: All cutting planes added\n- hyperplaneWaitingList: Pending cuts to add\n\n**Hyperplane Management:**\n- addHyperplane(): Add supporting hyperplane cut\n- addGeneratedHyperplane(): Record a hyperplane\n- hasHyperplaneBeenAdded(): Avoid duplicate cuts\n\n**Integer Cuts:**\n- addIntegerCut(): Add no-good cuts for MINLP\n- generatedIntegerCuts: All integer cuts\n\n**Interior Points:**\n- interiorPointCandidates: Candidate interior points\n- interiorPts: Verified interior points for ESH"
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyNLP.h",
            "meta": {
              "brief": "Direct NLP solver for continuous problems\n\nBypasses ESH for purely continuous NLP problems.\n\n**SolutionStrategyNLP Class:**\n- initializeStrategy(): Configure for direct NLP solve\n- solveProblem(): Single NLP solver call (Ipopt)\n\n**Use Case:**\n- Problems with no integer variables\n- Convex NLP where outer approximation is unnecessary\n- Falls back to standard NLP solvers (Ipopt)\n\n**When Selected:**\n- Problem type is NLP (no discrete variables)\n- Simpler than ESH for continuous problems"
            }
          }
        ]
      }
    },
    "newton_method": {
      "id": "newton_method",
      "name": "Newton's Method",
      "category": "algorithm",
      "definition": "Second-order optimization using Hessian to compute descent direction. \u0394x = -H^{-1} \u2207f(x)",
      "intuition": "Approximate function as quadratic, jump to minimum of quadratic. Fast convergence near optimum.",
      "aliases": [
        "Newton-Raphson"
      ],
      "key_equations": [
        "\u0394x = -H^{-1} \u2207f",
        "Quadratic convergence"
      ],
      "relationships": {
        "requires": [
          {
            "id": "hessian"
          },
          {
            "id": "linear_system_solve"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          }
        ]
      }
    },
    "branch_and_bound": {
      "id": "branch_and_bound",
      "name": "Branch and Bound",
      "category": "algorithm",
      "definition": "Systematic enumeration of candidate solutions via tree search, using bounds to prune suboptimal branches.",
      "intuition": "Divide problem into subproblems, solve relaxations to get bounds, prune branches that can't improve.",
      "aliases": [
        "B&B"
      ],
      "key_equations": [
        "Lower bound from relaxation",
        "Upper bound from feasible solutions",
        "Prune if LB \u2265 UB"
      ],
      "relationships": {
        "requires": [
          {
            "id": "LP_relaxation"
          },
          {
            "id": "branching"
          },
          {
            "id": "node_selection"
          }
        ],
        "solves": [
          {
            "id": "mixed_integer_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Cbc/CbcModel.hpp"
          },
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          },
          {
            "id": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
            "meta": {
              "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
            "meta": {
              "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "spatial_branch_and_bound": {
      "id": "spatial_branch_and_bound",
      "name": "Spatial Branch and Bound",
      "category": "algorithm",
      "definition": "Extends branch-and-bound to continuous variables for nonconvex problems. Branches on continuous variables to tighten convex relaxations.",
      "intuition": "Standard B&B branches on integers; spatial B&B also subdivides continuous domains to make relaxations tighter.",
      "aliases": [
        "sBB"
      ],
      "relationships": {
        "requires": [
          {
            "id": "branch_and_bound"
          },
          {
            "id": "convexification"
          },
          {
            "id": "bound_tightening"
          }
        ],
        "solves": [
          {
            "id": "nonconvex_optimization"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/CouenneObject.hpp"
          },
          {
            "id": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
            "meta": {
              "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
            }
          }
        ]
      }
    },
    "outer_approximation": {
      "id": "outer_approximation",
      "name": "Outer Approximation",
      "category": "algorithm",
      "definition": "Alternates between MILP master problem and NLP subproblems. Adds linearization cuts from NLP solutions to tighten MILP.",
      "intuition": "Approximate nonlinear constraints with tangent planes. Iterate: solve MILP, get point, add tangent cuts.",
      "aliases": [
        "OA"
      ],
      "key_equations": [
        "g(x*) + \u2207g(x*)^T (x - x*) \u2264 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexity"
          },
          {
            "id": "linear_programming"
          }
        ],
        "solves": [
          {
            "id": "mixed_integer_nonlinear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Bonmin/BonOACutGenerator2.hpp"
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem.\n\n**DualSolver Class:**\n- MIPSolver: Backend MIP solver (CPLEX/Gurobi/CBC/HiGHS)\n- generatedHyperplanes: All cutting planes added\n- hyperplaneWaitingList: Pending cuts to add\n\n**Hyperplane Management:**\n- addHyperplane(): Add supporting hyperplane cut\n- addGeneratedHyperplane(): Record a hyperplane\n- hasHyperplaneBeenAdded(): Avoid duplicate cuts\n\n**Integer Cuts:**\n- addIntegerCut(): Add no-good cuts for MINLP\n- generatedIntegerCuts: All integer cuts\n\n**Interior Points:**\n- interiorPointCandidates: Candidate interior points\n- interiorPts: Verified interior points for ESH"
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyMultiTree.h",
            "meta": {
              "brief": "Iterative outer approximation strategy (multi-tree)\n\nClassic outer approximation loop for convex MINLP.\n\n**Algorithm Pattern:**\n1. Solve MIP relaxation to get candidate point\n2. Generate supporting hyperplanes at violated points\n3. Add cuts to MIP and resolve\n4. Repeat until convergence or termination\n\n**Task Flow (initializeStrategy):**\n- CreateDualProblem \u2192 SolveIteration \u2192 SelectHyperplanes\n- AddHyperplanes \u2192 CheckTermination \u2192 loop\n\n**Advantages:**\n- No callback complexity\n- Can use any MIP solver\n- Easier debugging/logging\n\n**Disadvantages:**\n- Multiple MIP solves\n- May regenerate same B&B tree work"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/MIPSolverCbc.h",
            "meta": {
              "brief": "COIN-OR Cbc implementation of IMIPSolver interface\n\nProvides open-source MIP solving using Cbc branch-and-cut solver.\n\n**MIPSolverCbc Class:**\n- Implements IMIPSolver interface\n- Uses OsiClpSolverInterface for LP subproblems\n- CbcModel for branch-and-cut\n- CoinModel for problem construction\n\n**Key Data Structures:**\n- osiInterface: OSI LP solver (Clp)\n- cbcModel: MIP solver model\n- coinModel: Problem builder\n- objectiveLinearExpression: CoinPackedVector\n\n**CbcMessageHandler:**\n- Custom message handler for SHOT logging\n- Routes Cbc output through SHOT's Output system\n\n**Limitations:**\n- supportsQuadraticObjective(): No\n- supportsQuadraticConstraints(): No\n- LP/MIP only (no MIQP/QCQP)\n\n@note Default open-source MIP solver, no license required"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "cutting_planes": {
      "id": "cutting_planes",
      "name": "Cutting Planes",
      "category": "algorithm",
      "definition": "Strengthen LP relaxation by adding valid inequalities that cut off fractional solutions without removing integer-feasible points.",
      "intuition": "LP relaxation too loose? Add constraints that trim the polytope closer to the integer hull.",
      "aliases": [
        "cuts"
      ],
      "relationships": {
        "requires": [
          {
            "id": "LP_relaxation"
          }
        ],
        "contains": [
          {
            "id": "Gomory_cuts"
          },
          {
            "id": "MIR_cuts"
          }
        ],
        "implemented_in": [
          {
            "id": "Cgl/"
          },
          {
            "id": "CoinUtils/src/CoinConflictGraph.hpp",
            "meta": {
              "brief": "Conflict graph for binary variable incompatibilities in MIP"
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
            "meta": {
              "brief": "Simplex algorithm for Lift-and-Project cut generation"
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          },
          {
            "id": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
            "meta": {
              "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
            }
          },
          {
            "id": "SHOT/src/Tasks/TaskSelectHyperplanePointsECP.h",
            "meta": {
              "brief": "Extended Cutting Plane point selection\n\nClassic outer approximation: linearize at infeasible points.\n\n**TaskSelectHyperplanePointsECP Class:**\n- run(): Process current MIP solutions\n- run(solPoints): Process specific solution points\n\n**ECP Algorithm:**\n- Generate gradient cut at infeasible solution\n- Simpler than ESH but may converge slower\n- Used as fallback when ESH rootsearch fails"
            }
          }
        ]
      }
    },
    "Gomory_cuts": {
      "id": "Gomory_cuts",
      "name": "Gomory Cuts",
      "category": "algorithm",
      "definition": "Cuts derived from the simplex tableau that are violated by the current fractional solution but valid for all integer solutions.",
      "intuition": "Read off a valid inequality directly from the optimal tableau row of a fractional basic variable.",
      "aliases": [
        "Gomory mixed-integer cuts",
        "GMI"
      ],
      "key_equations": [
        "\u03a3 (f_j / f_0) x_j \u2265 1  (simplified)"
      ],
      "relationships": {
        "requires": [
          {
            "id": "cutting_planes"
          },
          {
            "id": "basis"
          }
        ],
        "implemented_in": [
          {
            "id": "Cgl/CglGomory.hpp"
          },
          {
            "id": "Cbc/src/CbcModel.hpp",
            "meta": {
              "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          }
        ]
      }
    },
    "MIR_cuts": {
      "id": "MIR_cuts",
      "name": "Mixed-Integer Rounding Cuts",
      "category": "algorithm",
      "definition": "Cuts derived by rounding continuous coefficients in mixed-integer constraints.",
      "intuition": "If x + y \u2264 2.7 and y is integer, then we can derive x + y \u2264 2.",
      "aliases": [
        "MIR"
      ],
      "relationships": {
        "requires": [
          {
            "id": "cutting_planes"
          }
        ],
        "implemented_in": [
          {
            "id": "Cgl/CglMixedIntegerRounding.hpp"
          }
        ]
      }
    },
    "active_set_method": {
      "id": "active_set_method",
      "name": "Active Set Method",
      "category": "algorithm",
      "definition": "Solves QP by maintaining a working set of active constraints, iteratively adding/dropping constraints.",
      "intuition": "Guess which constraints are tight at the optimum, solve the resulting equality-constrained problem.",
      "relationships": {
        "solves": [
          {
            "id": "quadratic_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "qpOASES/"
          },
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblem.hpp",
            "meta": {
              "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
            }
          }
        ]
      }
    },
    "feasibility_pump": {
      "id": "feasibility_pump",
      "name": "Feasibility Pump",
      "category": "algorithm",
      "definition": "Heuristic for finding feasible MIP solutions by alternating between rounding and projection.",
      "intuition": "Round fractional solution to integers, then find closest LP-feasible point. Repeat until integer-feasible.",
      "aliases": [
        "FP"
      ],
      "relationships": {
        "solves": [
          {
            "id": "mixed_integer_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Bonmin/BonHeuristicFPump.hpp"
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          }
        ]
      }
    },
    "KKT_conditions": {
      "id": "KKT_conditions",
      "name": "Karush-Kuhn-Tucker Conditions",
      "category": "optimality",
      "definition": "Necessary conditions for optimality in constrained optimization: stationarity, primal feasibility, dual feasibility, complementary slackness.",
      "intuition": "At optimum, gradient of objective is a combination of constraint gradients. Active constraints have positive multipliers.",
      "aliases": [
        "KKT",
        "first-order conditions"
      ],
      "key_equations": [
        "\u2207f = \u03a3 \u03bb_i \u2207g_i  (stationarity)",
        "g(x) \u2264 0  (primal feasibility)",
        "\u03bb \u2265 0  (dual feasibility)",
        "\u03bb_i g_i(x) = 0  (complementarity)"
      ],
      "relationships": {
        "requires": [
          {
            "id": "Lagrangian"
          }
        ],
        "contains": [
          {
            "id": "complementary_slackness"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          }
        ]
      }
    },
    "LP_duality": {
      "id": "LP_duality",
      "name": "LP Duality",
      "category": "optimality",
      "definition": "Every LP has a dual LP. At optimality, primal and dual objectives are equal. Primal: min c^T x, Dual: max b^T y",
      "intuition": "Dual variables are prices on constraints. Strong duality: optimal prices give same value as optimal solution.",
      "aliases": [
        "linear programming duality"
      ],
      "key_equations": [
        "Primal: min c^T x s.t. Ax \u2265 b",
        "Dual: max b^T y s.t. A^T y \u2264 c",
        "c^T x* = b^T y*"
      ],
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          },
          {
            "id": "Lagrangian"
          }
        ],
        "contains": [
          {
            "id": "complementary_slackness"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinPresolveDual.hpp",
            "meta": {
              "brief": "Fix variables using dual bounds and reduced cost analysis"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveTighten.hpp",
            "meta": {
              "brief": "Tighten variable bounds using constraint propagation"
            }
          },
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplex.hpp",
            "meta": {
              "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/Clp_C_Interface.h",
            "meta": {
              "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblem.hpp",
            "meta": {
              "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgo.h",
            "meta": {
              "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
            }
          },
          {
            "id": "HiGHS/highs/presolve/HPresolve.h",
            "meta": {
              "brief": "LP/MIP presolve engine\n\n**HPresolve Class:**\nReduces problem size and tightens bounds before solving.\n\n**Matrix Storage:**\nTriplet format with linked list (column) and splay tree (row) for fast access:\n- Avalue[], Arow[], Acol[]: Non-zero storage\n- colhead[], Anext[], Aprev[]: Column-wise linked list\n- rowroot[], ARleft[], ARright[]: Row-wise splay tree\n- rowsize[], colsize[]: Current row/column lengths\n\n**Bound Tracking:**\n- implColLower[]/implColUpper[]: Implied variable bounds\n- rowDualLower[]/rowDualUpper[]: Dual bounds\n- impliedRowBounds, impliedDualRowBounds: Row activity bounds\n\n**Presolve Techniques (Result enum):**\n- singletonRow()/singletonCol(): Remove singleton rows/columns\n- emptyCol(): Remove columns with no constraints\n- doubletonEq(): Eliminate doubleton equalities\n- dominatedColumns(): Remove dominated variables\n- aggregator(): Aggregate rows/columns\n- runProbing(): Probing for integer variables\n- sparsify(): Reduce matrix density\n- detectParallelRowsAndCols(): Remove parallel constraints/variables"
            }
          }
        ]
      }
    },
    "Lagrangian": {
      "id": "Lagrangian",
      "name": "Lagrangian Function",
      "category": "optimality",
      "definition": "L(x,\u03bb) = f(x) + \u03bb^T g(x). Combines objective and constraints with multipliers.",
      "intuition": "Price the constraint violations. Optimal multipliers \u03bb* are the right prices to make x* optimal.",
      "aliases": [
        "Lagrange function"
      ],
      "key_equations": [
        "L(x,\u03bb) = f(x) + \u03a3 \u03bb_i g_i(x)"
      ],
      "relationships": {
        "contains": [
          {
            "id": "KKT_conditions"
          }
        ],
        "implemented_in": [
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgo.h",
            "meta": {
              "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
            }
          }
        ]
      }
    },
    "complementary_slackness": {
      "id": "complementary_slackness",
      "name": "Complementary Slackness",
      "category": "optimality",
      "definition": "At optimality, either a constraint is tight (g_i = 0) or its multiplier is zero (\u03bb_i = 0).",
      "intuition": "You don't pay for slack constraints. If constraint is loose, its price is zero.",
      "key_equations": [
        "\u03bb_i g_i(x) = 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "KKT_conditions"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          }
        ]
      }
    },
    "convexity": {
      "id": "convexity",
      "name": "Convexity",
      "category": "structure",
      "definition": "A set is convex if line segments between any two points stay in the set. A function is convex if its epigraph is convex.",
      "intuition": "No \"dents\" or \"holes\". Can't get stuck in local optima because there's only one valley.",
      "key_equations": [
        "f(\u03b8x + (1-\u03b8)y) \u2264 \u03b8f(x) + (1-\u03b8)f(y)"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
            "meta": {
              "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
            }
          }
        ]
      }
    },
    "sparsity": {
      "id": "sparsity",
      "name": "Sparsity",
      "category": "structure",
      "definition": "Matrix has mostly zero entries. Enables efficient storage and computation.",
      "intuition": "Real-world problems often have structure\u2014each variable affects only a few constraints.",
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinSimpFactorization.hpp",
            "meta": {
              "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
            }
          },
          {
            "id": "CoinUtils/src/CoinPackedMatrix.hpp",
            "meta": {
              "brief": "Sparse matrix stored in compressed row or column format\n\nCoinPackedMatrix represents a sparse matrix using compressed storage.\nCan be stored row-major or column-major. Efficient for major-dimension\noperations (accessing rows in row-major, columns in column-major)."
            }
          },
          {
            "id": "CoinUtils/src/CoinIndexedVector.hpp",
            "meta": {
              "brief": "Sparse vector with dense backing array for O(1) element access\n\nCoinIndexedVector combines sparse index storage with a dense values array,\nenabling O(1) random access while tracking which positions are non-zero.\nDesigned for simplex operations where sparse updates need fast access.\nHas optional \"packed\" mode that behaves more like CoinPackedVector."
            }
          },
          {
            "id": "CoinUtils/src/CoinPackedVector.hpp",
            "meta": {
              "brief": "Sparse vector that owns its index/value storage\n\nCoinPackedVector stores a sparse vector as parallel arrays of indices\nand values. Unlike CoinShallowPackedVector, this class owns its storage\nand supports modification operations."
            }
          },
          {
            "id": "SuiteSparse/CSparse/Include/cs.h",
            "meta": {
              "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
            }
          },
          {
            "id": "SuiteSparse/LDL/Include/ldl.h",
            "meta": {
              "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkk.h",
            "meta": {
              "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
            }
          },
          {
            "id": "SHOT/src/Model/Problem.h",
            "meta": {
              "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
            }
          }
        ]
      }
    },
    "LP_relaxation": {
      "id": "LP_relaxation",
      "name": "LP Relaxation",
      "category": "structure",
      "definition": "Drop integrality constraints from MIP to get an LP. Provides lower bound on MIP optimal value.",
      "intuition": "Allow fractional solutions. Easier to solve; optimal value \u2264 true MIP optimum.",
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          },
          {
            "id": "Cbc/src/CbcModel.hpp",
            "meta": {
              "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
            "meta": {
              "brief": "Simplex algorithm for Lift-and-Project cut generation"
            }
          }
        ]
      }
    },
    "convexification": {
      "id": "convexification",
      "name": "Convexification",
      "category": "structure",
      "definition": "Replace nonconvex functions with convex under/over-estimators. Tightest convex relaxation is the convex envelope.",
      "intuition": "Wrap the nonconvex function in a convex \"envelope\". Gives valid bounds for global optimization.",
      "aliases": [
        "convex relaxation",
        "convex envelope"
      ],
      "relationships": {
        "contains": [
          {
            "id": "McCormick_envelopes"
          }
        ]
      }
    },
    "McCormick_envelopes": {
      "id": "McCormick_envelopes",
      "name": "McCormick Envelopes",
      "category": "structure",
      "definition": "Convex and concave envelopes for bilinear terms w = xy over a box. Four linear inequalities that tightly bound the product.",
      "intuition": "The product xy is nonconvex, but on a bounded box we can \"wrap\" it with four planes.",
      "key_equations": [
        "w \u2265 l_x y + x l_y - l_x l_y",
        "w \u2265 u_x y + x u_y - u_x u_y",
        "w \u2264 u_x y + x l_y - u_x l_y",
        "w \u2264 l_x y + x u_y - l_x u_y"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexification"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/"
          }
        ]
      }
    },
    "basis": {
      "id": "basis",
      "name": "Basis",
      "category": "structure",
      "definition": "Set of m linearly independent columns of A in LP standard form. Basic solution: set non-basic variables to zero, solve for basic variables.",
      "intuition": "A vertex of the polytope corresponds to a basis. Simplex moves between bases.",
      "aliases": [
        "basic solution"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/CoinFactorization.hpp"
          },
          {
            "id": "CoinUtils/src/CoinFactorization.hpp",
            "meta": {
              "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
            }
          },
          {
            "id": "CoinUtils/src/CoinWarmStartBasis.hpp",
            "meta": {
              "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplex.hpp",
            "meta": {
              "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "Clp/src/Clp_C_Interface.h",
            "meta": {
              "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkDual.h",
            "meta": {
              "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
            }
          }
        ]
      }
    },
    "LU_factorization": {
      "id": "LU_factorization",
      "name": "LU Factorization",
      "category": "technique",
      "definition": "Decompose matrix A = LU where L is lower triangular, U is upper triangular. Enables efficient solving of Ax = b via forward/back substitution.",
      "intuition": "Break matrix into triangular pieces. Solving triangular systems is O(n\u00b2) not O(n\u00b3).",
      "aliases": [
        "LU decomposition"
      ],
      "key_equations": [
        "A = LU",
        "Solve Ly = b, then Ux = y"
      ],
      "relationships": {
        "requires": [
          {
            "id": "sparsity"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/CoinFactorization.hpp"
          },
          {
            "id": "CoinUtils/src/CoinSimpFactorization.hpp",
            "meta": {
              "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
            }
          },
          {
            "id": "CoinUtils/src/CoinFactorization.hpp",
            "meta": {
              "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
            }
          },
          {
            "id": "CoinUtils/src/CoinDenseFactorization.hpp",
            "meta": {
              "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
            }
          },
          {
            "id": "SuiteSparse/CSparse/Include/cs.h",
            "meta": {
              "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
            }
          },
          {
            "id": "SuiteSparse/UMFPACK/Include/umfpack.h",
            "meta": {
              "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
            }
          },
          {
            "id": "SuiteSparse/LDL/Include/ldl.h",
            "meta": {
              "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplex.hpp",
            "meta": {
              "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkk.h",
            "meta": {
              "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkDual.h",
            "meta": {
              "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
            }
          }
        ]
      }
    },
    "presolve": {
      "id": "presolve",
      "name": "Presolve",
      "category": "technique",
      "definition": "Simplify problem before solving: remove redundant constraints, fix variables, tighten bounds, detect infeasibility.",
      "intuition": "Clean up the problem first. Often dramatically reduces size and improves conditioning.",
      "aliases": [
        "preprocessing"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/CoinPresolveMatrix.hpp"
          },
          {
            "id": "Clp/ClpPresolve.hpp"
          },
          {
            "id": "CoinUtils/src/CoinPresolveMatrix.hpp",
            "meta": {
              "brief": "Core presolve data structures and action base class\n\nDefines CoinPrePostsolveMatrix (common base), CoinPresolveMatrix (for\npresolve), CoinPostsolveMatrix (for postsolve), and CoinPresolveAction\n(base class for all presolve transformations)."
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveForcing.hpp",
            "meta": {
              "brief": "Forcing and useless constraint detection"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveImpliedFree.hpp",
            "meta": {
              "brief": "Detect and process implied free variables"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveTighten.hpp",
            "meta": {
              "brief": "Tighten variable bounds using constraint propagation"
            }
          },
          {
            "id": "SuiteSparse/KLU/Include/klu.h",
            "meta": {
              "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
            }
          },
          {
            "id": "Clp/src/ClpPresolve.hpp",
            "meta": {
              "brief": "Clp interface to CoinPresolve for LP preprocessing"
            }
          },
          {
            "id": "Cbc/src/CbcParameters.hpp",
            "meta": {
              "brief": "Central parameter collection for Cbc algorithm control\nCopyright (C) 2007, Lou Hafer, IBM Corporation and others.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcParameters: Master class holding all Cbc solver parameters.\nUsed by cbc-generic to configure and control the MIP solver.\n\nMajor subsystems configured:\n- Cut generators: Gomory, MIR, Probing, Clique, FlowCover, etc.\n- Heuristics: FPump, RINS, RENS, DINS, Diving variants, VND, etc.\n- Search strategy: Node selection, preprocessing, orbital branching\n- Limits: Time, nodes, gap tolerance, solution count\n\nIncludes instances of CGL cut generators and Cbc heuristics.\nLinks to ClpParameters for underlying LP solver control.\n\nKey methods:\n- init(): Initialize with strategy preset\n- setModel(): Associate with CbcModel\n- Various getters/setters for each parameter category\n\nStrategy presets provide common configurations:\n- Default aggressive cutting at root\n- Balanced cut/heuristic emphasis\n- Heuristic-focused for quick solutions"
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          }
        ]
      }
    },
    "warm_start": {
      "id": "warm_start",
      "name": "Warm Start",
      "category": "technique",
      "definition": "Initialize solver with information from a previous solve (basis, solution, bounds). Reduces iterations needed for similar problems.",
      "intuition": "Don't start from scratch. Use the old answer as a starting point for the modified problem.",
      "aliases": [
        "hot start"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/CoinWarmStart.hpp"
          },
          {
            "id": "Clp/ClpSimplex.hpp"
          },
          {
            "id": "CoinUtils/src/CoinWarmStartBasis.hpp",
            "meta": {
              "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
            }
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "Clp/src/Clp_C_Interface.h",
            "meta": {
              "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "SHOT/src/NLPSolver/NLPSolverIpoptBase.h",
            "meta": {
              "brief": "Ipopt implementation of INLPSolver interface\n\nProvides NLP solving for SHOT's primal problem using Ipopt interior point.\n\n**IpoptProblem Class (Ipopt::TNLP):**\n- Implements Ipopt's TNLP interface\n- Provides callbacks for function/gradient/Hessian evaluation\n- Sparse Jacobian/Hessian via index placement maps\n\n**TNLP Callbacks:**\n- get_nlp_info(): Problem dimensions and sparsity\n- get_bounds_info(): Variable and constraint bounds\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint function values\n- eval_jac_g(): Constraint Jacobian (sparse)\n- eval_h(): Lagrangian Hessian (sparse)\n- finalize_solution(): Store optimal point\n\n**NLPSolverIpoptBase Class:**\n- Wraps IpoptApplication for solve control\n- Variable fixing for integer-fixed NLP subproblems\n- Starting point management\n\n**IpoptJournal:**\n- Routes Ipopt output through SHOT logging system\n\n@note Used for fixed-integer NLP subproblems in primal bound computation"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "bound_tightening": {
      "id": "bound_tightening",
      "name": "Bound Tightening",
      "category": "technique",
      "definition": "Infer tighter variable bounds from constraints. FBBT: propagate through constraint graph. OBBT: solve optimization subproblems.",
      "intuition": "If x + y \u2264 10 and y \u2265 3, then x \u2264 7. Propagate these implications to shrink the search space.",
      "aliases": [
        "domain reduction"
      ],
      "relationships": {
        "contains": [
          {
            "id": "FBBT"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/CouenneFixPoint.hpp"
          },
          {
            "id": "CoinUtils/src/CoinPresolveTighten.hpp",
            "meta": {
              "brief": "Tighten variable bounds using constraint propagation"
            }
          },
          {
            "id": "Clp/src/ClpPresolve.hpp",
            "meta": {
              "brief": "Clp interface to CoinPresolve for LP preprocessing"
            }
          },
          {
            "id": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
            "meta": {
              "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
            }
          },
          {
            "id": "SHOT/src/Tasks/TaskPerformBoundTightening.h",
            "meta": {
              "brief": "Tighten variable bounds via optimization\n\nUses optimization-based bound tightening (OBBT).\n\n**TaskPerformBoundTightening Class:**\n- POASolver: Polyhedral outer approximation solver\n- createPOA(): Build relaxed problem for bound tightening\n\n**OBBT Algorithm:**\n- For each variable: min/max subject to relaxation\n- Tightens bounds beyond constraint propagation\n- Improves relaxation quality"
            }
          }
        ]
      }
    },
    "FBBT": {
      "id": "FBBT",
      "name": "Feasibility-Based Bound Tightening",
      "category": "technique",
      "definition": "Propagate bounds through constraint graph without solving subproblems. Fast but may miss tightenings that require global reasoning.",
      "intuition": "Local constraint propagation\u2014what can I infer about each variable from its immediate constraints?",
      "relationships": {
        "requires": [
          {
            "id": "bound_tightening"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/CouenneFixPoint.hpp"
          }
        ]
      }
    },
    "branching": {
      "id": "branching",
      "name": "Branching",
      "category": "technique",
      "definition": "Choose which variable to branch on and what value to split at. Strong branching: test candidates. Pseudocost: use history.",
      "intuition": "Which split will help most? Try a few candidates (expensive) or use past experience (cheap).",
      "aliases": [
        "variable selection"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "Cbc/CbcBranchActual.hpp"
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          }
        ]
      }
    },
    "node_selection": {
      "id": "node_selection",
      "name": "Node Selection",
      "category": "technique",
      "definition": "Choose which node in the B&B tree to explore next. Best-first: chase best bound. Depth-first: find feasible solutions fast.",
      "intuition": "Explore the tree strategically. Best-bound proves optimality; depth-first finds solutions.",
      "relationships": {
        "implemented_in": [
          {
            "id": "Cbc/CbcCompareActual.hpp"
          },
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          }
        ]
      }
    },
    "linear_system_solve": {
      "id": "linear_system_solve",
      "name": "Linear System Solve",
      "category": "technique",
      "definition": "Solve Ax = b for x. Foundation of most numerical optimization.",
      "intuition": "The workhorse computation. Interior point needs it for Newton; simplex for basis updates.",
      "relationships": {
        "contains": [
          {
            "id": "LU_factorization"
          }
        ]
      }
    },
    "barrier_function": {
      "id": "barrier_function",
      "name": "Barrier Function",
      "category": "technique",
      "definition": "Add -\u03bc \u03a3 log(x_i) to objective to keep x > 0. As \u03bc \u2192 0, solutions approach boundary (constraint satisfaction).",
      "intuition": "Create a \"force field\" that repels from boundaries. Weaken it gradually to approach the optimum.",
      "aliases": [
        "log barrier"
      ],
      "key_equations": [
        "-\u03bc log(x)  \u2192  +\u221e as x \u2192 0"
      ],
      "relationships": {}
    },
    "hessian": {
      "id": "hessian",
      "name": "Hessian Matrix",
      "category": "technique",
      "definition": "Matrix of second partial derivatives. H_ij = \u2202\u00b2f/\u2202x_i\u2202x_j. Describes local curvature of the function.",
      "intuition": "How curved is the function? Positive definite Hessian means convex (bowl-shaped).",
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinMpsIO.hpp",
            "meta": {
              "brief": "MPS file format reader/writer for LP and MIP problems\n\nReads/writes standard MPS format including extensions for quadratic,\nconic, and SOS constraints. Supports free format and compression."
            }
          },
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          }
        ]
      }
    },
    "automatic_differentiation": {
      "id": "automatic_differentiation",
      "name": "Automatic Differentiation",
      "category": "technique",
      "definition": "Compute derivatives exactly by applying chain rule to program operations. Forward mode: Jacobian-vector products. Reverse mode: gradient.",
      "intuition": "Don't derive gradients by hand or use finite differences. Let the computer apply calculus rules automatically.",
      "aliases": [
        "AD",
        "autodiff"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CppAD/"
          },
          {
            "id": "ADOL-C/"
          },
          {
            "id": "CppAD/include/cppad/cppad.hpp",
            "meta": {
              "brief": "Contains all variables and functions defined by CppAD package"
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/drivers/drivers.h",
            "meta": {
              "brief": "High-level driver functions for derivative computation\n\nProvides convenient functions for computing common derivative quantities:\n- gradient(): First derivative of scalar function (\u2207f)\n- jacobian(): First derivative of vector function (\u2202F/\u2202x)\n- hessian(): Second derivative of scalar function (\u2207\u00b2f)\n- hess_vec(): Hessian-vector product (\u2207\u00b2f \u00b7 v)\n- jac_vec(): Jacobian-vector product (J \u00b7 v)\n- vec_jac(): Vector-Jacobian product (u^T \u00b7 J)\n\nThese drivers wrap the lower-level forward/reverse interfaces and handle\nmemory allocation and mode selection automatically. All functions require\na pre-recorded tape (via trace_on/trace_off)."
            }
          }
        ]
      }
    }
  },
  "relationships": [
    {
      "from": "linear_programming",
      "to": "quadratic_programming",
      "type": "generalizes"
    },
    {
      "from": "linear_programming",
      "to": "convexity",
      "type": "requires"
    },
    {
      "from": "quadratic_programming",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "quadratic_programming",
      "to": "nonlinear_programming",
      "type": "generalizes"
    },
    {
      "from": "nonlinear_programming",
      "to": "quadratic_programming",
      "type": "requires"
    },
    {
      "from": "nonlinear_programming",
      "to": "KKT_conditions",
      "type": "requires"
    },
    {
      "from": "mixed_integer_programming",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "mixed_integer_programming",
      "to": "mixed_integer_nonlinear_programming",
      "type": "generalizes"
    },
    {
      "from": "mixed_integer_programming",
      "to": "LP_relaxation",
      "type": "requires"
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "nonlinear_programming",
      "type": "requires"
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "mixed_integer_programming",
      "type": "requires"
    },
    {
      "from": "convex_optimization",
      "to": "convexity",
      "type": "requires"
    },
    {
      "from": "convex_optimization",
      "to": "linear_programming",
      "type": "contains"
    },
    {
      "from": "convex_optimization",
      "to": "quadratic_programming",
      "type": "contains"
    },
    {
      "from": "nonconvex_optimization",
      "to": "convexification",
      "type": "requires"
    },
    {
      "from": "simplex_method",
      "to": "linear_programming",
      "type": "solves"
    },
    {
      "from": "simplex_method",
      "to": "LU_factorization",
      "type": "requires"
    },
    {
      "from": "simplex_method",
      "to": "basis",
      "type": "requires"
    },
    {
      "from": "simplex_method",
      "to": "interior_point_method",
      "type": "alternative_to"
    },
    {
      "from": "interior_point_method",
      "to": "simplex_method",
      "type": "alternative_to"
    },
    {
      "from": "simplex_method",
      "to": "dual_simplex",
      "type": "contains"
    },
    {
      "from": "simplex_method",
      "to": "primal_simplex",
      "type": "contains"
    },
    {
      "from": "dual_simplex",
      "to": "simplex_method",
      "type": "requires"
    },
    {
      "from": "dual_simplex",
      "to": "LP_duality",
      "type": "requires"
    },
    {
      "from": "dual_simplex",
      "to": "Clp/ClpDualRowSteepest.hpp",
      "type": "implemented_in"
    },
    {
      "from": "primal_simplex",
      "to": "simplex_method",
      "type": "requires"
    },
    {
      "from": "primal_simplex",
      "to": "Clp/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in"
    },
    {
      "from": "interior_point_method",
      "to": "linear_programming",
      "type": "solves"
    },
    {
      "from": "interior_point_method",
      "to": "nonlinear_programming",
      "type": "solves"
    },
    {
      "from": "interior_point_method",
      "to": "newton_method",
      "type": "requires"
    },
    {
      "from": "interior_point_method",
      "to": "barrier_function",
      "type": "requires"
    },
    {
      "from": "interior_point_method",
      "to": "KKT_conditions",
      "type": "requires"
    },
    {
      "from": "interior_point_method",
      "to": "simplex_method",
      "type": "alternative_to"
    },
    {
      "from": "simplex_method",
      "to": "interior_point_method",
      "type": "alternative_to"
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/IpIpoptAlg.hpp",
      "type": "implemented_in"
    },
    {
      "from": "newton_method",
      "to": "hessian",
      "type": "requires"
    },
    {
      "from": "newton_method",
      "to": "linear_system_solve",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "mixed_integer_programming",
      "type": "solves"
    },
    {
      "from": "branch_and_bound",
      "to": "LP_relaxation",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "branching",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "node_selection",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/CbcModel.hpp",
      "type": "implemented_in"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "branch_and_bound",
      "type": "requires"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "convexification",
      "type": "requires"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "bound_tightening",
      "type": "requires"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "nonconvex_optimization",
      "type": "solves"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "Couenne/CouenneObject.hpp",
      "type": "implemented_in"
    },
    {
      "from": "outer_approximation",
      "to": "mixed_integer_nonlinear_programming",
      "type": "solves"
    },
    {
      "from": "outer_approximation",
      "to": "convexity",
      "type": "requires"
    },
    {
      "from": "outer_approximation",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/BonOACutGenerator2.hpp",
      "type": "implemented_in"
    },
    {
      "from": "cutting_planes",
      "to": "LP_relaxation",
      "type": "requires"
    },
    {
      "from": "cutting_planes",
      "to": "Gomory_cuts",
      "type": "contains"
    },
    {
      "from": "cutting_planes",
      "to": "MIR_cuts",
      "type": "contains"
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/",
      "type": "implemented_in"
    },
    {
      "from": "Gomory_cuts",
      "to": "cutting_planes",
      "type": "requires"
    },
    {
      "from": "Gomory_cuts",
      "to": "basis",
      "type": "requires"
    },
    {
      "from": "Gomory_cuts",
      "to": "Cgl/CglGomory.hpp",
      "type": "implemented_in"
    },
    {
      "from": "MIR_cuts",
      "to": "cutting_planes",
      "type": "requires"
    },
    {
      "from": "MIR_cuts",
      "to": "Cgl/CglMixedIntegerRounding.hpp",
      "type": "implemented_in"
    },
    {
      "from": "active_set_method",
      "to": "quadratic_programming",
      "type": "solves"
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/",
      "type": "implemented_in"
    },
    {
      "from": "feasibility_pump",
      "to": "mixed_integer_programming",
      "type": "solves"
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/BonHeuristicFPump.hpp",
      "type": "implemented_in"
    },
    {
      "from": "KKT_conditions",
      "to": "Lagrangian",
      "type": "requires"
    },
    {
      "from": "KKT_conditions",
      "to": "complementary_slackness",
      "type": "contains"
    },
    {
      "from": "LP_duality",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "LP_duality",
      "to": "Lagrangian",
      "type": "requires"
    },
    {
      "from": "LP_duality",
      "to": "complementary_slackness",
      "type": "contains"
    },
    {
      "from": "Lagrangian",
      "to": "KKT_conditions",
      "type": "contains"
    },
    {
      "from": "complementary_slackness",
      "to": "KKT_conditions",
      "type": "requires"
    },
    {
      "from": "convexity",
      "to": "convex_optimization",
      "type": "required_by"
    },
    {
      "from": "sparsity",
      "to": "LU_factorization",
      "type": "enables"
    },
    {
      "from": "LP_relaxation",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "LP_relaxation",
      "to": "branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "convexification",
      "to": "spatial_branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "convexification",
      "to": "McCormick_envelopes",
      "type": "contains"
    },
    {
      "from": "McCormick_envelopes",
      "to": "convexification",
      "type": "requires"
    },
    {
      "from": "McCormick_envelopes",
      "to": "Couenne/",
      "type": "implemented_in"
    },
    {
      "from": "basis",
      "to": "simplex_method",
      "type": "required_by"
    },
    {
      "from": "basis",
      "to": "CoinUtils/CoinFactorization.hpp",
      "type": "implemented_in"
    },
    {
      "from": "LU_factorization",
      "to": "simplex_method",
      "type": "required_by"
    },
    {
      "from": "LU_factorization",
      "to": "sparsity",
      "type": "requires"
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/CoinFactorization.hpp",
      "type": "implemented_in"
    },
    {
      "from": "presolve",
      "to": "CoinUtils/CoinPresolveMatrix.hpp",
      "type": "implemented_in"
    },
    {
      "from": "presolve",
      "to": "Clp/ClpPresolve.hpp",
      "type": "implemented_in"
    },
    {
      "from": "warm_start",
      "to": "CoinUtils/CoinWarmStart.hpp",
      "type": "implemented_in"
    },
    {
      "from": "warm_start",
      "to": "Clp/ClpSimplex.hpp",
      "type": "implemented_in"
    },
    {
      "from": "bound_tightening",
      "to": "spatial_branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "bound_tightening",
      "to": "FBBT",
      "type": "contains"
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/CouenneFixPoint.hpp",
      "type": "implemented_in"
    },
    {
      "from": "FBBT",
      "to": "bound_tightening",
      "type": "requires"
    },
    {
      "from": "FBBT",
      "to": "Couenne/CouenneFixPoint.hpp",
      "type": "implemented_in"
    },
    {
      "from": "branching",
      "to": "branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "branching",
      "to": "Cbc/CbcBranchActual.hpp",
      "type": "implemented_in"
    },
    {
      "from": "node_selection",
      "to": "branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "node_selection",
      "to": "Cbc/CbcCompareActual.hpp",
      "type": "implemented_in"
    },
    {
      "from": "linear_system_solve",
      "to": "LU_factorization",
      "type": "contains"
    },
    {
      "from": "linear_system_solve",
      "to": "newton_method",
      "type": "required_by"
    },
    {
      "from": "barrier_function",
      "to": "interior_point_method",
      "type": "required_by"
    },
    {
      "from": "hessian",
      "to": "newton_method",
      "type": "required_by"
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/",
      "type": "implemented_in"
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/",
      "type": "implemented_in"
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinBronKerbosch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bron-Kerbosch Algorithm for maximal clique enumeration"
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinSimpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinDenseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinSort.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sorting utilities for pairs, triples, and parallel arrays\n\nProvides CoinPair, CoinTriple, and sort functions for sorting\nmultiple related arrays together (e.g., indices and values)."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinWarmStartBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/AMD/Include/amd.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Approximate Minimum Degree ordering for sparse matrix factorization\n\nAMD computes a fill-reducing permutation P for sparse Cholesky or LU\nfactorization. Given a symmetric matrix A (or A+A' if A is unsymmetric),\nAMD finds P such that P*A*P' has fewer nonzeros in its Cholesky factor\nthan A would."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/UMFPACK/Include/umfpack.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/KLU/Include/klu.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex algorithm for Lift-and-Project cut generation"
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/simplex/HEkkDual.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
      }
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinSimpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
      }
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
      }
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinDenseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/CSparse/Include/cs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/UMFPACK/Include/umfpack.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/LDL/Include/ldl.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "LU_factorization",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/simplex/HEkk.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/simplex/HEkkDual.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinSimpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinPackedMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse matrix stored in compressed row or column format\n\nCoinPackedMatrix represents a sparse matrix using compressed storage.\nCan be stored row-major or column-major. Efficient for major-dimension\noperations (accessing rows in row-major, columns in column-major)."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinIndexedVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse vector with dense backing array for O(1) element access\n\nCoinIndexedVector combines sparse index storage with a dense values array,\nenabling O(1) random access while tracking which positions are non-zero.\nDesigned for simplex operations where sparse updates need fast access.\nHas optional \"packed\" mode that behaves more like CoinPackedVector."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinPackedVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse vector that owns its index/value storage\n\nCoinPackedVector stores a sparse vector as parallel arrays of indices\nand values. Unlike CoinShallowPackedVector, this class owns its storage\nand supports modification operations."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/CSparse/Include/cs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/LDL/Include/ldl.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "sparsity",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "sparsity",
      "to": "HiGHS/highs/simplex/HEkk.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
      }
    },
    {
      "from": "sparsity",
      "to": "SHOT/src/Model/Problem.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
      }
    },
    {
      "from": "basis",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
      }
    },
    {
      "from": "basis",
      "to": "CoinUtils/src/CoinWarmStartBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/AbcSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/Clp_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
      }
    },
    {
      "from": "basis",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "basis",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/simplex/HEkkDual.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
      }
    },
    {
      "from": "hessian",
      "to": "CoinUtils/src/CoinMpsIO.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MPS file format reader/writer for LP and MIP problems\n\nReads/writes standard MPS format including extensions for quadratic,\nconic, and SOS constraints. Supports free format and compression."
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core presolve data structures and action base class\n\nDefines CoinPrePostsolveMatrix (common base), CoinPresolveMatrix (for\npresolve), CoinPostsolveMatrix (for postsolve), and CoinPresolveAction\n(base class for all presolve transformations)."
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveForcing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Forcing and useless constraint detection"
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveImpliedFree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Detect and process implied free variables"
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveTighten.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds using constraint propagation"
      }
    },
    {
      "from": "presolve",
      "to": "SuiteSparse/KLU/Include/klu.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
      }
    },
    {
      "from": "presolve",
      "to": "Clp/src/ClpPresolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clp interface to CoinPresolve for LP preprocessing"
      }
    },
    {
      "from": "presolve",
      "to": "Cbc/src/CbcParameters.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central parameter collection for Cbc algorithm control\nCopyright (C) 2007, Lou Hafer, IBM Corporation and others.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcParameters: Master class holding all Cbc solver parameters.\nUsed by cbc-generic to configure and control the MIP solver.\n\nMajor subsystems configured:\n- Cut generators: Gomory, MIR, Probing, Clique, FlowCover, etc.\n- Heuristics: FPump, RINS, RENS, DINS, Diving variants, VND, etc.\n- Search strategy: Node selection, preprocessing, orbital branching\n- Limits: Time, nodes, gap tolerance, solution count\n\nIncludes instances of CGL cut generators and Cbc heuristics.\nLinks to ClpParameters for underlying LP solver control.\n\nKey methods:\n- init(): Initialize with strategy preset\n- setModel(): Associate with CbcModel\n- Various getters/setters for each parameter category\n\nStrategy presets provide common configurations:\n- Default aggressive cutting at root\n- Balanced cut/heuristic emphasis\n- Heuristic-focused for quick solutions"
      }
    },
    {
      "from": "presolve",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "cutting_planes",
      "to": "CoinUtils/src/CoinConflictGraph.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Conflict graph for binary variable incompatibilities in MIP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex algorithm for Lift-and-Project cut generation"
      }
    },
    {
      "from": "cutting_planes",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "cutting_planes",
      "to": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
      }
    },
    {
      "from": "cutting_planes",
      "to": "SHOT/src/Tasks/TaskSelectHyperplanePointsECP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended Cutting Plane point selection\n\nClassic outer approximation: linearize at infeasible points.\n\n**TaskSelectHyperplanePointsECP Class:**\n- run(): Process current MIP solutions\n- run(solPoints): Process specific solution points\n\n**ECP Algorithm:**\n- Generate gradient cut at infeasible solution\n- Simpler than ESH but may converge slower\n- Used as fallback when ESH rootsearch fails"
      }
    },
    {
      "from": "LP_duality",
      "to": "CoinUtils/src/CoinPresolveDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fix variables using dual bounds and reduced cost analysis"
      }
    },
    {
      "from": "LP_duality",
      "to": "CoinUtils/src/CoinPresolveTighten.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds using constraint propagation"
      }
    },
    {
      "from": "LP_duality",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/Clp_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
      }
    },
    {
      "from": "LP_duality",
      "to": "qpOASES/include/qpOASES/QProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
      }
    },
    {
      "from": "LP_duality",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "LP_duality",
      "to": "Dip/Dip/src/DecompAlgo.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/presolve/HPresolve.h",
      "type": "implemented_in",
      "meta": {
        "brief": "LP/MIP presolve engine\n\n**HPresolve Class:**\nReduces problem size and tightens bounds before solving.\n\n**Matrix Storage:**\nTriplet format with linked list (column) and splay tree (row) for fast access:\n- Avalue[], Arow[], Acol[]: Non-zero storage\n- colhead[], Anext[], Aprev[]: Column-wise linked list\n- rowroot[], ARleft[], ARright[]: Row-wise splay tree\n- rowsize[], colsize[]: Current row/column lengths\n\n**Bound Tracking:**\n- implColLower[]/implColUpper[]: Implied variable bounds\n- rowDualLower[]/rowDualUpper[]: Dual bounds\n- impliedRowBounds, impliedDualRowBounds: Row activity bounds\n\n**Presolve Techniques (Result enum):**\n- singletonRow()/singletonCol(): Remove singleton rows/columns\n- emptyCol(): Remove columns with no constraints\n- doubletonEq(): Eliminate doubleton equalities\n- dominatedColumns(): Remove dominated variables\n- aggregator(): Aggregate rows/columns\n- runProbing(): Probing for integer variables\n- sparsify(): Reduce matrix density\n- detectParallelRowsAndCols(): Remove parallel constraints/variables"
      }
    },
    {
      "from": "bound_tightening",
      "to": "CoinUtils/src/CoinPresolveTighten.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds using constraint propagation"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Clp/src/ClpPresolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clp interface to CoinPresolve for LP preprocessing"
      }
    },
    {
      "from": "bound_tightening",
      "to": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
      }
    },
    {
      "from": "bound_tightening",
      "to": "SHOT/src/Tasks/TaskPerformBoundTightening.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds via optimization\n\nUses optimization-based bound tightening (OBBT).\n\n**TaskPerformBoundTightening Class:**\n- POASolver: Polyhedral outer approximation solver\n- createPOA(): Build relaxed problem for bound tightening\n\n**OBBT Algorithm:**\n- For each variable: min/max subject to relaxation\n- Tightens bounds beyond constraint propagation\n- Improves relaxation quality"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    },
    {
      "from": "node_selection",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex algorithm for Lift-and-Project cut generation"
      }
    },
    {
      "from": "warm_start",
      "to": "CoinUtils/src/CoinWarmStartBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
      }
    },
    {
      "from": "warm_start",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "warm_start",
      "to": "Clp/src/Clp_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
      }
    },
    {
      "from": "warm_start",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "warm_start",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "warm_start",
      "to": "SHOT/src/NLPSolver/NLPSolverIpoptBase.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt implementation of INLPSolver interface\n\nProvides NLP solving for SHOT's primal problem using Ipopt interior point.\n\n**IpoptProblem Class (Ipopt::TNLP):**\n- Implements Ipopt's TNLP interface\n- Provides callbacks for function/gradient/Hessian evaluation\n- Sparse Jacobian/Hessian via index placement maps\n\n**TNLP Callbacks:**\n- get_nlp_info(): Problem dimensions and sparsity\n- get_bounds_info(): Variable and constraint bounds\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint function values\n- eval_jac_g(): Constraint Jacobian (sparse)\n- eval_h(): Lagrangian Hessian (sparse)\n- finalize_solution(): Store optimal point\n\n**NLPSolverIpoptBase Class:**\n- Wraps IpoptApplication for solve control\n- Variable fixing for integer-fixed NLP subproblems\n- Starting point management\n\n**IpoptJournal:**\n- Routes Ipopt output through SHOT logging system\n\n@note Used for fixed-integer NLP subproblems in primal bound computation"
      }
    },
    {
      "from": "warm_start",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "linear_programming",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "linear_programming",
      "to": "SHOT/src/Model/Problem.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Gravity/include/gravity/IpoptProgram.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt solver interface implementing TNLP callbacks\n\nAdapts Gravity models to Ipopt's TNLP (Templated NLP) interface.\n\n**IpoptProgram<type> Class:**\n- Inherits from Ipopt::TNLP and Program<type>\n- _model: Pointer to Gravity Model\n\n**Required TNLP Callbacks:**\n- get_nlp_info(): Return problem dimensions (n, m, nnz_jac, nnz_hess)\n- get_bounds_info(): Variable and constraint bounds\n- get_starting_point(): Initial x, z_L, z_U, lambda\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint values\n- eval_jac_g(): Jacobian values and structure\n- eval_h(): Hessian of Lagrangian\n- finalize_solution(): Copy solution back to model\n\n**Sparsity Pattern:**\n- First call to eval_jac_g/eval_h: return structure (iRow, jCol)\n- Subsequent calls: return values only\n- Gravity tracks via _first_call_jac, _first_call_hess\n\n**Solution Recovery:**\n- finalize_solution() copies x values to model variables\n- Retrieves dual values (lambda) for constraints\n- Retrieves bound multipliers (z_L, z_U)"
      }
    },
    {
      "from": "interior_point_method",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem.\n\n**DualSolver Class:**\n- MIPSolver: Backend MIP solver (CPLEX/Gurobi/CBC/HiGHS)\n- generatedHyperplanes: All cutting planes added\n- hyperplaneWaitingList: Pending cuts to add\n\n**Hyperplane Management:**\n- addHyperplane(): Add supporting hyperplane cut\n- addGeneratedHyperplane(): Record a hyperplane\n- hasHyperplaneBeenAdded(): Avoid duplicate cuts\n\n**Integer Cuts:**\n- addIntegerCut(): Add no-good cuts for MINLP\n- generatedIntegerCuts: All integer cuts\n\n**Interior Points:**\n- interiorPointCandidates: Candidate interior points\n- interiorPts: Verified interior points for ESH"
      }
    },
    {
      "from": "interior_point_method",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyNLP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Direct NLP solver for continuous problems\n\nBypasses ESH for purely continuous NLP problems.\n\n**SolutionStrategyNLP Class:**\n- initializeStrategy(): Configure for direct NLP solve\n- solveProblem(): Single NLP solver call (Ipopt)\n\n**Use Case:**\n- Problems with no integer variables\n- Convex NLP where outer approximation is unnecessary\n- Falls back to standard NLP solvers (Ipopt)\n\n**When Selected:**\n- Problem type is NLP (no discrete variables)\n- Simpler than ESH for continuous problems"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "newton_method",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "branching",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "branching",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/include/cppad/cppad.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Contains all variables and functions defined by CppAD package"
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/drivers/drivers.h",
      "type": "implemented_in",
      "meta": {
        "brief": "High-level driver functions for derivative computation\n\nProvides convenient functions for computing common derivative quantities:\n- gradient(): First derivative of scalar function (\u2207f)\n- jacobian(): First derivative of vector function (\u2202F/\u2202x)\n- hessian(): Second derivative of scalar function (\u2207\u00b2f)\n- hess_vec(): Hessian-vector product (\u2207\u00b2f \u00b7 v)\n- jac_vec(): Jacobian-vector product (J \u00b7 v)\n- vec_jac(): Vector-Jacobian product (u^T \u00b7 J)\n\nThese drivers wrap the lower-level forward/reverse interfaces and handle\nmemory allocation and mode selection automatically. All functions require\na pre-recorded tape (via trace_on/trace_off)."
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/QProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/QProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cbc/src/CbcModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Dip/Dip/src/DecompAlgo.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem.\n\n**DualSolver Class:**\n- MIPSolver: Backend MIP solver (CPLEX/Gurobi/CBC/HiGHS)\n- generatedHyperplanes: All cutting planes added\n- hyperplaneWaitingList: Pending cuts to add\n\n**Hyperplane Management:**\n- addHyperplane(): Add supporting hyperplane cut\n- addGeneratedHyperplane(): Record a hyperplane\n- hasHyperplaneBeenAdded(): Avoid duplicate cuts\n\n**Integer Cuts:**\n- addIntegerCut(): Add no-good cuts for MINLP\n- generatedIntegerCuts: All integer cuts\n\n**Interior Points:**\n- interiorPointCandidates: Candidate interior points\n- interiorPts: Verified interior points for ESH"
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyMultiTree.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Iterative outer approximation strategy (multi-tree)\n\nClassic outer approximation loop for convex MINLP.\n\n**Algorithm Pattern:**\n1. Solve MIP relaxation to get candidate point\n2. Generate supporting hyperplanes at violated points\n3. Add cuts to MIP and resolve\n4. Repeat until convergence or termination\n\n**Task Flow (initializeStrategy):**\n- CreateDualProblem \u2192 SolveIteration \u2192 SelectHyperplanes\n- AddHyperplanes \u2192 CheckTermination \u2192 loop\n\n**Advantages:**\n- No callback complexity\n- Can use any MIP solver\n- Easier debugging/logging\n\n**Disadvantages:**\n- Multiple MIP solves\n- May regenerate same B&B tree work"
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/MIPSolver/MIPSolverCbc.h",
      "type": "implemented_in",
      "meta": {
        "brief": "COIN-OR Cbc implementation of IMIPSolver interface\n\nProvides open-source MIP solving using Cbc branch-and-cut solver.\n\n**MIPSolverCbc Class:**\n- Implements IMIPSolver interface\n- Uses OsiClpSolverInterface for LP subproblems\n- CbcModel for branch-and-cut\n- CoinModel for problem construction\n\n**Key Data Structures:**\n- osiInterface: OSI LP solver (Clp)\n- cbcModel: MIP solver model\n- coinModel: Problem builder\n- objectiveLinearExpression: CoinPackedVector\n\n**CbcMessageHandler:**\n- Custom message handler for SHOT logging\n- Routes Cbc output through SHOT's Output system\n\n**Limitations:**\n- supportsQuadraticObjective(): No\n- supportsQuadraticConstraints(): No\n- LP/MIP only (no MIQP/QCQP)\n\n@note Default open-source MIP solver, no license required"
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    },
    {
      "from": "convexity",
      "to": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
      }
    },
    {
      "from": "nonlinear_programming",
      "to": "SHOT/src/Model/Problem.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
      }
    },
    {
      "from": "mixed_integer_programming",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    }
  ],
  "stats": {
    "concept_count": 41,
    "relationship_count": 263
  }
}