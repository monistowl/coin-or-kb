{
  "version": "1.0",
  "concepts": {
    "linear_programming": {
      "id": "linear_programming",
      "name": "Linear Programming",
      "category": "problem_class",
      "definition": "Optimization with linear objective and linear constraints. min c^T x  s.t.  Ax \u2264 b, x \u2265 0",
      "intuition": "Find the best point in a convex polytope. Optimal solution always at a vertex.",
      "aliases": [
        "LP"
      ],
      "key_equations": [
        "min c^T x",
        "Ax \u2264 b",
        "x \u2265 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexity"
          }
        ],
        "generalizes": [
          {
            "id": "quadratic_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpConstraintLinear.hpp",
            "meta": {
              "brief": "Linear constraint implementation for nonlinear extensions\n\nImplements ClpConstraint for a linear constraint: sum(a_j * x_j) = b.\nUsed with ClpSimplexNonlinear when linear constraints appear alongside\nnonlinear objective or other nonlinear constraints."
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpConstraintQuadratic.hpp",
            "meta": {
              "brief": "Quadratic constraint implementation: x'Qx + c'x \u2264 b\n\nImplements ClpConstraint for quadratic constraints. The constraint\nfunction is: 0.5 * sum_{ij}(Q_ij * x_i * x_j) + sum_j(c_j * x_j) \u2264 b"
            }
          },
          {
            "id": "Cbc/src/CbcLinked.hpp",
            "meta": {
              "brief": "Extended solver for nonlinear and bilinear problems"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_enum_process_t.hpp",
            "meta": {
              "brief": "Process type enumeration for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_branch.hpp",
            "meta": {
              "brief": "Internal branching object for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp.hpp",
            "meta": {
              "brief": "LP process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_math.hpp",
            "meta": {
              "brief": "Mathematical constants for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart_dual.hpp",
            "meta": {
              "brief": "Dual-only warm start for BCP"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
            "meta": {
              "brief": "Abstract interface for NLP solvers used in branch-and-bound"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
            "meta": {
              "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
            }
          },
          {
            "id": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
            "meta": {
              "brief": "NLP heuristic for near-integer B&B nodes"
            }
          },
          {
            "id": "SHOT/src/Model/Problem.h",
            "meta": {
              "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
            }
          }
        ]
      }
    },
    "quadratic_programming": {
      "id": "quadratic_programming",
      "name": "Quadratic Programming",
      "category": "problem_class",
      "definition": "Optimization with quadratic objective and linear constraints. min (1/2)x^T Q x + c^T x  s.t.  Ax \u2264 b",
      "intuition": "LP plus a bowl-shaped or saddle-shaped objective. Convex if Q is positive semidefinite.",
      "aliases": [
        "QP"
      ],
      "key_equations": [
        "min (1/2)x^T Q x + c^T x",
        "Ax \u2264 b"
      ],
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          }
        ],
        "generalizes": [
          {
            "id": "nonlinear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Refinement.hpp",
            "meta": {
              "brief": "Partition projection during uncoarsening phase\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nRefinement projects partition from coarse to fine graph during\nuncoarsening. Maps coarse partition to fine vertices via inverse\nmatchmap, then applies FM/QP improvement (waterdance) at each level\nfor high-quality final partition."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPGradProj.hpp",
            "meta": {
              "brief": "Projected gradient descent for QP partition optimization\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPGradProj implements gradient projection for bound-constrained QP:\nminimizes quadratic cut objective subject to box constraints [0,1]\nand balance constraint (lo <= a'x <= hi). Projects gradient onto\nfeasible region, iterates until convergence or iteration limit."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPMaxHeap.hpp",
            "meta": {
              "brief": "Max-heap for QP napsack breakpoint processing\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPMaxHeap provides max-heap operations (build, delete, add, heapify)\nfor efficient breakpoint processing in napsack solver. Extracts\nbreakpoints in descending order, complementing min-heap for\nbidirectional lambda search."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_ImproveQP.hpp",
            "meta": {
              "brief": "Quadratic programming partition improvement via continuous relaxation\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQP improvement relaxes discrete partition to continuous [0,1] variables,\noptimizes via gradient projection with balance constraints, then rounds\nto discrete partition. Complements FM by exploring continuous solution\nspace; combined in waterdance for best results."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Internal.hpp",
            "meta": {
              "brief": "Internal type definitions and enumerations for Mongoose\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nDefines Int type (int64_t), matching strategies (Random, HEM, HEMSR,\nHEMSRdeg), initial cut types (QP, Random, NaturalOrder), and match\ntypes (Orphan, Standard, Brotherly, Community) used throughout Mongoose."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPMinHeap.hpp",
            "meta": {
              "brief": "Min-heap for QP napsack breakpoint processing\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPMinHeap provides min-heap operations (build, delete, add, heapify)\nfor efficient breakpoint processing in napsack solver. Extracts\nbreakpoints in ascending order to find optimal lambda for balance\nconstraint satisfaction."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPLinks.hpp",
            "meta": {
              "brief": "QP free set rounding and partition conversion\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPLinks converts continuous QP solution to discrete partition by\nrounding fractional variables and updating free set. Handles the\ninterface between continuous relaxation and discrete partition\nrepresentation in the waterdance refinement cycle."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_EdgeCut.hpp",
            "meta": {
              "brief": "Edge cut result structure and partitioning entry points\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nEdgeCut struct holds partitioning results: boolean partition array,\ncut_cost (edge weight sum), cut_size (edge count), partition weights\n(w0, w1), and imbalance metric. edge_cut() functions are main entry\npoints for computing graph partitions."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPBoundary.hpp",
            "meta": {
              "brief": "QP boundary initialization from graph partition\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPBoundary initializes QP state from discrete partition, setting\nx values based on partition assignment and identifying boundary\nvertices (those with neighbors in opposite partition) as the\nactive set for optimization."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose.hpp",
            "meta": {
              "brief": "Main public API for Mongoose graph partitioning library\nCopyright (C) 2017-2018, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nMongoose: High-quality graph partitioning via multilevel coarsening\nwith Fiduccia-Mattheyses and quadratic programming refinement.\nPublic interface includes Graph, EdgeCut, EdgeCut_Options classes\nand read_graph/edge_cut functions for partitioning workflows."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPDelta.hpp",
            "meta": {
              "brief": "QP solver state: solution, gradient, free set, and workspace\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPDelta stores iterative QP solver state: current solution x, gradient,\nfree set (variables not at bounds), balance constraint bounds (lo/hi),\nLagrange multiplier lambda, and workspace arrays. FreeSet_status tracks\nwhether each x_i is at 0, 1, or strictly between (free)."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_GuessCut.hpp",
            "meta": {
              "brief": "Initial partition generation at coarsest level\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nGuessCut creates initial partition for coarsest graph before refinement\nbegins. Strategies include QP relaxation, random assignment, or natural\nvertex order. Quality of initial guess affects final partition quality\ndespite refinement. Selected via initial_cut_type option."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_EdgeCutOptions.hpp",
            "meta": {
              "brief": "Configuration options for edge cut partitioning algorithms\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nEdgeCut_Options controls all algorithm parameters: coarsening (limit,\nmatching strategy, community detection), initial cut type (QP/random),\nFiduccia-Mattheyses (search depth, refinement count), QP gradient\nprojection (tolerance, iteration limit), and partition targets\n(split ratio, balance tolerance)."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPNapDown.hpp",
            "meta": {
              "brief": "Downward lambda search in napsack solver\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPNapDown searches for lambda in decreasing direction when current\nsolution violates lower balance bound (b < lo). Processes breakpoints\nvia heaps until constraint is satisfied, returning optimal lambda."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Waterdance.hpp",
            "meta": {
              "brief": "Alternating FM/QP refinement passes for partition improvement\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nWaterdance alternates between FM (discrete swaps) and QP (continuous\noptimization) refinement passes. The interplay (\"dance\") between methods\nescapes local minima that either method alone would get stuck in.\nNumber of dances controlled by num_dances option."
            }
          },
          {
            "id": "Clp/src/ClpConstraint.hpp",
            "meta": {
              "brief": "Abstract base class for nonlinear constraints\n\nDefines the interface for general (potentially nonlinear) constraints\nused in nonlinear programming extensions. The standard LP constraints\n(Ax \u2264 b) are handled directly by ClpModel; this class is for more\ngeneral constraint forms g(x) \u2264 0."
            }
          },
          {
            "id": "Clp/src/ClpQuadraticObjective.hpp",
            "meta": {
              "brief": "Quadratic objective function for convex QP (x'Qx/2 + c'x)\n\nImplements convex quadratic objectives for quadratic programming.\nThe quadratic term is stored as a CoinPackedMatrix Q, supporting\nboth full symmetric and half (lower triangular) storage."
            }
          },
          {
            "id": "Clp/src/ClpPrimalQuadraticDantzig.hpp",
            "meta": {
              "brief": "Dantzig-style pricing for quadratic programming\n\nExtends ClpPrimalColumnPivot for QP problems where the reduced cost\ndepends on the current solution (due to the quadratic objective)."
            }
          },
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/ConstraintProduct.hpp",
            "meta": {
              "brief": "User-defined constraint evaluation interface for structured matrices"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SparseSolver.hpp",
            "meta": {
              "brief": "Sparse linear solver interfaces for Schur-complement QP method"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
            "meta": {
              "brief": "Sparse QP solver using Schur complement for active-set updates"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Bounds.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Constraints.hpp",
            "meta": {
              "brief": "Working set management for general constraints in active-set QP"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblem.hpp",
            "meta": {
              "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Indexlist.hpp",
            "meta": {
              "brief": "Sorted index lists for efficient working set operations"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblem.hpp",
            "meta": {
              "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Flipper.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Matrices.hpp",
            "meta": {
              "brief": "Matrix classes for QP data with working-set-aware operations"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SubjectTo.hpp",
            "meta": {
              "brief": "Base class for working set management in active-set QP"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/SolutionAnalysis.hpp",
            "meta": {
              "brief": "Post-optimality analysis: KKT verification and sensitivity"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
            "meta": {
              "brief": "Online QP Benchmark Collection interface"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
            "meta": {
              "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
            "meta": {
              "brief": "Abstract base class for strong branching NLP solves"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
            "meta": {
              "brief": "Abstract interface for NLP solvers used in branch-and-bound"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
            "meta": {
              "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
            "meta": {
              "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "Gravity/include/gravity/model.h",
            "meta": {
              "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/devexpricing.hpp",
            "meta": {
              "brief": "HiGHS Devex pricing for QP active set method\n\nDevex pricing strategy: approximate steepest edge using\nreference framework with periodic weight updates."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/factor.hpp",
            "meta": {
              "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
            "meta": {
              "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/basis.hpp",
            "meta": {
              "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
            "meta": {
              "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
            }
          }
        ]
      }
    },
    "nonlinear_programming": {
      "id": "nonlinear_programming",
      "name": "Nonlinear Programming",
      "category": "problem_class",
      "definition": "Optimization with nonlinear objective or constraints. min f(x)  s.t.  g(x) \u2264 0, h(x) = 0",
      "intuition": "General smooth optimization. Find local optima; global optimality only guaranteed if convex.",
      "aliases": [
        "NLP"
      ],
      "key_equations": [
        "min f(x)",
        "g(x) \u2264 0",
        "h(x) = 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "quadratic_programming"
          },
          {
            "id": "KKT_conditions"
          }
        ],
        "implemented_in": [
          {
            "id": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
            "meta": {
              "brief": "Abstract interface for NLP solvers used in branch-and-bound"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
            "meta": {
              "brief": "NLP heuristic for near-integer B&B nodes"
            }
          },
          {
            "id": "SHOT/src/Model/Problem.h",
            "meta": {
              "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
            }
          }
        ]
      }
    },
    "mixed_integer_programming": {
      "id": "mixed_integer_programming",
      "name": "Mixed-Integer Programming",
      "category": "problem_class",
      "definition": "Linear programming with some integer-constrained variables. min c^T x  s.t.  Ax \u2264 b, x_i \u2208 Z for i \u2208 I",
      "intuition": "LP with discrete choices. NP-hard in general; solved via branch-and-bound with LP relaxations.",
      "aliases": [
        "MIP",
        "MILP"
      ],
      "key_equations": [
        "min c^T x",
        "Ax \u2264 b",
        "x_i \u2208 Z"
      ],
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          },
          {
            "id": "LP_relaxation"
          }
        ],
        "generalizes": [
          {
            "id": "mixed_integer_nonlinear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Cbc/src/CbcBranchAllDifferent.hpp",
            "meta": {
              "brief": "All-different constraint for integer variables\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchAllDifferent: Enforces that a set of integer variables\nmust all have different values. When two variables i,j have the\nsame value, creates branching disjunction:\n  x_i <= x_j - 1  OR  x_i >= x_j + 1"
            }
          },
          {
            "id": "Cgl/src/CglTwomir/CglTwomir.hpp",
            "meta": {
              "brief": "Two-step MIR (TMIR) cut generator\n\nGenerates tMIR and 2-step MIR cuts by applying the MIR inequality\nrecursively with different scaling factors. More general than\nsimple Gomory or MIR cuts."
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
            "meta": {
              "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
            "meta": {
              "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
            }
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
            }
          },
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "mixed_integer_nonlinear_programming": {
      "id": "mixed_integer_nonlinear_programming",
      "name": "Mixed-Integer Nonlinear Programming",
      "category": "problem_class",
      "definition": "Nonlinear programming with some integer-constrained variables. min f(x,y)  s.t.  g(x,y) \u2264 0, y \u2208 Z^m",
      "intuition": "Combines discrete choices with nonlinear physics. Convex MINLP is tractable; nonconvex needs global methods.",
      "aliases": [
        "MINLP"
      ],
      "key_equations": [
        "min f(x,y)",
        "g(x,y) \u2264 0",
        "y \u2208 Z^m"
      ],
      "relationships": {
        "requires": [
          {
            "id": "nonlinear_programming"
          },
          {
            "id": "mixed_integer_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
            "meta": {
              "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
            "meta": {
              "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
            "meta": {
              "brief": "Abstract base class for strong branching NLP solves"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
            "meta": {
              "brief": "Abstract interface for NLP solvers used in branch-and-bound"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP.hpp",
            "meta": {
              "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
            "meta": {
              "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
            "meta": {
              "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
            "meta": {
              "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic for MINLP\n\nImplements the Feasibility Pump algorithm adapted for nonlinear problems.\nAlternates between:\n1. Rounding to nearest integer solution\n2. Projecting back to feasible continuous space via NLP\n\n**Classes:**\n- HeuristicFPump: Main feasibility pump heuristic (CbcHeuristic)\n- RoundingFPump: Helper for intelligent rounding considering constraints"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
            "meta": {
              "brief": "Base class for heuristics using local NLP/MINLP solves"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonFixAndSolveHeuristic.hpp",
            "meta": {
              "brief": "Fix-and-Solve heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicLocalBranching.hpp",
            "meta": {
              "brief": "Local Branching heuristic for MINLP improvement"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
            "meta": {
              "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonMilpRounding.hpp",
            "meta": {
              "brief": "MILP-based rounding heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
            "meta": {
              "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
            "meta": {
              "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
            "meta": {
              "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
            "meta": {
              "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaDecBase.hpp",
            "meta": {
              "brief": "Base class for Outer Approximation (OA) decomposition algorithms\n\nImplements the foundation for OA-based MINLP algorithms. OA iterates between\nsolving MILP subproblems and NLP subproblems, generating linear outer\napproximations of the nonlinear constraints.\n\n**OA algorithm outline:**\n1. Solve MILP relaxation \u2192 get integer solution x*\n2. Fix integers to x*, solve NLP \u2192 get nonlinear solution y*\n3. Generate linearization cuts at y* (gradient-based)\n4. Add cuts to MILP, repeat until convergence\n\n**Key components:**\n- solverManip: RAII helper to save/restore solver state\n- performOa(): Virtual method implementing specific OA variant\n- post_nlp_solve(): Handle NLP solution and update bounds\n\n**Parameters:**\n- global_: Add cuts globally (valid at all nodes)\n- addOnlyViolated_: Only add cuts violated by current solution\n- maxLocalSearch_: Limit on local search iterations"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
            "meta": {
              "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
            "meta": {
              "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
            }
          },
          {
            "id": "Bonmin/experimental/Separable/BonHeuristicInnerApproximation.hpp",
            "meta": {
              "brief": "Bonmin inner approximation heuristic for MINLP\n\nPrimal heuristic using inner approximation of feasible region.\nGenerates feasible MINLP solutions from LP relaxations."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection for branching in global optimization"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneNauty.hpp",
            "meta": {
              "brief": "Interface to nauty library for symmetry detection\n\nWraps the nauty graph automorphism library to detect symmetries\nin MINLP problems. Symmetry information enables orbital branching\nand isomorphism pruning to reduce the search space."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneChooseStrong.hpp",
            "meta": {
              "brief": "Strong branching for global MINLP optimization\n\nExtends Bonmin's strong branching to handle nonconvex constraints\nby evaluating actual LP bound improvement from branching."
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "Couenne/src/problem/CouenneProblem.hpp",
            "meta": {
              "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneFeasPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
            }
          },
          {
            "id": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
            "meta": {
              "brief": "NLP heuristic for near-integer B&B nodes"
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "Gravity/include/gravity/model.h",
            "meta": {
              "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
            }
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
            }
          }
        ]
      }
    },
    "convex_optimization": {
      "id": "convex_optimization",
      "name": "Convex Optimization",
      "category": "problem_class",
      "definition": "Optimization where objective and feasible region are convex. Any local minimum is global minimum.",
      "intuition": "The \"easy\" class of optimization. Polynomial-time algorithms exist; no need to worry about local optima.",
      "relationships": {
        "requires": [
          {
            "id": "convexity"
          }
        ],
        "contains": [
          {
            "id": "linear_programming"
          },
          {
            "id": "quadratic_programming"
          }
        ]
      }
    },
    "nonconvex_optimization": {
      "id": "nonconvex_optimization",
      "name": "Nonconvex Optimization",
      "category": "problem_class",
      "definition": "Optimization where convexity does not hold. Local optima may not be global; exhaustive search or clever bounding required.",
      "intuition": "The \"hard\" class. Must actively search for global optimum or prove bounds.",
      "aliases": [
        "global optimization"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexification"
          }
        ]
      }
    },
    "simplex_method": {
      "id": "simplex_method",
      "name": "Simplex Method",
      "category": "algorithm",
      "definition": "Iteratively moves between adjacent vertices of the feasible polytope, improving objective at each step until optimal vertex reached.",
      "intuition": "Walk along edges of the polytope, always going \"downhill\". Worst-case exponential but fast in practice.",
      "aliases": [
        "simplex algorithm"
      ],
      "key_equations": [
        "Select entering variable: max reduced cost",
        "Select leaving variable: min ratio test",
        "Pivot: update basis"
      ],
      "relationships": {
        "requires": [
          {
            "id": "LU_factorization"
          },
          {
            "id": "basis"
          }
        ],
        "solves": [
          {
            "id": "linear_programming"
          }
        ],
        "contains": [
          {
            "id": "dual_simplex"
          },
          {
            "id": "primal_simplex"
          }
        ],
        "alternative_to": [
          {
            "id": "interior_point_method"
          },
          {
            "id": "interior_point_method"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinBronKerbosch.hpp",
            "meta": {
              "brief": "Bron-Kerbosch Algorithm for maximal clique enumeration"
            }
          },
          {
            "id": "CoinUtils/src/CoinWarmStart.hpp",
            "meta": {
              "brief": "Abstract interfaces for warm start information in optimization solvers"
            }
          },
          {
            "id": "CoinUtils/src/CoinSimpFactorization.hpp",
            "meta": {
              "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
            }
          },
          {
            "id": "CoinUtils/src/CoinFactorization.hpp",
            "meta": {
              "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
            }
          },
          {
            "id": "CoinUtils/src/CoinOslFactorization.hpp",
            "meta": {
              "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
            }
          },
          {
            "id": "CoinUtils/src/CoinDenseFactorization.hpp",
            "meta": {
              "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
            }
          },
          {
            "id": "CoinUtils/src/CoinSort.hpp",
            "meta": {
              "brief": "Sorting utilities for pairs, triples, and parallel arrays\n\nProvides CoinPair, CoinTriple, and sort functions for sorting\nmultiple related arrays together (e.g., indices and values)."
            }
          },
          {
            "id": "CoinUtils/src/CoinWarmStartBasis.hpp",
            "meta": {
              "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
            }
          },
          {
            "id": "SuiteSparse/ParU/Source/paru_internal.hpp",
            "meta": {
              "brief": "Internal data structures and functions for ParU sparse LU\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis.\nGPL-3.0-or-later license.\n\nCore ParU structures: ParU_Symbolic_struct (row-form S, singletons, fronts,\ntask tree), ParU_Numeric_struct (LU factors, permutations, scaling),\nParU_Control_struct (tolerances, threading). paru_element (contribution\nblock), paru_work (workspace), paru_tuple (element lists). Internal\nfunctions: front assembly/factorization, heap management, BLAS threading.\nIncludes UMFPACK SymbolicType/SWType for singleton detection."
            }
          },
          {
            "id": "SuiteSparse/AMD/Include/amd.h",
            "meta": {
              "brief": "Approximate Minimum Degree ordering for sparse matrix factorization\n\nAMD computes a fill-reducing permutation P for sparse Cholesky or LU\nfactorization. Given a symmetric matrix A (or A+A' if A is unsymmetric),\nAMD finds P such that P*A*P' has fewer nonzeros in its Cholesky factor\nthan A would."
            }
          },
          {
            "id": "SuiteSparse/UMFPACK/Include/umfpack.h",
            "meta": {
              "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
            }
          },
          {
            "id": "SuiteSparse/UMFPACK/Source/umf_internal.h",
            "meta": {
              "brief": "Internal definitions for UMFPACK sparse LU factorization\nCopyright (c) 2005-2023, Timothy A. Davis. GPL-2.0+ license.\n\nUMFPACK is an unsymmetric multifrontal sparse LU factorization package.\nComputes P\u00b7A\u00b7Q = L\u00b7U via supernodal factorization with partial pivoting.\nHandles real and complex matrices in single and double precision."
            }
          },
          {
            "id": "SuiteSparse/KLU/Include/klu.h",
            "meta": {
              "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
            }
          },
          {
            "id": "SuiteSparse/KLU/Include/klu_internal.h",
            "meta": {
              "brief": "Internal definitions for KLU sparse LU factorization\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nKLU is a sparse LU factorization package designed for circuit simulation\nmatrices, which are typically highly sparse with near-diagonal structure.\nUses BTF (Block Triangular Form) permutation to exploit structure."
            }
          },
          {
            "id": "SuiteSparse/CHOLMOD/Include/cholmod_internal.h",
            "meta": {
              "brief": "Internal definitions for CHOLMOD sparse Cholesky factorization\nCopyright (C) 2005-2023, Timothy A. Davis. Apache-2.0 license.\n\nCHOLMOD is a comprehensive sparse Cholesky factorization package supporting\nsupernodal and simplicial methods, update/downdate, and multiple orderings.\nHandles symmetric positive definite systems A\u00b7x = b via L\u00b7L' = A."
            }
          },
          {
            "id": "SuiteSparse/ParU/Include/ParU.h",
            "meta": {
              "brief": "Parallel unsymmetric multifrontal sparse LU factorization\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis. GPL-3.0-or-later.\n\nParU is a parallel sparse direct solver using OpenMP tasking for task-based\nparallelism combined with parallel BLAS (nested parallelism). Solves Ax = b\nfor sparse A via LU factorization with partial pivoting."
            }
          },
          {
            "id": "Clp/src/AbcDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for ABC dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpGubMatrix.hpp",
            "meta": {
              "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/ClpNonLinearCost.hpp",
            "meta": {
              "brief": "Piecewise linear cost handling and bound infeasibility tracking\n\nManages piecewise linear objective functions and tracks bound violations\nduring primal simplex. When variables move outside their bounds, this class\ncomputes the appropriate infeasibility penalty costs."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyPardiso.hpp",
            "meta": {
              "brief": "Intel MKL Pardiso sparse direct solver for Cholesky factorization\n\nWraps Intel's Pardiso solver from the Math Kernel Library (MKL) for\nCholesky factorization of normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/AbcMatrix.hpp",
            "meta": {
              "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyUfl.hpp",
            "meta": {
              "brief": "SuiteSparse CHOLMOD interface for Cholesky factorization\n\nWraps the CHOLMOD library from SuiteSparse (University of Florida) for\nCholesky factorization of normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/AbcSimplexPrimal.hpp",
            "meta": {
              "brief": "AVX-optimized primal simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpNetworkMatrix.hpp",
            "meta": {
              "brief": "Specialized matrix for pure network LP problems\n\nImplements efficient storage for network flow problems where each column\n(arc) has exactly two nonzeros: +1 at the head node and -1 at the tail node.\nThis representation requires only O(n) storage for row indices vs O(2n) for\na general sparse matrix."
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpPEPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Positive Edge enhanced Dantzig pricing for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpPEPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Positive Edge enhanced steepest edge for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpSolve.hpp",
            "meta": {
              "brief": "Algorithm selection and configuration for ClpSimplex::initialSolve()"
            }
          },
          {
            "id": "Clp/src/AbcWarmStart.hpp",
            "meta": {
              "brief": "Extended warm start with factorization caching for ABC"
            }
          },
          {
            "id": "Clp/src/CoinAbcCommon.hpp",
            "meta": {
              "brief": "Common definitions for ABC (A Better Coin) optimized simplex"
            }
          },
          {
            "id": "Clp/src/ClpDualRowDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyWssmpKKT.hpp",
            "meta": {
              "brief": "WSSMP solver for KKT system (augmented system) formulation\n\nVariant of ClpCholeskyWssmp that solves the KKT/augmented system directly\ninstead of forming and factoring the normal equations A*D*A'."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyMumps.hpp",
            "meta": {
              "brief": "MUMPS sparse direct solver interface for Cholesky factorization\n\nWraps the MUMPS (MUltifrontal Massively Parallel sparse direct Solver)\nlibrary for Cholesky factorization of normal equations in interior point."
            }
          },
          {
            "id": "Clp/src/AbcCommon.hpp",
            "meta": {
              "brief": "Configuration macros for ABC (A Better Clp) build modes"
            }
          },
          {
            "id": "Clp/src/ClpEventHandler.hpp",
            "meta": {
              "brief": "Callback interface for handling solver events during optimization\n\nProvides a mechanism for user code to receive callbacks during the solve\nprocess. Users derive from ClpEventHandler and override event() to handle\nevents like end of iteration, factorization, or presolve stages."
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplexDual.hpp",
            "meta": {
              "brief": "AVX-optimized dual simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpSolver.hpp",
            "meta": {
              "brief": "Standalone Clp solver driver and command-line interface"
            }
          },
          {
            "id": "Clp/src/ClpSimplexOther.hpp",
            "meta": {
              "brief": "Auxiliary simplex operations: ranging, parametrics, and utilities"
            }
          },
          {
            "id": "Clp/src/AbcPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex for ABC primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplexNonlinear.hpp",
            "meta": {
              "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
            }
          },
          {
            "id": "Clp/src/AbcDualRowDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for ABC dual simplex pivot selection"
            }
          },
          {
            "id": "Clp/src/ClpNetworkBasis.hpp",
            "meta": {
              "brief": "Specialized factorization for pure network problems"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnPivot.hpp",
            "meta": {
              "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
            }
          },
          {
            "id": "Clp/src/ClpDualRowPivot.hpp",
            "meta": {
              "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/CoinAbcDenseFactorization.hpp",
            "meta": {
              "brief": "Abstract base class for ABC factorization and dense submatrix handling"
            }
          },
          {
            "id": "Clp/src/ClpPEDualRowDantzig.hpp",
            "meta": {
              "brief": "Positive Edge enhanced Dantzig pricing for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpPEDualRowSteepest.hpp",
            "meta": {
              "brief": "Positive Edge enhanced steepest edge for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpPESimplex.hpp",
            "meta": {
              "brief": "Positive Edge anti-degeneracy framework for simplex"
            }
          },
          {
            "id": "Clp/src/AbcPrimalColumnPivot.hpp",
            "meta": {
              "brief": "Abstract base class for primal pivot column selection in ABC"
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "Osi/src/Osi/OsiRowCut.hpp",
            "meta": {
              "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SparseSolver.hpp",
            "meta": {
              "brief": "Sparse linear solver interfaces for Schur-complement QP method"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Constraints.hpp",
            "meta": {
              "brief": "Working set management for general constraints in active-set QP"
            }
          },
          {
            "id": "Cbc/src/CbcSolverHeuristics.hpp",
            "meta": {
              "brief": "Heuristic setup and execution routines for cbc-generic"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicPivotAndFix.hpp",
            "meta": {
              "brief": "Pivot and Fix heuristic using simplex pivots\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicPivotAndFix: Exploits LP basis structure.\nPerforms simplex pivots to explore nearby basic solutions,\nthen fixes integer variables at their current values."
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Cgl/src/CglRedSplit/CglRedSplit.hpp",
            "meta": {
              "brief": "Reduce-and-Split cuts for enhanced Gomory generation"
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandP.hpp",
            "meta": {
              "brief": "Lift-and-Project cuts via simplex pivoting"
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
            "meta": {
              "brief": "Simplex algorithm for Lift-and-Project cut generation"
            }
          },
          {
            "id": "Cgl/src/CglBKClique/CglBKClique.hpp",
            "meta": {
              "brief": "Clique cut separator using Bron-Kerbosch algorithm"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpDenseGenMatrix.hpp",
            "meta": {
              "brief": "Dense general (non-symmetric) matrix with linear algebra operations\n\nDenseGenMatrix stores elements in column-major (Fortran) format\nand provides direct factorization capabilities:\n- Cholesky factorization (for positive definite matrices)\n- LU factorization with pivoting (for general matrices)\n- Forward/back substitution solves"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpLapack.hpp",
            "meta": {
              "brief": "C++ wrappers for LAPACK (Linear Algebra PACKage) routines\n\nProvides platform-independent access to LAPACK for dense matrices."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
            "meta": {
              "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoMKLSolverInterface.hpp",
            "meta": {
              "brief": "Interface to Intel MKL PARDISO sparse solver\n\nPardisoMKLSolverInterface wraps Intel's MKL implementation of PARDISO.\nWhile sharing the same API as pardiso-project.org's version, Intel MKL\nPARDISO has some differences in features and behavior."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMc19TSymScalingMethod.hpp",
            "meta": {
              "brief": "Matrix scaling using HSL MC19 equilibration\n\nMc19TSymScalingMethod uses the HSL subroutine MC19 to compute\nequilibration scaling factors for symmetric matrices."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpWsmpSolverInterface.hpp",
            "meta": {
              "brief": "Interface to IBM WSMP sparse symmetric direct solver\n\nWsmpSolverInterface wraps the Watson Sparse Matrix Package (WSMP),\na high-performance parallel direct solver developed at IBM for\nsparse symmetric indefinite linear systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMumpsSolverInterface.hpp",
            "meta": {
              "brief": "Interface to MUMPS parallel sparse direct solver\n\nMumpsSolverInterface wraps MUMPS (MUltifrontal Massively Parallel\nsparse direct Solver), a freely available solver supporting MPI\nparallelism for distributed memory systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTSymScalingMethod.hpp",
            "meta": {
              "brief": "Base class for matrix scaling in triplet format\n\nTSymScalingMethod is the abstract base class for computing diagonal\nscaling factors for symmetric matrices. Scaling improves numerical\nconditioning of the linear system.\n\nScaling transformation:\n  Original: A * x = b\n  Scaled:   (D*A*D) * (D^{-1}*x) = D*b\nwhere D = diag(scaling_factors).\n\nThe ComputeSymTScalingFactors method takes:\n- n: matrix dimension\n- nnz: number of nonzeros\n- airn, ajcn: row/column indices (triplet format)\n- a: matrix values\n- scaling_factors: output array of length n\n\nImplementations:\n- Mc19TSymScalingMethod: HSL MC19 equilibration\n- SlackBasedTSymScalingMethod: Simple slack-based scaling"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSpralSolverInterface.hpp",
            "meta": {
              "brief": "Interface to SPRAL SSIDS sparse symmetric solver\n\nSpralSolverInterface wraps SPRAL (Sparse Parallel Robust Algorithms\nLibrary), an open-source alternative to HSL solvers developed by\nSTFC RAL. SSIDS is SPRAL's symmetric indefinite direct solver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa86SolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA86 parallel sparse symmetric solver\n\nMa86SolverInterface wraps the HSL MA86 solver, a DAG-based\nparallel direct solver for symmetric indefinite systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa28TDependencyDetector.hpp",
            "meta": {
              "brief": "Dependency detector using HSL MA28 unsymmetric solver\n\nMa28TDependencyDetector uses the unsymmetric sparse solver MA28\nto detect linearly dependent rows in the constraint Jacobian.\nUnlike the symmetric solvers, MA28 handles general rectangular\nmatrices, making it suitable for analyzing the constraint Jacobian\ndirectly.\n\nThe detection works by attempting LU factorization with threshold\npivoting. When a pivot falls below tolerance (ma28_pivtol_), the\ncorresponding row is flagged as linearly dependent.\n\nInput format: Triplet (row, col, val) for general matrices\n\nUsed by Ipopt's constraint degeneracy detection mechanism."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTSymDependencyDetector.hpp",
            "meta": {
              "brief": "Dependency detection using symmetric linear solver\n\nTSymDependencyDetector detects linearly dependent constraint rows\nby using a TSymLinearSolver that provides degeneracy detection.\n\nMethod:\nSome symmetric linear solvers (e.g., MA57 via ProvidesDegeneracyDetection)\ncan identify dependent rows during factorization. This class\nleverages that capability.\n\nAlgorithm:\n1. Form symmetric matrix J*J^T (or equivalent structure)\n2. Attempt factorization with the TSymLinearSolver\n3. If solver detects singularity, query dependent row indices\n4. Return list of dependent rows in c_deps\n\nRequirements:\n- The underlying linear solver must implement\n  ProvidesDegeneracyDetection() returning true\n- Must implement DetermineDependentRows() for the sparse format\n\nThis is preferred over MA28-based detection when using a solver\nthat already provides this capability."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
            "meta": {
              "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
            "meta": {
              "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa57TSolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA57 sparse symmetric indefinite solver\n\nMa57TSolverInterface wraps the Harwell MA57 subroutine, an improved\nmultifrontal solver over MA27 with better memory management and\nnumerical stability."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpIterativeWsmpSolverInterface.hpp",
            "meta": {
              "brief": "Interface to IBM WSMP iterative (WISMP) solver\n\nIterativeWsmpSolverInterface wraps the iterative variant of WSMP\n(called WISMP), which uses incomplete LU factorization as a\npreconditioner for iterative refinement."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoSolverInterface.hpp",
            "meta": {
              "brief": "Interface to PARDISO sparse solver from pardiso-project.org\n\nPardisoSolverInterface wraps the PARDISO solver distributed by\npardiso-project.org (not to be confused with Intel MKL's PARDISO).\nPARDISO is a high-performance parallel direct solver for sparse\nsymmetric indefinite systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa27TSolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA27 sparse symmetric indefinite solver\n\nMa27TSolverInterface wraps the Harwell MA27 subroutine for solving\nsparse symmetric indefinite linear systems using multifrontal\nfactorization with threshold pivoting."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa97SolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA97 modern parallel sparse symmetric solver\n\nMa97SolverInterface wraps the HSL MA97 solver, the most modern\nHSL solver for symmetric indefinite systems with advanced\nparallelism and scaling strategies."
            }
          },
          {
            "id": "Bcp/Applications/MaxCut/include/MC_lp_param.hpp",
            "meta": {
              "brief": "Max-cut LP parameters"
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/CSP_lp_param.hpp",
            "meta": {
              "brief": "CSP LP parameters"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart_basis.hpp",
            "meta": {
              "brief": "BCP warm start basis implementation"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
            "meta": {
              "brief": "LP warm start information for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Dip/Dip/src/DecompCut.h",
            "meta": {
              "brief": "Cut representation in original x-space\n\nDecompCut represents a cutting plane (valid inequality) that can be\nadded to strengthen the formulation. Cuts are defined in original\nx-space and expanded to the master problem."
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/devexpricing.hpp",
            "meta": {
              "brief": "HiGHS Devex pricing for QP active set method\n\nDevex pricing strategy: approximate steepest edge using\nreference framework with periodic weight updates."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
            "meta": {
              "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkPrimal.h",
            "meta": {
              "brief": "Phase 2 primal simplex solver for HiGHS"
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkDual.h",
            "meta": {
              "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
            }
          },
          {
            "id": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
            "meta": {
              "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/kkt_solver.h",
            "meta": {
              "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
            }
          }
        ]
      }
    },
    "dual_simplex": {
      "id": "dual_simplex",
      "name": "Dual Simplex Method",
      "category": "algorithm",
      "definition": "Simplex variant that maintains dual feasibility (optimality) while working toward primal feasibility.",
      "intuition": "Start with optimal-but-infeasible solution, pivot to restore feasibility. Great for re-optimization.",
      "relationships": {
        "requires": [
          {
            "id": "simplex_method"
          },
          {
            "id": "LP_duality"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp"
          },
          {
            "id": "Clp/src/AbcDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for ABC dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcMatrix.hpp",
            "meta": {
              "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpDualRowDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/AbcSimplexDual.hpp",
            "meta": {
              "brief": "AVX-optimized dual simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpDualRowPivot.hpp",
            "meta": {
              "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          }
        ]
      }
    },
    "primal_simplex": {
      "id": "primal_simplex",
      "name": "Primal Simplex Method",
      "category": "algorithm",
      "definition": "Classic simplex that maintains primal feasibility while improving toward optimality.",
      "intuition": "Start with feasible solution, pivot to improve objective.",
      "relationships": {
        "requires": [
          {
            "id": "simplex_method"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp"
          },
          {
            "id": "Clp/src/ClpNonLinearCost.hpp",
            "meta": {
              "brief": "Piecewise linear cost handling and bound infeasibility tracking\n\nManages piecewise linear objective functions and tracks bound violations\nduring primal simplex. When variables move outside their bounds, this class\ncomputes the appropriate infeasibility penalty costs."
            }
          },
          {
            "id": "Clp/src/AbcSimplexPrimal.hpp",
            "meta": {
              "brief": "AVX-optimized primal simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnPivot.hpp",
            "meta": {
              "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkPrimal.h",
            "meta": {
              "brief": "Phase 2 primal simplex solver for HiGHS"
            }
          }
        ]
      }
    },
    "interior_point_method": {
      "id": "interior_point_method",
      "name": "Interior Point Method",
      "category": "algorithm",
      "definition": "Solves optimization by traversing the interior of the feasible region, using barrier functions to stay away from boundaries.",
      "intuition": "Stay inside constraints using a \"force field\" (barrier). Follow the central path as barrier weakens.",
      "aliases": [
        "IPM",
        "barrier method"
      ],
      "key_equations": [
        "min f(x) - \u03bc \u03a3 log(s_i)",
        "Central path: \u03bc \u2192 0",
        "Newton step for KKT system"
      ],
      "relationships": {
        "requires": [
          {
            "id": "newton_method"
          },
          {
            "id": "barrier_function"
          },
          {
            "id": "KKT_conditions"
          }
        ],
        "solves": [
          {
            "id": "linear_programming"
          },
          {
            "id": "nonlinear_programming"
          }
        ],
        "alternative_to": [
          {
            "id": "simplex_method"
          },
          {
            "id": "simplex_method"
          }
        ],
        "implemented_in": [
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp"
          },
          {
            "id": "CoinUtils/src/CoinWarmStart.hpp",
            "meta": {
              "brief": "Abstract interfaces for warm start information in optimization solvers"
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Waterdance.hpp",
            "meta": {
              "brief": "Alternating FM/QP refinement passes for partition improvement\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nWaterdance alternates between FM (discrete swaps) and QP (continuous\noptimization) refinement passes. The interplay (\"dance\") between methods\nescapes local minima that either method alone would get stuck in.\nNumber of dances controlled by num_dances option."
            }
          },
          {
            "id": "Clp/src/ClpDummyMatrix.hpp",
            "meta": {
              "brief": "Placeholder matrix with dimensions but no data\n\nImplements ClpMatrixBase with only dimensions (rows, columns, elements)\nbut no actual matrix data. Used primarily with ClpPdco where the user\nprovides custom matrix-vector products via callbacks."
            }
          },
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpPdcoBase.hpp",
            "meta": {
              "brief": "Abstract base class for PDCO problem customization\n\nStrategy pattern interface for defining custom convex objectives in PDCO."
            }
          },
          {
            "id": "Clp/src/ClpSolver.hpp",
            "meta": {
              "brief": "Standalone Clp solver driver and command-line interface"
            }
          },
          {
            "id": "Clp/src/ClpModel.hpp",
            "meta": {
              "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyBase.hpp",
            "meta": {
              "brief": "Cholesky factorization base class for interior point methods\n\nProvides Cholesky factorization of the normal equations matrix A*D*A'\nused in predictor-corrector interior point methods. The factorization\nuses AMD ordering to reduce fill-in.\n\nThe base class provides a simple sparse Cholesky implementation with\nsupernodal dense blocks. Derived classes can interface to more\nsophisticated factorizations (MUMPS, Pardiso, TAUCS, etc.).\n\nKey methods:\n- order(): Compute fill-reducing ordering (AMD by default)\n- symbolic(): Set up sparsity structure of factor\n- factorize(): Numeric factorization of A*D*A'\n- solve(): Solve system using computed factors"
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
            "meta": {
              "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMonotoneMuUpdate.hpp",
            "meta": {
              "brief": "Standard monotone barrier parameter update strategy\n\nMonotoneMuUpdate implements the classical IPM approach where the\nbarrier parameter mu is reduced monotonically as the subproblem\nconverges.\n\nUpdate rule:\n1. Solve barrier subproblem to tolerance barrier_tol_factor_ * mu\n2. Reduce mu: new_mu = max(mu_target_, min(kappa_mu * mu, mu^theta_mu))\n   where kappa_mu = mu_linear_decrease_factor_\n   and theta_mu = mu_superlinear_decrease_power_\n3. Update tau (fraction-to-boundary): tau = max(tau_min_, 1 - mu)\n\nKey parameters:\n- mu_init_: Initial barrier parameter\n- mu_linear_decrease_factor_: Linear decrease factor kappa_mu\n- mu_superlinear_decrease_power_: Superlinear power theta_mu\n- tau_min_: Minimum fraction-to-boundary parameter\n- mu_target_: Target mu for termination\n\nFast decrease heuristic:\n- mu_allow_fast_monotone_decrease_: Allow faster decrease when\n  complementarity is already small\n\nInteractions:\n- Calls linesearch_->Reset() when mu changes\n- Filter is cleared on barrier parameter update"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpOrigIterationOutput.hpp",
            "meta": {
              "brief": "Standard iteration output for original NLP problem\n\nOrigIterationOutput displays the per-iteration summary line\nfor the original (non-restoration) NLP problem."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoRestoPhase.hpp",
            "meta": {
              "brief": "Recursive restoration for separable n,p variable initialization\n\nRestoRestorationPhase provides a specialized \"restoration within\nrestoration\" procedure for the MinC_1NrmRestorationPhase. It computes\noptimal values for the slack variables (n_c, p_c, n_d, p_d) by\ntreating them as separable from x and s."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMuOracle.hpp",
            "meta": {
              "brief": "Strategy interface for suggesting barrier parameter values\n\nMuOracle is the abstract interface for components that compute\nsuggested values for the barrier parameter mu in adaptive (non-monotone)\nbarrier updates."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoIpoptNLP.hpp",
            "meta": {
              "brief": "IpoptNLP adapter for restoration phase feasibility problem\n\nRestoIpoptNLP transforms the original NLP into a feasibility problem\nfor the restoration phase. It introduces slack variables to allow\nconstraint violations and penalizes them in the objective."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpConvCheck.hpp",
            "meta": {
              "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpWarmStartIterateInitializer.hpp",
            "meta": {
              "brief": "Warm start initialization from previous solution\n\nWarmStartIterateInitializer initializes IPM iterates from a\npreviously computed solution, enabling faster convergence for\nrelated problems (e.g., MPC, parametric optimization).\n\nWarm start sources:\n- warm_start_entire_iterate_: Use GetWarmStartIterate() from NLP\n- Otherwise: Use initialization vectors from NLP\n\nProcessing steps:\n1. Push primals away from bounds (warm_start_bound_push/frac_)\n2. Push slacks (warm_start_slack_bound_push/frac_)\n3. Clip multipliers (warm_start_mult_init_max_)\n4. Ensure bound multipliers positive (warm_start_mult_bound_push_)\n\nTarget mu adjustment (warm_start_target_mu_):\n- Adjusts slack/multiplier pairs toward target complementarity\n- process_target_mu(): Scales to achieve s*z \u2248 target_mu\n- adapt_to_target_mu(): Fine-tunes pairing\n\nKey parameters:\n- warm_start_bound_push_: Absolute bound push\n- warm_start_bound_frac_: Relative bound push\n- warm_start_mult_init_max_: Maximum multiplier magnitude\n- warm_start_target_mu_: Target barrier parameter"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLoqoMuOracle.hpp",
            "meta": {
              "brief": "LOQO formula for barrier parameter selection\n\nLoqoMuOracle computes the barrier parameter using the heuristic\nfrom the LOQO solver (Vanderbei). This provides a simple formula\nbased on current complementarity.\n\nThe LOQO formula typically uses:\n  sigma = min(0.1, 100*mu)\n  mu_new = sigma * (current_complementarity / n)\n\nThis is a simple, stateless oracle that doesn't require solving\nan additional linear system (unlike probing or quality function).\n\nCompared to other strategies:\n- ProbingMuOracle: Requires affine step computation\n- QualityFunctionMuOracle: Requires 1D optimization\n- LoqoMuOracle: Direct formula, no extra computation"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
            "meta": {
              "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
            "meta": {
              "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoMinC_1Nrm.hpp",
            "meta": {
              "brief": "Restoration phase minimizing 1-norm of constraint violation\n\nMinC_1NrmRestorationPhase is the main restoration phase implementation.\nWhen the line search cannot make progress, it minimizes constraint\nviolation to find a feasible point from which optimization can continue.\n\nRestoration NLP formulation:\n  min  \u03c1 * ||[p_c; n_c; p_d; n_d]||_1 + (\u03b7/2) * ||D_r(x - x_ref)||_2^2\n  s.t. c(x) - p_c + n_c = 0\n       d_L <= d(x) - p_d + n_d <= d_U\n       x_L <= x <= x_U\n       p_c, n_c, p_d, n_d >= 0\n\nWhere:\n- \u03c1: Penalty on infeasibility (resto_penalty_parameter)\n- \u03b7: Proximity weight (resto_proximity_weight * sqrt(mu))\n- D_r: Diagonal scaling based on reference point\n- x_ref: Starting point for restoration\n\nKey behaviors:\n- Uses nested IpoptAlgorithm to solve restoration NLP\n- eq_mult_calculator_ reinitializes multipliers after restoration\n- bound_mult_reset_threshold_: Limits post-restoration bound multipliers\n- count_restorations_: Tracks restoration phase calls"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpBacktrackingLineSearch.hpp",
            "meta": {
              "brief": "General backtracking line search with filter/restoration support\n\nBacktrackingLineSearch is the main LineSearch implementation,\nproviding a flexible framework for globalization strategies:\n\nCore algorithm:\n1. Start with full step alpha = alpha_max (fraction-to-boundary)\n2. Test acceptability via BacktrackingLSAcceptor\n3. If rejected, reduce alpha *= alpha_red_factor and retry\n4. If alpha becomes too small, trigger restoration phase\n\nAdvanced features:\n- Watchdog mechanism: Accept poor steps temporarily to escape local minima\n- Second-order correction (SOC): Improve constraint satisfaction\n- Soft restoration phase: Accept steps that reduce primal-dual error\n- Magic steps: Improve slack/bound multiplier pairing\n- Corrector steps: Improve local convergence rate\n\nKey parameters:\n- alpha_for_y: How to step in equality multipliers\n- watchdog_trial_iter_max: Watchdog iteration limit\n- max_soc: Maximum second-order corrections"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoPhase.hpp",
            "meta": {
              "brief": "Strategy interface for restoration phase fallback\n\nRestorationPhase is the abstract base for the fallback mechanism\nwhen the line search cannot make progress. The restoration phase\nminimizes constraint violation to find a feasible point.\n\nTriggered when:\n- Line search step size becomes too small\n- No search direction can be computed (singular KKT system)\n- Algorithm explicitly requests fallback (ActivateFallbackMechanism)\n\nExceptions thrown on restoration failure:\n- RESTORATION_CONVERGED_TO_FEASIBLE_POINT: Success, found feasible point\n- RESTORATION_FAILED: Could not reduce infeasibility\n- RESTORATION_MAXITER_EXCEEDED: Hit iteration limit\n- RESTORATION_USER_STOP: User callback requested stop\n\nMain implementation: RestoIterationOutput minimizes ||c(x)||^2 + ||d(x)-s||^2\nusing the interior point method on a modified feasibility problem."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpFilterLSAcceptor.hpp",
            "meta": {
              "brief": "Filter line search acceptor using W\u00e4chter-Biegler method\n\nFilterLSAcceptor implements the filter globalization strategy where\nstep acceptance is based on improvement in either constraint violation\n(theta) or barrier objective (phi).\n\nAcceptance criteria:\n- Armijo sufficient decrease in barrier function, OR\n- Sufficient reduction in constraint violation (switching condition)\n- Point must be acceptable to current filter\n\nKey parameters:\n- theta_max_fact_: Upper bound factor on infeasibility\n- gamma_phi_, gamma_theta_: Margin parameters for filter\n- eta_phi_: Armijo parameter\n- s_phi_, s_theta_: Exponents in switching condition\n\nSecond-order correction (SOC):\n- When step is rejected, solves for constraint linearization error\n- Up to max_soc_ corrections tried\n- kappa_soc_ controls required constraint reduction between SOCs\n\nCorrector steps:\n- Affine or primal-dual corrector for fast local convergence\n- Applied even when step is acceptable\n\nFilter management:\n- Dominated entries removed on filter augmentation\n- Filter reset heuristic when repeatedly rejected by filter"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoConvCheck.hpp",
            "meta": {
              "brief": "Base class for restoration phase convergence checking\n\nRestoConvergenceCheck extends OptimalityErrorConvergenceCheck for\nthe restoration phase, adding termination criteria based on\nacceptability to the original problem's globalization mechanism."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpDefaultIterateInitializer.hpp",
            "meta": {
              "brief": "Standard initialization procedure for IPM iterates\n\nDefaultIterateInitializer computes starting points for all primal\nand dual variables based on user options and problem bounds.\n\nPrimal initialization (x, s):\n- Start from user-provided x0 or NLP default\n- Push away from bounds: x_new = max(x_L + \u03b5, min(x, x_U - \u03b5))\n- bound_push_, bound_frac_: Absolute/relative push parameters\n- least_square_init_primal_: Fit linearized constraints\n\nDual initialization:\n- Equality multipliers (y_c, y_d): Least-squares or zero\n- eq_mult_calculator_: Computes min ||y|| s.t. KKT gradient\n- constr_mult_init_max_: Reject large multiplier estimates\n- Bound multipliers (z_L, z_U, v_L, v_U):\n  - B_CONSTANT: bound_mult_init_val_\n  - B_MU_BASED: mu_init_ / slack\n\nWarm start:\n- warm_start_init_point_: Use warm_start_initializer_ instead\n- Delegates to WarmStartIterateInitializer\n\nStatic utilities:\n- push_variables(): Move point away from bounds\n- least_square_mults(): Compute y from gradient conditions"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMuUpdate.hpp",
            "meta": {
              "brief": "Strategy interface for updating barrier parameter mu\n\nMuUpdate is the abstract base for strategies that determine the\nbarrier parameter mu and fraction-to-boundary parameter tau for\neach iteration of the interior point method."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAdaptiveMuUpdate.hpp",
            "meta": {
              "brief": "Adaptive (non-monotone) barrier parameter update strategy\n\nAdaptiveMuUpdate implements the free-mode/fixed-mode approach for\nbarrier parameter updates. In free mode, mu is computed adaptively\neach iteration. In fixed mode, monotone decrease is enforced.\n\nTwo operating modes:\n- Free mode: MuOracle suggests mu (e.g., Mehrotra predictor-corrector\n  or quality function minimization). Allows temporary mu increases.\n- Fixed mode: Monotone decrease enforced. Triggered when free mode\n  fails to make sufficient progress.\n\nGlobalization strategies (adaptive_mu_globalization_):\n- KKT_ERROR: Track reduction in primal-dual KKT error\n- FILTER_OBJ_CONSTR: Use filter on (theta, phi)\n- NEVER_MONOTONE_MODE: Always stay in free mode\n\nFree mode oracles (via MuOracle):\n- QualityFunctionMuOracle: Minimize quality function\n- ProbingMuOracle: Try candidate mu values\n- LoqoMuOracle: LOQO-style adaptive rule\n\nFixed mode behavior:\n- Uses fix_mu_oracle_ or average complementarity\n- restore_accepted_iterate_: Can restore last good free-mode point\n\nReference value tracking:\n- refs_vals_: List of recent KKT error values\n- refs_red_fact_: Required reduction factor\n- num_refs_max_: Maximum stored references"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
            "meta": {
              "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
            "meta": {
              "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
            "meta": {
              "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
            "meta": {
              "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIterationOutput.hpp",
            "meta": {
              "brief": "Strategy interface for per-iteration output display\n\nIterationOutput is the abstract base for strategies that produce\nthe iteration summary line and optional detailed output.\n\nStandard output line (from OrigIterationOutput):\n  iter  objective   inf_pr   inf_du   lg(mu)  ||d||  lg(rg) alpha_du alpha_pr ls\n\nInfPrOutput enum controls whether inf_pr shows internal (with slacks)\nor original NLP constraint violation.\n\nImplementations:\n- OrigIterationOutput: Standard one-line summary for original problem\n- RestoIterationOutput: Output during restoration phase\n\nOutput controlled by print_level option (0-12)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptData.hpp",
            "meta": {
              "brief": "Central storage for all iteration data in Ipopt\n\nIpoptData holds the algorithmic state across iterations:\n- curr_: Current iterate (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\n- trial_: Trial point from line search\n- delta_: Search direction from KKT solve\n- delta_aff_: Affine-scaling step (for Mehrotra predictor-corrector)\n- W_: Hessian or Hessian approximation"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgStrategy.hpp",
            "meta": {
              "brief": "Base class for all pluggable algorithm components\n\nAlgorithmStrategyObject is the abstract base for Ipopt's Strategy pattern\nimplementation. All pluggable algorithm components inherit from this:\n- LineSearch, MuUpdate, ConvergenceCheck\n- SearchDirectionCalculator, HessianUpdater\n- PDSystemSolver, AugSystemSolver"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
            "meta": {
              "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpVector.hpp",
            "meta": {
              "brief": "Abstract base class for all vector types in Ipopt\n\nVector is the foundation of Ipopt's linear algebra abstraction.\nProvides BLAS-1 style operations (Copy, Scal, Axpy, Dot, Nrm2, etc.)\nplus IPM-specific operations (AddOneVector, FracToBound, etc.)."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
            "meta": {
              "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
            "meta": {
              "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundVector.hpp",
            "meta": {
              "brief": "Composite vector stacking multiple sub-vectors\n\nCompoundVector implements the Composite pattern for vectors,\nrepresenting: x_compound = [x_0; x_1; ...; x_{n-1}]"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
            "meta": {
              "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
            }
          },
          {
            "id": "Ipopt/src/contrib/CGPenalty/IpPiecewisePenalty.hpp",
            "meta": {
              "brief": "Piecewise linear penalty function (PLPF) data structure"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSlackBasedTSymScalingMethod.hpp",
            "meta": {
              "brief": "Simple scaling based on current slack values\n\nSlackBasedTSymScalingMethod computes scaling factors using only\nthe current slack values, without requiring external HSL routines.\nDesigned for use with inexact/iterative linear solvers.\n\nUnlike MC19 which performs full equilibration, this method uses\na simpler heuristic based on:\n- Current slack variable values s\n- Diagonal elements of the KKT system\n\nBenefits:\n- No external library dependencies\n- Lightweight computation\n- Suitable when full equilibration is unnecessary\n\nLimitations:\n- May not achieve as good conditioning as MC19\n- Best for problems where slacks dominate scaling needs"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
            "meta": {
              "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart_primaldual.hpp",
            "meta": {
              "brief": "Primal-dual warm start for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
            "meta": {
              "brief": "LP warm start information for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
            "meta": {
              "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
            "meta": {
              "brief": "Iterative rounding heuristic for nonconvex MINLP"
            }
          },
          {
            "id": "Gravity/include/gravity/IpoptProgram.h",
            "meta": {
              "brief": "Ipopt solver interface implementing TNLP callbacks\n\nAdapts Gravity models to Ipopt's TNLP (Templated NLP) interface.\n\n**IpoptProgram<type> Class:**\n- Inherits from Ipopt::TNLP and Program<type>\n- _model: Pointer to Gravity Model\n\n**Required TNLP Callbacks:**\n- get_nlp_info(): Return problem dimensions (n, m, nnz_jac, nnz_hess)\n- get_bounds_info(): Variable and constraint bounds\n- get_starting_point(): Initial x, z_L, z_U, lambda\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint values\n- eval_jac_g(): Jacobian values and structure\n- eval_h(): Hessian of Lagrangian\n- finalize_solution(): Copy solution back to model\n\n**Sparsity Pattern:**\n- First call to eval_jac_g/eval_h: return structure (iRow, jCol)\n- Subsequent calls: return values only\n- Gravity tracks via _first_call_jac, _first_call_hess\n\n**Solution Recovery:**\n- finalize_solution() copies x values to model variables\n- Retrieves dual values (lambda) for constraints\n- Retrieves bound multipliers (z_L, z_U)"
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
            "meta": {
              "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/iterate.h",
            "meta": {
              "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/crossover.h",
            "meta": {
              "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/ipm.h",
            "meta": {
              "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/kkt_solver.h",
            "meta": {
              "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
            "meta": {
              "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
            }
          },
          {
            "id": "SHOT/src/Solver.h",
            "meta": {
              "brief": "Main solver interface for convex MINLP problems\n\nPrimary entry point for the SHOT optimizer."
            }
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyNLP.h",
            "meta": {
              "brief": "Direct NLP solver for continuous problems\n\nBypasses ESH for purely continuous NLP problems.\n\n**SolutionStrategyNLP Class:**\n- initializeStrategy(): Configure for direct NLP solve\n- solveProblem(): Single NLP solver call (Ipopt)\n\n**Use Case:**\n- Problems with no integer variables\n- Convex NLP where outer approximation is unnecessary\n- Falls back to standard NLP solvers (Ipopt)\n\n**When Selected:**\n- Problem type is NLP (no discrete variables)\n- Simpler than ESH for continuous problems"
            }
          }
        ]
      }
    },
    "newton_method": {
      "id": "newton_method",
      "name": "Newton's Method",
      "category": "algorithm",
      "definition": "Second-order optimization using Hessian to compute descent direction. \u0394x = -H^{-1} \u2207f(x)",
      "intuition": "Approximate function as quadratic, jump to minimum of quadratic. Fast convergence near optimum.",
      "aliases": [
        "Newton-Raphson"
      ],
      "key_equations": [
        "\u0394x = -H^{-1} \u2207f",
        "Quadratic convergence"
      ],
      "relationships": {
        "requires": [
          {
            "id": "hessian"
          },
          {
            "id": "linear_system_solve"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpHelperFunctions.hpp",
            "meta": {
              "brief": "BLAS-1 style dense vector operations for Clp"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLineSearch.hpp",
            "meta": {
              "brief": "Strategy interface for globalization via line search\n\nLineSearch is the abstract base for all line search strategies\nin Ipopt's globalization framework. Given a search direction\n(from IpData.delta()), finds an acceptable trial point."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLimMemQuasiNewtonUpdater.hpp",
            "meta": {
              "brief": "Limited-memory quasi-Newton Hessian approximation (L-BFGS/SR1)\n\nLimMemQuasiNewtonUpdater maintains a low-rank approximation of the\nLagrangian Hessian using limited-memory BFGS or SR1 updates.\n\nCompact representation: W = \u03c3I + V*M^(-1)*V^T where\n- \u03c3: Scalar initialization factor (B0_ if diagonal)\n- V, U: Low-rank update matrices derived from S, Y history\n- S_: Matrix of step vectors s_k = x_{k+1} - x_k\n- Y_: Matrix of gradient differences y_k = \u2207L_{k+1} - \u2207L_k\n\nUpdate types (limited_memory_update_type_):\n- BFGS: Positive definite secant update, may skip if s'y <= 0\n- SR1: Symmetric rank-1, can capture negative curvature\n\nInitialization (limited_memory_initialization_):\n- SCALAR1-4: Various heuristics for \u03c3 based on y'y/s'y\n- CONSTANT: Fixed \u03c3 = limited_memory_init_val_\n\nKey parameters:\n- limited_memory_max_history_: Maximum stored (s,y) pairs\n- limited_memory_max_skipping_: Reset after N consecutive skips\n- sigma_safe_min/max_: Safeguards for initialization factor\n\nRestoration phase (update_for_resto_):\n- Structured update accounting for \u03b7*D_r*x quadratic term\n- Ypart_ stores constraint-only gradient differences"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpProbingMuOracle.hpp",
            "meta": {
              "brief": "Mehrotra's probing heuristic for barrier parameter selection\n\nProbingMuOracle implements Mehrotra's predictor-corrector approach\nto compute the barrier parameter mu. This is the strategy used in\nmany interior point codes like LOQO and PCx.\n\nAlgorithm:\n1. Compute affine scaling direction (predictor step) with sigma=0\n2. Find maximum step to boundary (alpha_aff)\n3. Compute complementarity after affine step: mu_aff\n4. Compute centering parameter: sigma = (mu_aff/mu)^3\n5. Use sigma in corrector step\n\nThe centering parameter sigma controls the balance between:\n- sigma=0: Pure affine scaling (aggressive, may overshoot)\n- sigma=1: Pure centering (conservative, slow progress)\n\nKey parameter:\n- sigma_max_: Upper bound on sigma to prevent excessive centering"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
            "meta": {
              "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpGradientScaling.hpp",
            "meta": {
              "brief": "NLP scaling based on gradient magnitudes at initial point\n\nGradientScaling computes scaling factors for the NLP based on the\nmaximum gradient norms at the user-provided starting point. This\nimproves problem conditioning by normalizing objective and constraint\nmagnitudes."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpHessianUpdater.hpp",
            "meta": {
              "brief": "Strategy interface for Hessian computation/approximation\n\nHessianUpdater is the abstract base for strategies that provide\nthe Hessian of the Lagrangian (or an approximation) to the algorithm.\nThe result is stored in IpData.W()."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpNLPBoundsRemover.hpp",
            "meta": {
              "brief": "NLP adapter that converts variable bounds to inequality constraints\n\nNLPBoundsRemover is an NLP adapter primarily used for inexact/iterative\nlinear solvers that require the KKT system to have a specific structure\nwithout bound constraints."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
            "meta": {
              "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
            "meta": {
              "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpMultiVectorMatrix.hpp",
            "meta": {
              "brief": "Tall-skinny matrix stored as collection of column Vectors\n\nMultiVectorMatrix represents an m x k matrix (k << m) where each\ncolumn is stored as a separate Vector. Efficient for:\n- Limited-memory quasi-Newton: store recent gradient differences\n- Low-rank updates: V*V^T matvec via two sequential operations"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpLowRankUpdateSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix as low-rank update: M = D + V*V^T - U*U^T\n\nLowRankUpdateSymMatrix represents matrices in factored form:\n  M = P_LR * (D + V*V^T - U*U^T) * P_LR^T  (if reduced_diag)\n  M = D + P_LR * (V*V^T - U*U^T) * P_LR^T  (otherwise)"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpDenseSymMatrix.hpp",
            "meta": {
              "brief": "Dense symmetric matrix in BLAS lower-triangular storage\n\nDenseSymMatrix stores only the lower triangle in column-major format,\nfollowing BLAS/LAPACK conventions for symmetric matrices."
            }
          },
          {
            "id": "Ipopt/src/contrib/CGPenalty/IpCGPerturbationHandler.hpp",
            "meta": {
              "brief": "Perturbation handler for Chen-Goldfarb penalty method"
            }
          },
          {
            "id": "Ipopt/src/contrib/CGPenalty/IpCGSearchDirCalc.hpp",
            "meta": {
              "brief": "Search direction calculator for Chen-Goldfarb penalty method"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactNewtonNormal.hpp",
            "meta": {
              "brief": "Newton normal step from slack-scaled augmented system\n\nInexactNewtonNormalStep computes the normal step component by\nsolving a reduced system derived from the slack-scaled KKT system."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactAlgBuilder.hpp",
            "meta": {
              "brief": "Builder for inexact step computation algorithm variant\n\nInexactAlgorithmBuilder constructs the complete IpoptAlgorithm\nconfigured for inexact Newton methods using iterative linear solvers."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactCq.hpp",
            "meta": {
              "brief": "Cached quantities for inexact Newton / Chen-Goldfarb penalty method\n\nInexactCq provides precomputed and cached quantities specific to the\ninexact Newton algorithm, extending IpoptCalculatedQuantities."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactDoglegNormal.hpp",
            "meta": {
              "brief": "Dogleg trust region method for normal step computation\n\nInexactDoglegNormalStep computes the normal step using a dogleg\napproach that combines steepest descent and Newton directions\nwithin a trust region."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactNormalStepCalc.hpp",
            "meta": {
              "brief": "Abstract base class for normal step computation\n\nInexactNormalStepCalculator defines the interface for computing\nthe normal step component in the inexact Newton decomposition."
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprPow.hpp",
            "meta": {
              "brief": "Power expression w = x^k with convexification"
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/ipm.h",
            "meta": {
              "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/kkt_solver.h",
            "meta": {
              "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
            }
          }
        ]
      }
    },
    "branch_and_bound": {
      "id": "branch_and_bound",
      "name": "Branch and Bound",
      "category": "algorithm",
      "definition": "Systematic enumeration of candidate solutions via tree search, using bounds to prune suboptimal branches.",
      "intuition": "Divide problem into subproblems, solve relaxations to get bounds, prune branches that can't improve.",
      "aliases": [
        "B&B"
      ],
      "key_equations": [
        "Lower bound from relaxation",
        "Upper bound from feasible solutions",
        "Prune if LB \u2265 UB"
      ],
      "relationships": {
        "requires": [
          {
            "id": "LP_relaxation"
          },
          {
            "id": "branching"
          },
          {
            "id": "node_selection"
          }
        ],
        "solves": [
          {
            "id": "mixed_integer_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Cbc/src/CbcModel.hpp"
          },
          {
            "id": "CoinUtils/src/CoinWarmStart.hpp",
            "meta": {
              "brief": "Abstract interfaces for warm start information in optimization solvers"
            }
          },
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          },
          {
            "id": "Clp/src/ClpNode.hpp",
            "meta": {
              "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
            }
          },
          {
            "id": "Clp/src/AbcWarmStart.hpp",
            "meta": {
              "brief": "Extended warm start with factorization caching for ABC"
            }
          },
          {
            "id": "Clp/src/ClpModel.hpp",
            "meta": {
              "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
            }
          },
          {
            "id": "Osi/src/Osi/OsiAuxInfo.hpp",
            "meta": {
              "brief": "Auxiliary information for algorithm-specific solver customization"
            }
          },
          {
            "id": "Osi/src/Osi/OsiChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection strategies for branch-and-bound\n\nIn MIP solving, choosing which variable to branch on significantly\naffects tree size and solve time. This file provides:\n\n- OsiChooseVariable: Base class for branching variable selection\n- OsiChooseStrong: Strong branching (evaluates candidates by solving LPs)"
            }
          },
          {
            "id": "Osi/src/Osi/OsiCut.hpp",
            "meta": {
              "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
            }
          },
          {
            "id": "Cbc/src/CbcGeneralDepth.hpp",
            "meta": {
              "brief": "Depth-limited partial evaluation branching"
            }
          },
          {
            "id": "Cbc/src/CbcObject.hpp",
            "meta": {
              "brief": "Abstract base for branching entities (variables, SOS, etc.)"
            }
          },
          {
            "id": "Cbc/src/CbcNodeInfo.hpp",
            "meta": {
              "brief": "Persistent information for recreating search tree nodes"
            }
          },
          {
            "id": "Cbc/src/CbcBranchingObject.hpp",
            "meta": {
              "brief": "Abstract base for branching actions"
            }
          },
          {
            "id": "Cbc/src/CbcNode.hpp",
            "meta": {
              "brief": "Search tree node for branch-and-cut\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcBranchToFixLots.hpp",
            "meta": {
              "brief": "Branch to fix many variables simultaneously\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchToFixLots: Heuristic branching that fixes multiple variables\nin one branch, cutting off the current solution in the other. Useful\nfor reducing problem size when reduced costs indicate fixable variables."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicRENS.hpp",
            "meta": {
              "brief": "RENS - Relaxation Enforced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRENS: Fixes variables based on LP relaxation solution.\nUnlike RINS (which needs an incumbent), RENS works from LP alone."
            }
          },
          {
            "id": "Cbc/src/CbcTree.hpp",
            "meta": {
              "brief": "Heap-based storage for live search tree nodes\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcCompareBase.hpp",
            "meta": {
              "brief": "Abstract base class for node comparison/selection"
            }
          },
          {
            "id": "Bcp/Applications/MaxCut/include/MC_tm.hpp",
            "meta": {
              "brief": "Max-cut tree manager for BCP"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_tm.hpp",
            "meta": {
              "brief": "MKC tree manager for BCP"
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/KS.hpp",
            "meta": {
              "brief": "Knapsack solver for CSP column generation"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_cut.hpp",
            "meta": {
              "brief": "Cut (constraint) representation for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm.hpp",
            "meta": {
              "brief": "Tree Manager process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm_functions.hpp",
            "meta": {
              "brief": "Tree Manager internal function declarations"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_process.hpp",
            "meta": {
              "brief": "BCP process base class and scheduler"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_obj_change.hpp",
            "meta": {
              "brief": "Delta encoding for variable/cut bound changes"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp.hpp",
            "meta": {
              "brief": "LP process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm_user.hpp",
            "meta": {
              "brief": "User customization interface for Tree Manager process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_var.hpp",
            "meta": {
              "brief": "Variable representation for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tmstorage.hpp",
            "meta": {
              "brief": "BCP tree storage process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm_node.hpp",
            "meta": {
              "brief": "Search tree node representation in Tree Manager"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
            "meta": {
              "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
            "meta": {
              "brief": "Abstract interface for NLP solvers used in branch-and-bound"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
            "meta": {
              "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
            "meta": {
              "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
            "meta": {
              "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
            "meta": {
              "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
            "meta": {
              "brief": "Orbital branching object using symmetry"
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
            "meta": {
              "brief": "NLP heuristic for near-integer B&B nodes"
            }
          },
          {
            "id": "Dip/Dip/src/DecompApp.h",
            "meta": {
              "brief": "User application interface - derive to define your decomposition\n\nDecompApp is the main user-facing class. Derive from it to define:\n- Model decomposition (core vs relaxed constraints)\n- Subproblem solvers\n- Problem-specific heuristics"
            }
          },
          {
            "id": "Dip/Dip/src/Decomp.h",
            "meta": {
              "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
            }
          },
          {
            "id": "SYMPHONY/include/sym_master.h",
            "meta": {
              "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
            }
          },
          {
            "id": "SYMPHONY/include/sym_lp.h",
            "meta": {
              "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
            }
          },
          {
            "id": "SYMPHONY/include/symphony.h",
            "meta": {
              "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
            }
          },
          {
            "id": "SYMPHONY/include/sym_tm.h",
            "meta": {
              "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsMipSolver.h",
            "meta": {
              "brief": "Branch-and-cut MIP solver"
            }
          },
          {
            "id": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
            "meta": {
              "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
            "meta": {
              "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "spatial_branch_and_bound": {
      "id": "spatial_branch_and_bound",
      "name": "Spatial Branch and Bound",
      "category": "algorithm",
      "definition": "Extends branch-and-bound to continuous variables for nonconvex problems. Branches on continuous variables to tighten convex relaxations.",
      "intuition": "Standard B&B branches on integers; spatial B&B also subdivides continuous domains to make relaxations tighter.",
      "aliases": [
        "sBB"
      ],
      "relationships": {
        "requires": [
          {
            "id": "branch_and_bound"
          },
          {
            "id": "convexification"
          },
          {
            "id": "bound_tightening"
          }
        ],
        "solves": [
          {
            "id": "nonconvex_optimization"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/src/branch/CouenneObject.hpp"
          },
          {
            "id": "Couenne/src/branch/CouenneChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection for branching in global optimization"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
            "meta": {
              "brief": "Three-way spatial branching for continuous variables"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneVarObject.hpp",
            "meta": {
              "brief": "Variable-based branching object for MINLP"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
            "meta": {
              "brief": "Orbital branching object using symmetry"
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
            "meta": {
              "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
            }
          }
        ]
      }
    },
    "outer_approximation": {
      "id": "outer_approximation",
      "name": "Outer Approximation",
      "category": "algorithm",
      "definition": "Alternates between MILP master problem and NLP subproblems. Adds linearization cuts from NLP solutions to tighten MILP.",
      "intuition": "Approximate nonlinear constraints with tangent planes. Iterate: solve MILP, get point, add tangent cuts.",
      "aliases": [
        "OA"
      ],
      "key_equations": [
        "g(x*) + \u2207g(x*)^T (x - x*) \u2264 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexity"
          },
          {
            "id": "linear_programming"
          }
        ],
        "solves": [
          {
            "id": "mixed_integer_nonlinear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp"
          },
          {
            "id": "Clp/src/ClpConstraintLinear.hpp",
            "meta": {
              "brief": "Linear constraint implementation for nonlinear extensions\n\nImplements ClpConstraint for a linear constraint: sum(a_j * x_j) = b.\nUsed with ClpSimplexNonlinear when linear constraints appear alongside\nnonlinear objective or other nonlinear constraints."
            }
          },
          {
            "id": "Clp/src/ClpConstraint.hpp",
            "meta": {
              "brief": "Abstract base class for nonlinear constraints\n\nDefines the interface for general (potentially nonlinear) constraints\nused in nonlinear programming extensions. The standard LP constraints\n(Ax \u2264 b) are handled directly by ClpModel; this class is for more\ngeneral constraint forms g(x) \u2264 0."
            }
          },
          {
            "id": "Clp/src/ClpConstraintQuadratic.hpp",
            "meta": {
              "brief": "Quadratic constraint implementation: x'Qx + c'x \u2264 b\n\nImplements ClpConstraint for quadratic constraints. The constraint\nfunction is: 0.5 * sum_{ij}(Q_ij * x_i * x_j) + sum_j(c_j * x_j) \u2264 b"
            }
          },
          {
            "id": "Cbc/src/CbcLinked.hpp",
            "meta": {
              "brief": "Extended solver for nonlinear and bilinear problems"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpBacktrackingLineSearch.hpp",
            "meta": {
              "brief": "General backtracking line search with filter/restoration support\n\nBacktrackingLineSearch is the main LineSearch implementation,\nproviding a flexible framework for globalization strategies:\n\nCore algorithm:\n1. Start with full step alpha = alpha_max (fraction-to-boundary)\n2. Test acceptability via BacktrackingLSAcceptor\n3. If rejected, reduce alpha *= alpha_red_factor and retry\n4. If alpha becomes too small, trigger restoration phase\n\nAdvanced features:\n- Watchdog mechanism: Accept poor steps temporarily to escape local minima\n- Second-order correction (SOC): Improve constraint satisfaction\n- Soft restoration phase: Accept steps that reduce primal-dual error\n- Magic steps: Improve slack/bound multiplier pairing\n- Corrector steps: Improve local convergence rate\n\nKey parameters:\n- alpha_for_y: How to step in equality multipliers\n- watchdog_trial_iter_max: Watchdog iteration limit\n- max_soc: Maximum second-order corrections"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactPDSolver.hpp",
            "meta": {
              "brief": "Primal-dual system solver for inexact Newton methods\n\nInexactPDSolver solves the primal-dual system using iterative linear\nsolvers, allowing for inexact solutions that don't fully satisfy\nthe linearized KKT conditions."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonCutStrengthener.hpp",
            "meta": {
              "brief": "Strengthening OA cuts via NLP optimization\n\nImproves outer approximation cuts by solving auxiliary NLPs to find\ntighter bounds on linearizations. Also supports disjunctive cuts."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonSubMipSolver.hpp",
            "meta": {
              "brief": "Unified interface for solving MILP subproblems in OA decomposition\n\nProvides a common interface for solving MILP subproblems using either\nCbc (via OsiClpSolverInterface) or CPLEX (via OsiCpxSolverInterface).\nUsed by OA decomposition algorithms to solve the linearized master problem."
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
            "meta": {
              "brief": "Base class for heuristics using local NLP/MINLP solves"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonFixAndSolveHeuristic.hpp",
            "meta": {
              "brief": "Fix-and-Solve heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
            "meta": {
              "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
            "meta": {
              "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
            "meta": {
              "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
            "meta": {
              "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
            "meta": {
              "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaDecBase.hpp",
            "meta": {
              "brief": "Base class for Outer Approximation (OA) decomposition algorithms\n\nImplements the foundation for OA-based MINLP algorithms. OA iterates between\nsolving MILP subproblems and NLP subproblems, generating linear outer\napproximations of the nonlinear constraints.\n\n**OA algorithm outline:**\n1. Solve MILP relaxation \u2192 get integer solution x*\n2. Fix integers to x*, solve NLP \u2192 get nonlinear solution y*\n3. Generate linearization cuts at y* (gradient-based)\n4. Add cuts to MILP, repeat until convergence\n\n**Key components:**\n- solverManip: RAII helper to save/restore solver state\n- performOa(): Virtual method implementing specific OA variant\n- post_nlp_solve(): Handle NLP solution and update bounds\n\n**Parameters:**\n- global_: Add cuts globally (valid at all nodes)\n- addOnlyViolated_: Only add cuts violated by current solution\n- maxLocalSearch_: Limit on local search iterations"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
            "meta": {
              "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
            "meta": {
              "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
            }
          },
          {
            "id": "Bonmin/experimental/Separable/BonOuterDescription.hpp",
            "meta": {
              "brief": "Bonmin outer approximation description for convex MINLP\n\nOuter approximation (OA) cut management for MINLP.\nLinearization-based approach for convex MINLP."
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
            "meta": {
              "brief": "Quadratic expression with alpha-convexification"
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/kkt_solver.h",
            "meta": {
              "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
            }
          },
          {
            "id": "SHOT/src/PrimalSolver.h",
            "meta": {
              "brief": "NLP-based primal bound computation and solution repair\n\nFinds feasible solutions and improves the primal bound."
            }
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
            }
          },
          {
            "id": "SHOT/src/SolutionStrategy/SolutionStrategyMultiTree.h",
            "meta": {
              "brief": "Iterative outer approximation strategy (multi-tree)\n\nClassic outer approximation loop for convex MINLP.\n\n**Algorithm Pattern:**\n1. Solve MIP relaxation to get candidate point\n2. Generate supporting hyperplanes at violated points\n3. Add cuts to MIP and resolve\n4. Repeat until convergence or termination\n\n**Task Flow (initializeStrategy):**\n- CreateDualProblem \u2192 SolveIteration \u2192 SelectHyperplanes\n- AddHyperplanes \u2192 CheckTermination \u2192 loop\n\n**Advantages:**\n- No callback complexity\n- Can use any MIP solver\n- Easier debugging/logging\n\n**Disadvantages:**\n- Multiple MIP solves\n- May regenerate same B&B tree work"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/MIPSolverCbc.h",
            "meta": {
              "brief": "COIN-OR Cbc implementation of IMIPSolver interface\n\nProvides open-source MIP solving using Cbc branch-and-cut solver.\n\n**MIPSolverCbc Class:**\n- Implements IMIPSolver interface\n- Uses OsiClpSolverInterface for LP subproblems\n- CbcModel for branch-and-cut\n- CoinModel for problem construction\n\n**Key Data Structures:**\n- osiInterface: OSI LP solver (Clp)\n- cbcModel: MIP solver model\n- coinModel: Problem builder\n- objectiveLinearExpression: CoinPackedVector\n\n**CbcMessageHandler:**\n- Custom message handler for SHOT logging\n- Routes Cbc output through SHOT's Output system\n\n**Limitations:**\n- supportsQuadraticObjective(): No\n- supportsQuadraticConstraints(): No\n- LP/MIP only (no MIQP/QCQP)\n\n@note Default open-source MIP solver, no license required"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "cutting_planes": {
      "id": "cutting_planes",
      "name": "Cutting Planes",
      "category": "algorithm",
      "definition": "Strengthen LP relaxation by adding valid inequalities that cut off fractional solutions without removing integer-feasible points.",
      "intuition": "LP relaxation too loose? Add constraints that trim the polytope closer to the integer hull.",
      "aliases": [
        "cuts"
      ],
      "relationships": {
        "requires": [
          {
            "id": "LP_relaxation"
          }
        ],
        "contains": [
          {
            "id": "Gomory_cuts"
          },
          {
            "id": "MIR_cuts"
          }
        ],
        "implemented_in": [
          {
            "id": "Cgl/"
          },
          {
            "id": "CoinUtils/src/CoinConflictGraph.hpp",
            "meta": {
              "brief": "Conflict graph for binary variable incompatibilities in MIP"
            }
          },
          {
            "id": "CoinUtils/src/CoinCliqueExtender.hpp",
            "meta": {
              "brief": "Clique extender"
            }
          },
          {
            "id": "Osi/src/Osi/OsiRowCut.hpp",
            "meta": {
              "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
            }
          },
          {
            "id": "Osi/src/Osi/OsiCuts.hpp",
            "meta": {
              "brief": "Container for collections of row cuts and column cuts"
            }
          },
          {
            "id": "Osi/src/Osi/OsiCut.hpp",
            "meta": {
              "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
            }
          },
          {
            "id": "Cbc/src/CbcNodeInfo.hpp",
            "meta": {
              "brief": "Persistent information for recreating search tree nodes"
            }
          },
          {
            "id": "Cbc/src/CbcFullNodeInfo.hpp",
            "meta": {
              "brief": "Complete subproblem state storage (typically for root node)"
            }
          },
          {
            "id": "Cbc/src/CbcThread.hpp",
            "meta": {
              "brief": "Multi-threaded parallel B&C support"
            }
          },
          {
            "id": "Cbc/src/CbcStrategy.hpp",
            "meta": {
              "brief": "Strategy pattern for configuring CbcModel components"
            }
          },
          {
            "id": "Cgl/src/CglAllDifferent/CglAllDifferent.hpp",
            "meta": {
              "brief": "All-different constraint propagation for CSP-style constraints\n\nPropagates all-different constraints: variables in a set must all\ntake different integer values. Common in constraint satisfaction\nproblems (CSP) mapped to MIP."
            }
          },
          {
            "id": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
            "meta": {
              "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandP.hpp",
            "meta": {
              "brief": "Lift-and-Project cuts via simplex pivoting"
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
            "meta": {
              "brief": "Simplex algorithm for Lift-and-Project cut generation"
            }
          },
          {
            "id": "Cgl/src/CglCommon/CglCutGenerator.hpp",
            "meta": {
              "brief": "Abstract base class for all CGL cutting plane generators\n\nDefines the interface that all cut generators must implement. In MIP\nbranch-and-cut, cutting planes tighten the LP relaxation to cut off\nfractional solutions while keeping all integer-feasible points."
            }
          },
          {
            "id": "Cgl/src/CglZeroHalf/CglZeroHalf.hpp",
            "meta": {
              "brief": "Zero-half ({0,1/2}) cutting planes\n\nGenerates {0,1/2}-cuts by taking mod-2 combinations of constraint rows.\nBased on Andreello, Caprara, Fischetti (INFORMS J. Computing, 2007).\n\nTheory: If we combine constraints with {0, 1/2} multipliers such that\nall LHS coefficients become even, we get a valid cut by dividing by 2\nand rounding down the RHS.\n\nAlgorithm outline:\n1. Convert constraint matrix to integers (scaling)\n2. Reduce coefficients mod 2 (0-1 matrix)\n3. Find combinations where LHS sums to 0 mod 2 per column\n4. These yield valid {0,1/2}-cuts when RHS is odd\n\nInternal representation:\n- mr_, mc_, mnz_: Matrix dimensions and nonzeros\n- mtbeg_, mtcnt_, mtind_, mtval_: Sparse row storage\n- vlb_, vub_: Variable bounds (integer scaled)\n- Cgl012Cut cutInfo_: Separation algorithm state\n\nUses Dijkstra shortest path (cglShortestPath) for separation."
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
            "meta": {
              "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_knapsack.hpp",
            "meta": {
              "brief": "MKC knapsack subproblem for column generation"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_lp.hpp",
            "meta": {
              "brief": "MKC LP relaxation for BCP"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_tm.hpp",
            "meta": {
              "brief": "MKC tree manager for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_enum_process_t.hpp",
            "meta": {
              "brief": "Process type enumeration for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_cut.hpp",
            "meta": {
              "brief": "Cut (constraint) representation for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_cg.hpp",
            "meta": {
              "brief": "Cut Generator process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_cg_param.hpp",
            "meta": {
              "brief": "Cut Generator parameters for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_cg_user.hpp",
            "meta": {
              "brief": "User customization interface for Cut Generator process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp.hpp",
            "meta": {
              "brief": "LP process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_main_fun.hpp",
            "meta": {
              "brief": "Process entry point functions for BCP"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
            "meta": {
              "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
            }
          },
          {
            "id": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
            "meta": {
              "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoC.h",
            "meta": {
              "brief": "Cutting Plane Method algorithm (no column generation)\n\nDecompAlgoC implements classic cutting plane method:\n- Solve LP relaxation\n- Find violated cuts\n- Add cuts and resolve\n- Repeat until integer or no cuts found"
            }
          },
          {
            "id": "SYMPHONY/include/sym_lp.h",
            "meta": {
              "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
            }
          },
          {
            "id": "SYMPHONY/include/symphony.h",
            "meta": {
              "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
            }
          },
          {
            "id": "Gravity/include/gravity/constraint.h",
            "meta": {
              "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsMipSolver.h",
            "meta": {
              "brief": "Branch-and-cut MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsCutGeneration.h",
            "meta": {
              "brief": "Class that generates cuts from single row relaxations"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparation.h",
            "meta": {
              "brief": "Cut generation orchestration for MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparator.h",
            "meta": {
              "brief": "Abstract base class for cut separators"
            }
          },
          {
            "id": "SHOT/src/Solver.h",
            "meta": {
              "brief": "Main solver interface for convex MINLP problems\n\nPrimary entry point for the SHOT optimizer."
            }
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
            }
          },
          {
            "id": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
            "meta": {
              "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
            }
          },
          {
            "id": "SHOT/src/Tasks/TaskSelectHyperplanePointsECP.h",
            "meta": {
              "brief": "Extended Cutting Plane point selection\n\nClassic outer approximation: linearize at infeasible points.\n\n**TaskSelectHyperplanePointsECP Class:**\n- run(): Process current MIP solutions\n- run(solPoints): Process specific solution points\n\n**ECP Algorithm:**\n- Generate gradient cut at infeasible solution\n- Simpler than ESH but may converge slower\n- Used as fallback when ESH rootsearch fails"
            }
          }
        ]
      }
    },
    "Gomory_cuts": {
      "id": "Gomory_cuts",
      "name": "Gomory Cuts",
      "category": "algorithm",
      "definition": "Cuts derived from the simplex tableau that are violated by the current fractional solution but valid for all integer solutions.",
      "intuition": "Read off a valid inequality directly from the optimal tableau row of a fractional basic variable.",
      "aliases": [
        "Gomory mixed-integer cuts",
        "GMI"
      ],
      "key_equations": [
        "\u03a3 (f_j / f_0) x_j \u2265 1  (simplified)"
      ],
      "relationships": {
        "requires": [
          {
            "id": "cutting_planes"
          },
          {
            "id": "basis"
          }
        ],
        "implemented_in": [
          {
            "id": "Cgl/src/CglGomory/CglGomory.hpp"
          },
          {
            "id": "Osi/src/Osi/OsiRowCut.hpp",
            "meta": {
              "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
            }
          },
          {
            "id": "Osi/src/Osi/OsiCut.hpp",
            "meta": {
              "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
            }
          },
          {
            "id": "Cbc/src/CbcModel.hpp",
            "meta": {
              "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
            }
          },
          {
            "id": "Cbc/src/CbcBranchCut.hpp",
            "meta": {
              "brief": "Branching by adding cuts (split disjunctions)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchCut and CbcCutBranchingObject: Branch by adding cuts\nrather than tightening variable bounds. Implements split disjunctions\nwhere each branch arm adds a different cut to the LP."
            }
          },
          {
            "id": "Cgl/src/CglRedSplit/CglRedSplit.hpp",
            "meta": {
              "brief": "Reduce-and-Split cuts for enhanced Gomory generation"
            }
          },
          {
            "id": "Cgl/src/CglOddHole/CglOddHole.hpp",
            "meta": {
              "brief": "Odd hole cuts from conflict graphs\n\nGenerates odd hole inequalities based on the method from\nGrotschel, Lovasz, and Schrijver (1988). An odd hole is a\nchordless cycle of odd length in the conflict graph."
            }
          },
          {
            "id": "Cgl/src/CglCommon/CglCutGenerator.hpp",
            "meta": {
              "brief": "Abstract base class for all CGL cutting plane generators\n\nDefines the interface that all cut generators must implement. In MIP\nbranch-and-cut, cutting planes tighten the LP relaxation to cut off\nfractional solutions while keeping all integer-feasible points."
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
            "meta": {
              "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
            }
          },
          {
            "id": "Cgl/src/CglZeroHalf/CglZeroHalf.hpp",
            "meta": {
              "brief": "Zero-half ({0,1/2}) cutting planes\n\nGenerates {0,1/2}-cuts by taking mod-2 combinations of constraint rows.\nBased on Andreello, Caprara, Fischetti (INFORMS J. Computing, 2007).\n\nTheory: If we combine constraints with {0, 1/2} multipliers such that\nall LHS coefficients become even, we get a valid cut by dividing by 2\nand rounding down the RHS.\n\nAlgorithm outline:\n1. Convert constraint matrix to integers (scaling)\n2. Reduce coefficients mod 2 (0-1 matrix)\n3. Find combinations where LHS sums to 0 mod 2 per column\n4. These yield valid {0,1/2}-cuts when RHS is odd\n\nInternal representation:\n- mr_, mc_, mnz_: Matrix dimensions and nonzeros\n- mtbeg_, mtcnt_, mtind_, mtval_: Sparse row storage\n- vlb_, vub_: Variable bounds (integer scaled)\n- Cgl012Cut cutInfo_: Separation algorithm state\n\nUses Dijkstra shortest path (cglShortestPath) for separation."
            }
          },
          {
            "id": "SYMPHONY/include/symphony.h",
            "meta": {
              "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsMipSolver.h",
            "meta": {
              "brief": "Branch-and-cut MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparation.h",
            "meta": {
              "brief": "Cut generation orchestration for MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparator.h",
            "meta": {
              "brief": "Abstract base class for cut separators"
            }
          }
        ]
      }
    },
    "MIR_cuts": {
      "id": "MIR_cuts",
      "name": "Mixed-Integer Rounding Cuts",
      "category": "algorithm",
      "definition": "Cuts derived by rounding continuous coefficients in mixed-integer constraints.",
      "intuition": "If x + y \u2264 2.7 and y is integer, then we can derive x + y \u2264 2.",
      "aliases": [
        "MIR"
      ],
      "relationships": {
        "requires": [
          {
            "id": "cutting_planes"
          }
        ],
        "implemented_in": [
          {
            "id": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp"
          },
          {
            "id": "Cgl/src/CglTwomir/CglTwomir.hpp",
            "meta": {
              "brief": "Two-step MIR (TMIR) cut generator\n\nGenerates tMIR and 2-step MIR cuts by applying the MIR inequality\nrecursively with different scaling factors. More general than\nsimple Gomory or MIR cuts."
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
            "meta": {
              "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
            "meta": {
              "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/QuadCuts/BonLinearCutsGenerator.hpp",
            "meta": {
              "brief": "Composite cut generator managing multiple linear cut generators\nCopyright (C) International Business Machines Corporation 2007.\nAll Rights Reserved.\nThis code is published under the Eclipse Public License."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsModkSeparator.h",
            "meta": {
              "brief": "Class for separating maximally violated mod-k MIR cuts"
            }
          }
        ]
      }
    },
    "active_set_method": {
      "id": "active_set_method",
      "name": "Active Set Method",
      "category": "algorithm",
      "definition": "Solves QP by maintaining a working set of active constraints, iteratively adding/dropping constraints.",
      "intuition": "Guess which constraints are tight at the optimum, solve the resulting equality-constrained problem.",
      "relationships": {
        "solves": [
          {
            "id": "quadratic_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "qpOASES/"
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPGradProj.hpp",
            "meta": {
              "brief": "Projected gradient descent for QP partition optimization\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPGradProj implements gradient projection for bound-constrained QP:\nminimizes quadratic cut objective subject to box constraints [0,1]\nand balance constraint (lo <= a'x <= hi). Projects gradient onto\nfeasible region, iterates until convergence or iteration limit."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPDelta.hpp",
            "meta": {
              "brief": "QP solver state: solution, gradient, free set, and workspace\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPDelta stores iterative QP solver state: current solution x, gradient,\nfree set (variables not at bounds), balance constraint bounds (lo/hi),\nLagrange multiplier lambda, and workspace arrays. FreeSet_status tracks\nwhether each x_i is at 0, 1, or strictly between (free)."
            }
          },
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
            "meta": {
              "brief": "Sparse QP solver using Schur complement for active-set updates"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Bounds.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Constraints.hpp",
            "meta": {
              "brief": "Working set management for general constraints in active-set QP"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblem.hpp",
            "meta": {
              "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Indexlist.hpp",
            "meta": {
              "brief": "Sorted index lists for efficient working set operations"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblem.hpp",
            "meta": {
              "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Flipper.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Matrices.hpp",
            "meta": {
              "brief": "Matrix classes for QP data with working-set-aware operations"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SubjectTo.hpp",
            "meta": {
              "brief": "Base class for working set management in active-set QP"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
            "meta": {
              "brief": "Online QP Benchmark Collection interface"
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/devexpricing.hpp",
            "meta": {
              "brief": "HiGHS Devex pricing for QP active set method\n\nDevex pricing strategy: approximate steepest edge using\nreference framework with periodic weight updates."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/factor.hpp",
            "meta": {
              "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
            "meta": {
              "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/basis.hpp",
            "meta": {
              "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
            }
          }
        ]
      }
    },
    "feasibility_pump": {
      "id": "feasibility_pump",
      "name": "Feasibility Pump",
      "category": "algorithm",
      "definition": "Heuristic for finding feasible MIP solutions by alternating between rounding and projection.",
      "intuition": "Round fractional solution to integers, then find closest LP-feasible point. Repeat until integer-feasible.",
      "aliases": [
        "FP"
      ],
      "relationships": {
        "solves": [
          {
            "id": "mixed_integer_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp"
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPLinks.hpp",
            "meta": {
              "brief": "QP free set rounding and partition conversion\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPLinks converts continuous QP solution to discrete partition by\nrounding fractional variables and updating free set. Handles the\ninterface between continuous relaxation and discrete partition\nrepresentation in the waterdance refinement cycle."
            }
          },
          {
            "id": "Osi/src/Osi/OsiRowCut.hpp",
            "meta": {
              "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristic.hpp",
            "meta": {
              "brief": "Base class for MIP primal heuristics\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcCompareDefault.hpp",
            "meta": {
              "brief": "Default adaptive node comparison strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDINS.hpp",
            "meta": {
              "brief": "DINS - Distance-Induced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDINS: Uses multiple solutions to define neighborhoods.\nMaintains a pool of solutions and fixes variables based on\nagreement across the solution pool (Ghosh 2007)."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveCoefficient.hpp",
            "meta": {
              "brief": "Dive heuristic based on objective coefficients\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveCoefficient: Selects variables based on objective impact.\nPrioritizes fractional variables with large objective coefficients."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveGuided.hpp",
            "meta": {
              "brief": "Dive heuristic guided by incumbent solution\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveGuided: Uses existing incumbent to guide diving.\nRequires a feasible solution (canHeuristicRun checks this)."
            }
          },
          {
            "id": "Cbc/src/CbcSubProblem.hpp",
            "meta": {
              "brief": "Compact subproblem state for diving heuristics"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicRandRound.hpp",
            "meta": {
              "brief": "Randomized rounding heuristic\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRandRound: Probabilistic rounding of LP solution.\nRounds fractional variables randomly with probabilities based on\ntheir fractional values (e.g., x=0.7 rounds up with prob 0.7)."
            }
          },
          {
            "id": "Cbc/src/CbcTreeLocal.hpp",
            "meta": {
              "brief": "Local branching search tree (Fischetti-Lodi 2002)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDivePseudoCost.hpp",
            "meta": {
              "brief": "Dive heuristic using pseudocost estimates\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDivePseudoCost: Most informed diving strategy.\nUses pseudocosts to estimate objective change from fixing."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicFPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic (Fischetti, Glover & Lodi)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicRINS.hpp",
            "meta": {
              "brief": "RINS - Relaxation Induced Neighborhood Search (Danna et al.)\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRINS: Implements RINS (Danna, Rothberg & Le Pape, 2005).\nUses LP relaxation to define a neighborhood around the incumbent solution."
            }
          },
          {
            "id": "Cbc/src/CbcCompareEstimate.hpp",
            "meta": {
              "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDive.hpp",
            "meta": {
              "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveLineSearch.hpp",
            "meta": {
              "brief": "Dive heuristic along line to LP optimum\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveLineSearch: Geometric diving approach.\nSelects variables along the line from current point to LP optimum."
            }
          },
          {
            "id": "Cgl/src/CglTwomir/CglTwomir.hpp",
            "meta": {
              "brief": "Two-step MIR (TMIR) cut generator\n\nGenerates tMIR and 2-step MIR cuts by applying the MIR inequality\nrecursively with different scaling factors. More general than\nsimple Gomory or MIR cuts."
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
            "meta": {
              "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
            }
          },
          {
            "id": "Cgl/src/CglZeroHalf/Cgl012cut.hpp",
            "meta": {
              "brief": "Low-level C-style implementation for {0,1/2}-cut separation\nCopyright (C) 2010, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
            "meta": {
              "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
            }
          },
          {
            "id": "Cgl/src/CglSimpleRounding/CglSimpleRounding.hpp",
            "meta": {
              "brief": "Simple rounding cuts via GCD (greatest common divisor)\n\nGenerates simple rounding cuts using the GCD method from\nNemhauser and Wolsey (1988, p.211)."
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm.hpp",
            "meta": {
              "brief": "Tree Manager process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_enum_branch.hpp",
            "meta": {
              "brief": "Branching-related enumerations for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_message_tag.hpp",
            "meta": {
              "brief": "Message tag enumeration for BCP inter-process communication"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_node.hpp",
            "meta": {
              "brief": "LP process node representation"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm_param.hpp",
            "meta": {
              "brief": "Tree Manager parameters for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/BonDiver.hpp",
            "meta": {
              "brief": "Diving-based tree traversal strategies for MINLP branch-and-bound\n\nImplements tree traversal strategies that \"dive\" down branches before\nbacktracking, often finding feasible solutions faster than pure best-bound."
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic for MINLP\n\nImplements the Feasibility Pump algorithm adapted for nonlinear problems.\nAlternates between:\n1. Rounding to nearest integer solution\n2. Projecting back to feasible continuous space via NLP\n\n**Classes:**\n- HeuristicFPump: Main feasibility pump heuristic (CbcHeuristic)\n- RoundingFPump: Helper for intelligent rounding considering constraints"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
            "meta": {
              "brief": "Base class for heuristics using local NLP/MINLP solves"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonFixAndSolveHeuristic.hpp",
            "meta": {
              "brief": "Fix-and-Solve heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicLocalBranching.hpp",
            "meta": {
              "brief": "Local Branching heuristic for MINLP improvement"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicDive.hpp",
            "meta": {
              "brief": "Base class for diving heuristics in MINLP"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
            "meta": {
              "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonMilpRounding.hpp",
            "meta": {
              "brief": "MILP-based rounding heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
            "meta": {
              "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneFeasPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
            "meta": {
              "brief": "Iterative rounding heuristic for nonconvex MINLP"
            }
          },
          {
            "id": "SYMPHONY/include/sym_primal_heuristics.h",
            "meta": {
              "brief": "Primal heuristics for finding feasible solutions\n\nCollection of heuristics to find feasible MIP solutions quickly.\nCalled during B&C to improve incumbent and provide bounds."
            }
          },
          {
            "id": "SYMPHONY/include/sym_tm.h",
            "meta": {
              "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsPrimalHeuristics.h",
            "meta": {
              "brief": "Primal heuristics for finding MIP feasible solutions\n\nCollection of primal heuristics to discover incumbent solutions."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSearch.h",
            "meta": {
              "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsMipSolver.h",
            "meta": {
              "brief": "Branch-and-cut MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsCutGeneration.h",
            "meta": {
              "brief": "Class that generates cuts from single row relaxations"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparation.h",
            "meta": {
              "brief": "Cut generation orchestration for MIP solver"
            }
          },
          {
            "id": "SHOT/src/PrimalSolver.h",
            "meta": {
              "brief": "NLP-based primal bound computation and solution repair\n\nFinds feasible solutions and improves the primal bound."
            }
          }
        ]
      }
    },
    "KKT_conditions": {
      "id": "KKT_conditions",
      "name": "Karush-Kuhn-Tucker Conditions",
      "category": "optimality",
      "definition": "Necessary conditions for optimality in constrained optimization: stationarity, primal feasibility, dual feasibility, complementary slackness.",
      "intuition": "At optimum, gradient of objective is a combination of constraint gradients. Active constraints have positive multipliers.",
      "aliases": [
        "KKT",
        "first-order conditions"
      ],
      "key_equations": [
        "\u2207f = \u03a3 \u03bb_i \u2207g_i  (stationarity)",
        "g(x) \u2264 0  (primal feasibility)",
        "\u03bb \u2265 0  (dual feasibility)",
        "\u03bb_i g_i(x) = 0  (complementarity)"
      ],
      "relationships": {
        "requires": [
          {
            "id": "Lagrangian"
          }
        ],
        "contains": [
          {
            "id": "complementary_slackness"
          }
        ],
        "implemented_in": [
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPDelta.hpp",
            "meta": {
              "brief": "QP solver state: solution, gradient, free set, and workspace\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPDelta stores iterative QP solver state: current solution x, gradient,\nfree set (variables not at bounds), balance constraint bounds (lo/hi),\nLagrange multiplier lambda, and workspace arrays. FreeSet_status tracks\nwhether each x_i is at 0, 1, or strictly between (free)."
            }
          },
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyWssmpKKT.hpp",
            "meta": {
              "brief": "WSSMP solver for KKT system (augmented system) formulation\n\nVariant of ClpCholeskyWssmp that solves the KKT/augmented system directly\ninstead of forming and factoring the normal equations A*D*A'."
            }
          },
          {
            "id": "Clp/src/ClpPdcoBase.hpp",
            "meta": {
              "brief": "Abstract base class for PDCO problem customization\n\nStrategy pattern interface for defining custom convex objectives in PDCO."
            }
          },
          {
            "id": "Clp/src/ClpPredictorCorrector.hpp",
            "meta": {
              "brief": "Mehrotra's predictor-corrector interior point algorithm"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SparseSolver.hpp",
            "meta": {
              "brief": "Sparse linear solver interfaces for Schur-complement QP method"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
            "meta": {
              "brief": "Sparse QP solver using Schur complement for active-set updates"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblem.hpp",
            "meta": {
              "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/SolutionAnalysis.hpp",
            "meta": {
              "brief": "Post-optimality analysis: KKT verification and sensitivity"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
            "meta": {
              "brief": "Online QP Benchmark Collection interface"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpGenAugSystemSolver.hpp",
            "meta": {
              "brief": "Augmented system solver using GenKKTSolverInterface\n\nGenAugSystemSolver adapts the AugSystemSolver interface to use\nGenKKTSolverInterface, which provides a more generic linear solver\ninterface supporting iterative methods.\n\nThis class:\n- Extracts raw Number* arrays from Vector objects\n- Passes Matrix objects directly from the NLP\n- Manages caching to avoid redundant matrix updates\n\nMultiSolve() implementation:\n1. Check if augmented system matrices have changed (via tags)\n2. If changed, update solver_interface_ with new matrices\n3. Extract RHS vectors to raw arrays\n4. Call solver_interface_->Solve()\n5. Copy solutions back to Vector objects\n\nTag-based caching tracks:\n- W matrix and W_factor\n- Diagonal matrices D_x, D_s, D_c, D_d\n- Jacobians J_c, J_d\n- Regularization deltas\n\nInertia and quality:\n- NumberOfNegEVals(): Query solver for eigenvalue count\n- ProvidesInertia(): Check if solver supports this\n- IncreaseQuality(): Request better pivoting/tolerance"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMonotoneMuUpdate.hpp",
            "meta": {
              "brief": "Standard monotone barrier parameter update strategy\n\nMonotoneMuUpdate implements the classical IPM approach where the\nbarrier parameter mu is reduced monotonically as the subproblem\nconverges.\n\nUpdate rule:\n1. Solve barrier subproblem to tolerance barrier_tol_factor_ * mu\n2. Reduce mu: new_mu = max(mu_target_, min(kappa_mu * mu, mu^theta_mu))\n   where kappa_mu = mu_linear_decrease_factor_\n   and theta_mu = mu_superlinear_decrease_power_\n3. Update tau (fraction-to-boundary): tau = max(tau_min_, 1 - mu)\n\nKey parameters:\n- mu_init_: Initial barrier parameter\n- mu_linear_decrease_factor_: Linear decrease factor kappa_mu\n- mu_superlinear_decrease_power_: Superlinear power theta_mu\n- tau_min_: Minimum fraction-to-boundary parameter\n- mu_target_: Target mu for termination\n\nFast decrease heuristic:\n- mu_allow_fast_monotone_decrease_: Allow faster decrease when\n  complementarity is already small\n\nInteractions:\n- Calls linesearch_->Reset() when mu changes\n- Filter is cleared on barrier parameter update"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpConvCheck.hpp",
            "meta": {
              "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpEqMultCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing equality constraint multipliers\n\nEqMultiplierCalculator is the abstract base for computing estimates\nof the equality constraint multipliers y_c and y_d. These estimates\nare used for:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLowRankSSAugSystemSolver.hpp",
            "meta": {
              "brief": "Low-rank Hessian handling via single backsolve (iterative solver friendly)\n\nLowRankSSAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS) by augmenting the system rather than using\nSherman-Morrison. This requires only ONE factorization/backsolve."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
            "meta": {
              "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpEquilibrationScaling.hpp",
            "meta": {
              "brief": "NLP scaling using MC19 matrix equilibration\n\nEquilibrationScaling computes scaling factors using the HSL MC19\nsymmetric indefinite matrix equilibration routine. This produces\nwell-conditioned scaling by analyzing the Jacobian structure."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoConvCheck.hpp",
            "meta": {
              "brief": "Base class for restoration phase convergence checking\n\nRestoConvergenceCheck extends OptimalityErrorConvergenceCheck for\nthe restoration phase, adding termination criteria based on\nacceptability to the original problem's globalization mechanism."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpNLPBoundsRemover.hpp",
            "meta": {
              "brief": "NLP adapter that converts variable bounds to inequality constraints\n\nNLPBoundsRemover is an NLP adapter primarily used for inexact/iterative\nlinear solvers that require the KKT system to have a specific structure\nwithout bound constraints."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAdaptiveMuUpdate.hpp",
            "meta": {
              "brief": "Adaptive (non-monotone) barrier parameter update strategy\n\nAdaptiveMuUpdate implements the free-mode/fixed-mode approach for\nbarrier parameter updates. In free mode, mu is computed adaptively\neach iteration. In fixed mode, monotone decrease is enforced.\n\nTwo operating modes:\n- Free mode: MuOracle suggests mu (e.g., Mehrotra predictor-corrector\n  or quality function minimization). Allows temporary mu increases.\n- Fixed mode: Monotone decrease enforced. Triggered when free mode\n  fails to make sufficient progress.\n\nGlobalization strategies (adaptive_mu_globalization_):\n- KKT_ERROR: Track reduction in primal-dual KKT error\n- FILTER_OBJ_CONSTR: Use filter on (theta, phi)\n- NEVER_MONOTONE_MODE: Always stay in free mode\n\nFree mode oracles (via MuOracle):\n- QualityFunctionMuOracle: Minimize quality function\n- ProbingMuOracle: Try candidate mu values\n- LoqoMuOracle: LOQO-style adaptive rule\n\nFixed mode behavior:\n- Uses fix_mu_oracle_ or average complementarity\n- restore_accepted_iterate_: Can restore last good free-mode point\n\nReference value tracking:\n- refs_vals_: List of recent KKT error values\n- refs_red_fact_: Required reduction factor\n- num_refs_max_: Maximum stored references"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
            "meta": {
              "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpStdAugSystemSolver.hpp",
            "meta": {
              "brief": "Standard augmented system solver forming explicit matrix\n\nStdAugSystemSolver is the main implementation of AugSystemSolver\nfor sparse triple-format matrices (SymTMatrix). It explicitly\nassembles the 4x4 augmented system as a CompoundSymMatrix:\n\n  [W + D_x + \u03b4_x I      0         J_c^T      J_d^T  ]\n  [     0          D_s + \u03b4_s I    0          -I    ]\n  [    J_c             0       D_c - \u03b4_c I    0     ]\n  [    J_d            -I          0       D_d - \u03b4_d I]\n\nImplementation details:\n- Uses CompoundSymMatrixSpace with SumSymMatrix for (1,1) block\n- DiagMatrix for D_x, D_s, D_c, D_d contributions\n- IdentityMatrix for scalar delta regularization\n- Tracks matrix tags to avoid unnecessary reassembly\n- Delegates factorization/solve to SymLinearSolver"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
            "meta": {
              "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
            "meta": {
              "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDFullSpaceSolver.hpp",
            "meta": {
              "brief": "Full-space primal-dual system solver with inertia correction\n\nPDFullSpaceSolver is the main implementation of PDSystemSolver.\nIt reduces the 8x8 primal-dual system to the 4x4 augmented system\nby eliminating bound multiplier equations:\n  d_z = S^{-1}(rhs_z - Z*P^T*d_x)\n\nKey features:\n- Iterative refinement with quality monitoring (residual_ratio)\n- Inertia correction via PDPerturbationHandler (adds delta_x, delta_c)\n- Automatic retries with increased pivot tolerance\n- Handles singular systems by adding regularization\n\nParameters:\n- min/max_refinement_steps: Iterative refinement bounds\n- residual_ratio_max: Acceptable solution quality threshold\n- neg_curv_test_tol: Tolerance for inertia heuristics"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
            "meta": {
              "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
            "meta": {
              "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
            "meta": {
              "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpExpandedMultiVectorMatrix.hpp",
            "meta": {
              "brief": "Short-fat matrix V^T*P^T with expansion for KKT construction\n\nExpandedMultiVectorMatrix represents a k x n matrix (k << n) as\nV^T * P^T where V is a MultiVectorMatrix-like collection of row\nvectors and P is an optional ExpansionMatrix."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundVector.hpp",
            "meta": {
              "brief": "Composite vector stacking multiple sub-vectors\n\nCompoundVector implements the Composite pattern for vectors,\nrepresenting: x_compound = [x_0; x_1; ...; x_{n-1}]"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
            "meta": {
              "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpSymMatrix.hpp",
            "meta": {
              "brief": "Abstract base class for symmetric matrices\n\nSymMatrix extends Matrix for symmetric matrices (A = A^T).\nTransMultVector automatically delegates to MultVector since\ntranspose is a no-op for symmetric matrices."
            }
          },
          {
            "id": "Ipopt/src/contrib/CGPenalty/IpCGPerturbationHandler.hpp",
            "meta": {
              "brief": "Perturbation handler for Chen-Goldfarb penalty method"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSlackBasedTSymScalingMethod.hpp",
            "meta": {
              "brief": "Simple scaling based on current slack values\n\nSlackBasedTSymScalingMethod computes scaling factors using only\nthe current slack values, without requiring external HSL routines.\nDesigned for use with inexact/iterative linear solvers.\n\nUnlike MC19 which performs full equilibration, this method uses\na simpler heuristic based on:\n- Current slack variable values s\n- Diagonal elements of the KKT system\n\nBenefits:\n- No external library dependencies\n- Lightweight computation\n- Suitable when full equilibration is unnecessary\n\nLimitations:\n- May not achieve as good conditioning as MC19\n- Best for problems where slacks dominate scaling needs"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
            "meta": {
              "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
            "meta": {
              "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
            "meta": {
              "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
            "meta": {
              "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneComplObject.hpp",
            "meta": {
              "brief": "Branching object for complementarity constraints"
            }
          },
          {
            "id": "Gravity/include/gravity/constraint.h",
            "meta": {
              "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/crossover.h",
            "meta": {
              "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/ipm.h",
            "meta": {
              "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/kkt_solver.h",
            "meta": {
              "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
            "meta": {
              "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
            }
          }
        ]
      }
    },
    "LP_duality": {
      "id": "LP_duality",
      "name": "LP Duality",
      "category": "optimality",
      "definition": "Every LP has a dual LP. At optimality, primal and dual objectives are equal. Primal: min c^T x, Dual: max b^T y",
      "intuition": "Dual variables are prices on constraints. Strong duality: optimal prices give same value as optimal solution.",
      "aliases": [
        "linear programming duality"
      ],
      "key_equations": [
        "Primal: min c^T x s.t. Ax \u2265 b",
        "Dual: max b^T y s.t. A^T y \u2264 c",
        "c^T x* = b^T y*"
      ],
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          },
          {
            "id": "Lagrangian"
          }
        ],
        "contains": [
          {
            "id": "complementary_slackness"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinPresolveDual.hpp",
            "meta": {
              "brief": "Fix variables using dual bounds and reduced cost analysis"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveTighten.hpp",
            "meta": {
              "brief": "Tighten variable bounds using constraint propagation"
            }
          },
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          },
          {
            "id": "CoinUtils/src/CoinCliqueExtender.hpp",
            "meta": {
              "brief": "Clique extender"
            }
          },
          {
            "id": "Clp/src/AbcDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for ABC dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpGubMatrix.hpp",
            "meta": {
              "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplex.hpp",
            "meta": {
              "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
            }
          },
          {
            "id": "Clp/src/ClpNode.hpp",
            "meta": {
              "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
            }
          },
          {
            "id": "Clp/src/AbcMatrix.hpp",
            "meta": {
              "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/AbcSimplexPrimal.hpp",
            "meta": {
              "brief": "AVX-optimized primal simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpPEPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Positive Edge enhanced Dantzig pricing for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplex.hpp",
            "meta": {
              "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
            }
          },
          {
            "id": "Clp/src/ClpPEPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Positive Edge enhanced steepest edge for primal simplex"
            }
          },
          {
            "id": "Clp/src/Idiot.hpp",
            "meta": {
              "brief": "Heuristic crash procedure for finding initial LP solutions\n\nThe \"Idiot\" algorithm is a simple heuristic that finds approximate primal\nsolutions quickly. Despite its self-deprecating name (which is copylefted!),\nit serves as an effective \"crash\" procedure to warm-start the simplex method."
            }
          },
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyDense.hpp",
            "meta": {
              "brief": "Dense Cholesky factorization for interior point methods\n\nImplements Cholesky factorization when A*D*A' becomes effectively dense.\nUses blocked recursive algorithms for cache efficiency and supports\nparallel execution via ClpCholeskySpawn."
            }
          },
          {
            "id": "Clp/src/ClpDualRowDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/ClpMatrixBase.hpp",
            "meta": {
              "brief": "Abstract base class for constraint matrices in Clp\n\nDefines the interface that all matrix types must implement for use with\nClp algorithms. The abstraction allows specialized matrix formats that\nexploit structure (network, GUB, \u00b11 matrices) while providing a uniform\ninterface to the simplex solver."
            }
          },
          {
            "id": "Clp/src/ClpPdcoBase.hpp",
            "meta": {
              "brief": "Abstract base class for PDCO problem customization\n\nStrategy pattern interface for defining custom convex objectives in PDCO."
            }
          },
          {
            "id": "Clp/src/ClpHelperFunctions.hpp",
            "meta": {
              "brief": "BLAS-1 style dense vector operations for Clp"
            }
          },
          {
            "id": "Clp/src/ClpPredictorCorrector.hpp",
            "meta": {
              "brief": "Mehrotra's predictor-corrector interior point algorithm"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplexDual.hpp",
            "meta": {
              "brief": "AVX-optimized dual simplex algorithm"
            }
          },
          {
            "id": "Clp/src/AbcPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for ABC primal simplex pivot selection"
            }
          },
          {
            "id": "Clp/src/ClpSimplexNonlinear.hpp",
            "meta": {
              "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
            }
          },
          {
            "id": "Clp/src/AbcDualRowDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for ABC dual simplex pivot selection"
            }
          },
          {
            "id": "Clp/src/ClpModel.hpp",
            "meta": {
              "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
            }
          },
          {
            "id": "Clp/src/ClpPrimalQuadraticDantzig.hpp",
            "meta": {
              "brief": "Dantzig-style pricing for quadratic programming\n\nExtends ClpPrimalColumnPivot for QP problems where the reduced cost\ndepends on the current solution (due to the quadratic objective)."
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnPivot.hpp",
            "meta": {
              "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
            }
          },
          {
            "id": "Clp/src/ClpDualRowPivot.hpp",
            "meta": {
              "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/ClpPEDualRowDantzig.hpp",
            "meta": {
              "brief": "Positive Edge enhanced Dantzig pricing for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpPEDualRowSteepest.hpp",
            "meta": {
              "brief": "Positive Edge enhanced steepest edge for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpPESimplex.hpp",
            "meta": {
              "brief": "Positive Edge anti-degeneracy framework for simplex"
            }
          },
          {
            "id": "Clp/src/ClpDynamicMatrix.hpp",
            "meta": {
              "brief": "Dynamic column generation matrix with GUB structure\n\nSupports column generation by maintaining a pool of potential columns\nand dynamically adding promising ones to the active working matrix.\nBuilt on GUB structure where each \"set\" can generate multiple columns."
            }
          },
          {
            "id": "Clp/src/Clp_C_Interface.h",
            "meta": {
              "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
            }
          },
          {
            "id": "CppAD/include/cppad/core/sparse_hes.hpp",
            "meta": {
              "brief": "Sparse Hessian computation using automatic differentiation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblem.hpp",
            "meta": {
              "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
            "meta": {
              "brief": "Online QP Benchmark Collection interface"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicGreedy.hpp",
            "meta": {
              "brief": "Greedy construction heuristics for set covering/partitioning\nCopyright (C) 2005, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nContains greedy heuristics suited for set covering/partitioning models:"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDivePseudoCost.hpp",
            "meta": {
              "brief": "Dive heuristic using pseudocost estimates\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDivePseudoCost: Most informed diving strategy.\nUses pseudocosts to estimate objective change from fixing."
            }
          },
          {
            "id": "Cbc/src/CbcBranchToFixLots.hpp",
            "meta": {
              "brief": "Branch to fix many variables simultaneously\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchToFixLots: Heuristic branching that fixes multiple variables\nin one branch, cutting off the current solution in the other. Useful\nfor reducing problem size when reduced costs indicate fixable variables."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDive.hpp",
            "meta": {
              "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicRENS.hpp",
            "meta": {
              "brief": "RENS - Relaxation Enforced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRENS: Fixes variables based on LP relaxation solution.\nUnlike RINS (which needs an incumbent), RENS works from LP alone."
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Cgl/src/CglResidualCapacity/CglResidualCapacity.hpp",
            "meta": {
              "brief": "Residual capacity cuts for network design"
            }
          },
          {
            "id": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
            "meta": {
              "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
            }
          },
          {
            "id": "Cgl/src/CglRedSplit2/CglRedSplit2.hpp",
            "meta": {
              "brief": "Enhanced Reduce-and-Split cuts with multiple strategies"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLeastSquareMults.hpp",
            "meta": {
              "brief": "Least-squares estimation of equality constraint multipliers\n\nLeastSquareMultipliers computes initial estimates for the equality\nconstraint multipliers y_c and y_d by solving a least-squares problem.\n\nFormulation: Find y minimizing ||\u2207_x L(x,y)||^2 where\n  \u2207_x L = \u2207f(x) + J_c^T y_c + J_d^T y_d - z_L + z_U\n\nThis is equivalent to solving the normal equations:\n  [J_c J_c^T    0    ] [y_c]   [-J_c (\u2207f - z_L + z_U)]\n  [   0     J_d J_d^T] [y_d] = [-J_d (\u2207f - z_L + z_U)]\n\nActually solved via augmented system:\n  [0  J_c^T  J_d^T] [r  ]   [\u2207f - z_L + z_U]\n  [J_c  0     0   ] [y_c] = [     0        ]\n  [J_d  0     0   ] [y_d]   [     0        ]\n\nUses AugSystemSolver to solve the linear system with W=0.\n\nUsage:\n- DefaultIterateInitializer: Initial multiplier estimates\n- MinC_1NrmRestorationPhase: Post-restoration multiplier reset"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpUserScaling.hpp",
            "meta": {
              "brief": "NLP scaling using user-provided scaling factors\n\nUserScaling obtains scaling factors directly from the NLP interface\nvia the get_scaling_parameters callback (TNLP) or GetScalingParameters\nmethod (NLP)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpOrigIterationOutput.hpp",
            "meta": {
              "brief": "Standard iteration output for original NLP problem\n\nOrigIterationOutput displays the per-iteration summary line\nfor the original (non-restoration) NLP problem."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoRestoPhase.hpp",
            "meta": {
              "brief": "Recursive restoration for separable n,p variable initialization\n\nRestoRestorationPhase provides a specialized \"restoration within\nrestoration\" procedure for the MinC_1NrmRestorationPhase. It computes\noptimal values for the slack variables (n_c, p_c, n_d, p_d) by\ntreating them as separable from x and s."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIterateInitializer.hpp",
            "meta": {
              "brief": "Strategy interface for computing initial iterates\n\nIterateInitializer is the abstract base for strategies that\ncompute the starting point (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\nfor the interior point algorithm."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpConvCheck.hpp",
            "meta": {
              "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpEqMultCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing equality constraint multipliers\n\nEqMultiplierCalculator is the abstract base for computing estimates\nof the equality constraint multipliers y_c and y_d. These estimates\nare used for:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
            "meta": {
              "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
            "meta": {
              "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpDefaultIterateInitializer.hpp",
            "meta": {
              "brief": "Standard initialization procedure for IPM iterates\n\nDefaultIterateInitializer computes starting points for all primal\nand dual variables based on user options and problem bounds.\n\nPrimal initialization (x, s):\n- Start from user-provided x0 or NLP default\n- Push away from bounds: x_new = max(x_L + \u03b5, min(x, x_U - \u03b5))\n- bound_push_, bound_frac_: Absolute/relative push parameters\n- least_square_init_primal_: Fit linearized constraints\n\nDual initialization:\n- Equality multipliers (y_c, y_d): Least-squares or zero\n- eq_mult_calculator_: Computes min ||y|| s.t. KKT gradient\n- constr_mult_init_max_: Reject large multiplier estimates\n- Bound multipliers (z_L, z_U, v_L, v_U):\n  - B_CONSTANT: bound_mult_init_val_\n  - B_MU_BASED: mu_init_ / slack\n\nWarm start:\n- warm_start_init_point_: Use warm_start_initializer_ instead\n- Delegates to WarmStartIterateInitializer\n\nStatic utilities:\n- push_variables(): Move point away from bounds\n- least_square_mults(): Compute y from gradient conditions"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoIterationOutput.hpp",
            "meta": {
              "brief": "Iteration output during restoration phase\n\nRestoIterationOutput provides per-iteration summary output while\nthe algorithm is in restoration phase. It displays metrics for the\nORIGINAL NLP (not the restoration feasibility problem).\n\nOutput format:\n- Iteration number marked with 'r' prefix to indicate restoration\n- Objective value from original NLP\n- Constraint violation (theta) for original constraints\n- Dual infeasibility for original problem\n\nDual output mode:\nIf resto_orig_iteration_output is provided, produces two lines:\n1. Restoration phase problem metrics\n2. Original NLP metrics (using original scaling)\n\nConfiguration:\n- print_info_string_: Whether to print info at end of line\n- inf_pr_output_: What to show in inf_pr column\n- print_frequency_iter_: Iteration print frequency\n- print_frequency_time_: Time-based print frequency"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAdaptiveMuUpdate.hpp",
            "meta": {
              "brief": "Adaptive (non-monotone) barrier parameter update strategy\n\nAdaptiveMuUpdate implements the free-mode/fixed-mode approach for\nbarrier parameter updates. In free mode, mu is computed adaptively\neach iteration. In fixed mode, monotone decrease is enforced.\n\nTwo operating modes:\n- Free mode: MuOracle suggests mu (e.g., Mehrotra predictor-corrector\n  or quality function minimization). Allows temporary mu increases.\n- Fixed mode: Monotone decrease enforced. Triggered when free mode\n  fails to make sufficient progress.\n\nGlobalization strategies (adaptive_mu_globalization_):\n- KKT_ERROR: Track reduction in primal-dual KKT error\n- FILTER_OBJ_CONSTR: Use filter on (theta, phi)\n- NEVER_MONOTONE_MODE: Always stay in free mode\n\nFree mode oracles (via MuOracle):\n- QualityFunctionMuOracle: Minimize quality function\n- ProbingMuOracle: Try candidate mu values\n- LoqoMuOracle: LOQO-style adaptive rule\n\nFixed mode behavior:\n- Uses fix_mu_oracle_ or average complementarity\n- restore_accepted_iterate_: Can restore last good free-mode point\n\nReference value tracking:\n- refs_vals_: List of recent KKT error values\n- refs_red_fact_: Required reduction factor\n- num_refs_max_: Maximum stored references"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
            "meta": {
              "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAugSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the 4x4 augmented KKT system\n\nAugSystemSolver defines the interface for solving the reduced\naugmented system obtained by eliminating bound multiplier equations:\n\n  [W + Dx + \u03b4x*I      0        Jc^T      Jd^T  ] [sol_x]   [rhs_x]\n  [    0         Ds + \u03b4s*I     0         -I   ] [sol_s] = [rhs_s]\n  [   Jc             0      Dc - \u03b4c*I    0    ] [sol_c]   [rhs_c]\n  [   Jd            -I         0      Dd - \u03b4d*I] [sol_d]   [rhs_d]"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
            "meta": {
              "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
            "meta": {
              "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoIterateInitializer.hpp",
            "meta": {
              "brief": "Iterate initialization for restoration phase\n\nRestoIterateInitializer computes starting values for all variables\nin the restoration phase feasibility problem. This includes the\noriginal variables (x, s) and the slack variables (n_c, p_c, n_d, p_d)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
            "meta": {
              "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDFullSpaceSolver.hpp",
            "meta": {
              "brief": "Full-space primal-dual system solver with inertia correction\n\nPDFullSpaceSolver is the main implementation of PDSystemSolver.\nIt reduces the 8x8 primal-dual system to the 4x4 augmented system\nby eliminating bound multiplier equations:\n  d_z = S^{-1}(rhs_z - Z*P^T*d_x)\n\nKey features:\n- Iterative refinement with quality monitoring (residual_ratio)\n- Inertia correction via PDPerturbationHandler (adds delta_x, delta_c)\n- Automatic retries with increased pivot tolerance\n- Handles singular systems by adding regularization\n\nParameters:\n- min/max_refinement_steps: Iterative refinement bounds\n- residual_ratio_max: Acceptable solution quality threshold\n- neg_curv_test_tol: Tolerance for inertia heuristics"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIterationOutput.hpp",
            "meta": {
              "brief": "Strategy interface for per-iteration output display\n\nIterationOutput is the abstract base for strategies that produce\nthe iteration summary line and optional detailed output.\n\nStandard output line (from OrigIterationOutput):\n  iter  objective   inf_pr   inf_du   lg(mu)  ||d||  lg(rg) alpha_du alpha_pr ls\n\nInfPrOutput enum controls whether inf_pr shows internal (with slacks)\nor original NLP constraint violation.\n\nImplementations:\n- OrigIterationOutput: Standard one-line summary for original problem\n- RestoIterationOutput: Output during restoration phase\n\nOutput controlled by print_level option (0-12)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptData.hpp",
            "meta": {
              "brief": "Central storage for all iteration data in Ipopt\n\nIpoptData holds the algorithmic state across iterations:\n- curr_: Current iterate (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\n- trial_: Trial point from line search\n- delta_: Search direction from KKT solve\n- delta_aff_: Affine-scaling step (for Mehrotra predictor-corrector)\n- W_: Hessian or Hessian approximation"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgStrategy.hpp",
            "meta": {
              "brief": "Base class for all pluggable algorithm components\n\nAlgorithmStrategyObject is the abstract base for Ipopt's Strategy pattern\nimplementation. All pluggable algorithm components inherit from this:\n- LineSearch, MuUpdate, ConvergenceCheck\n- SearchDirectionCalculator, HessianUpdater\n- PDSystemSolver, AugSystemSolver"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
            "meta": {
              "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundVector.hpp",
            "meta": {
              "brief": "Composite vector stacking multiple sub-vectors\n\nCompoundVector implements the Composite pattern for vectors,\nrepresenting: x_compound = [x_0; x_1; ...; x_{n-1}]"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
            "meta": {
              "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactNewtonNormal.hpp",
            "meta": {
              "brief": "Newton normal step from slack-scaled augmented system\n\nInexactNewtonNormalStep computes the normal step component by\nsolving a reduced system derived from the slack-scaled KKT system."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactSearchDirCalc.hpp",
            "meta": {
              "brief": "Search direction via normal-tangential decomposition\n\nInexactSearchDirCalculator computes the search direction using\niterative linear solvers by decomposing into normal and tangential\ncomponents, enabling inexact Newton methods."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactPDSolver.hpp",
            "meta": {
              "brief": "Primal-dual system solver for inexact Newton methods\n\nInexactPDSolver solves the primal-dual system using iterative linear\nsolvers, allowing for inexact solutions that don't fully satisfy\nthe linearized KKT conditions."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactCq.hpp",
            "meta": {
              "brief": "Cached quantities for inexact Newton / Chen-Goldfarb penalty method\n\nInexactCq provides precomputed and cached quantities specific to the\ninexact Newton algorithm, extending IpoptCalculatedQuantities."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSlackBasedTSymScalingMethod.hpp",
            "meta": {
              "brief": "Simple scaling based on current slack values\n\nSlackBasedTSymScalingMethod computes scaling factors using only\nthe current slack values, without requiring external HSL routines.\nDesigned for use with inexact/iterative linear solvers.\n\nUnlike MC19 which performs full equilibration, this method uses\na simpler heuristic based on:\n- Current slack variable values s\n- Diagonal elements of the KKT system\n\nBenefits:\n- No external library dependencies\n- Lightweight computation\n- Suitable when full equilibration is unnecessary\n\nLimitations:\n- May not achieve as good conditioning as MC19\n- Best for problems where slacks dominate scaling needs"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
            "meta": {
              "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_knapsack.hpp",
            "meta": {
              "brief": "MKC knapsack subproblem for column generation"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_vargen.hpp",
            "meta": {
              "brief": "MKC variable generation (pricing)"
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/CSP_colgen.hpp",
            "meta": {
              "brief": "CSP column generation"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_user.hpp",
            "meta": {
              "brief": "User customization interface for LP process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_functions.hpp",
            "meta": {
              "brief": "LP process internal function declarations"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_pool.hpp",
            "meta": {
              "brief": "Cut and variable pools for LP process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_vg.hpp",
            "meta": {
              "brief": "Variable Generator process for BCP Branch-Cut-Price (pricing)"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart_primaldual.hpp",
            "meta": {
              "brief": "Primal-dual warm start for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_enum.hpp",
            "meta": {
              "brief": "Core enumerations for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_vg_user.hpp",
            "meta": {
              "brief": "User customization interface for Variable Generator process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_solution.hpp",
            "meta": {
              "brief": "Solution representation for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_functions.hpp",
            "meta": {
              "brief": "Warmstart serialization utilities"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
            "meta": {
              "brief": "LP warm start information for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_set_intersects.hpp",
            "meta": {
              "brief": "Set intersection test utility"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart_dual.hpp",
            "meta": {
              "brief": "Dual-only warm start for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_message_tag.hpp",
            "meta": {
              "brief": "Message tag enumeration for BCP inter-process communication"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_result.hpp",
            "meta": {
              "brief": "LP solve results for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
            "meta": {
              "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneObject.hpp",
            "meta": {
              "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneSOSObject.hpp",
            "meta": {
              "brief": "Special Ordered Set (SOS) branching for Couenne"
            }
          },
          {
            "id": "Couenne/src/problem/CouenneProblem.hpp",
            "meta": {
              "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
            }
          },
          {
            "id": "Dip/Dip/src/DecompVar.h",
            "meta": {
              "brief": "Column generation variable (lambda) representation\n\nDecompVar represents a column in the Dantzig-Wolfe reformulation.\nEach lambda_s corresponds to an extreme point s of a subproblem\npolyhedron: conv{x : A'x >= b', x integer}."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgo.h",
            "meta": {
              "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoRC.h",
            "meta": {
              "brief": "Relax-and-Cut algorithm (Lagrangian relaxation with cuts)\n\nDecompAlgoRC implements Lagrangian relaxation:\n- Dualize complicating constraints with multipliers u\n- Solve Lagrangian subproblem: min (c - u'A'')x s.t. A'x >= b'\n- Update multipliers via subgradient optimization\n- Add cuts to improve bounds"
            }
          },
          {
            "id": "Dip/Dip/src/Decomp.h",
            "meta": {
              "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoPC.h",
            "meta": {
              "brief": "Price-and-Cut algorithm (Dantzig-Wolfe decomposition with cuts)\n\nDecompAlgoPC implements the most powerful DIP algorithm combining:\n- Column generation (pricing subproblems)\n- Cut generation (violated inequalities)\n- Branch-and-bound integration via ALPS"
            }
          },
          {
            "id": "SYMPHONY/include/sym_master.h",
            "meta": {
              "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
            }
          },
          {
            "id": "SYMPHONY/include/symphony.h",
            "meta": {
              "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
            }
          },
          {
            "id": "Gravity/include/gravity/constraint.h",
            "meta": {
              "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkPrimal.h",
            "meta": {
              "brief": "Phase 2 primal simplex solver for HiGHS"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsMipSolver.h",
            "meta": {
              "brief": "Branch-and-cut MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/presolve/HPresolve.h",
            "meta": {
              "brief": "LP/MIP presolve engine\n\n**HPresolve Class:**\nReduces problem size and tightens bounds before solving.\n\n**Matrix Storage:**\nTriplet format with linked list (column) and splay tree (row) for fast access:\n- Avalue[], Arow[], Acol[]: Non-zero storage\n- colhead[], Anext[], Aprev[]: Column-wise linked list\n- rowroot[], ARleft[], ARright[]: Row-wise splay tree\n- rowsize[], colsize[]: Current row/column lengths\n\n**Bound Tracking:**\n- implColLower[]/implColUpper[]: Implied variable bounds\n- rowDualLower[]/rowDualUpper[]: Dual bounds\n- impliedRowBounds, impliedDualRowBounds: Row activity bounds\n\n**Presolve Techniques (Result enum):**\n- singletonRow()/singletonCol(): Remove singleton rows/columns\n- emptyCol(): Remove columns with no constraints\n- doubletonEq(): Eliminate doubleton equalities\n- dominatedColumns(): Remove dominated variables\n- aggregator(): Aggregate rows/columns\n- runProbing(): Probing for integer variables\n- sparsify(): Reduce matrix density\n- detectParallelRowsAndCols(): Remove parallel constraints/variables"
            }
          },
          {
            "id": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
            "meta": {
              "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/iterate.h",
            "meta": {
              "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/crossover.h",
            "meta": {
              "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/ipm.h",
            "meta": {
              "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/kkt_solver.h",
            "meta": {
              "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
            "meta": {
              "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
            }
          },
          {
            "id": "SHOT/src/DualSolver.h",
            "meta": {
              "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
            }
          }
        ]
      }
    },
    "Lagrangian": {
      "id": "Lagrangian",
      "name": "Lagrangian Function",
      "category": "optimality",
      "definition": "L(x,\u03bb) = f(x) + \u03bb^T g(x). Combines objective and constraints with multipliers.",
      "intuition": "Price the constraint violations. Optimal multipliers \u03bb* are the right prices to make x* optimal.",
      "aliases": [
        "Lagrange function"
      ],
      "key_equations": [
        "L(x,\u03bb) = f(x) + \u03a3 \u03bb_i g_i(x)"
      ],
      "relationships": {
        "contains": [
          {
            "id": "KKT_conditions"
          }
        ],
        "implemented_in": [
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_QPNapsack.hpp",
            "meta": {
              "brief": "Napsack subproblem solver for QP balance constraint\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPNapsack solves the napsack subproblem: find lambda such that the\nprojected solution satisfies balance constraint lo <= a'x <= hi.\nUses breakpoint method with heaps to efficiently find optimal lambda.\nCore subroutine in QP gradient projection."
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblem.hpp",
            "meta": {
              "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpTNLP.hpp",
            "meta": {
              "brief": "User interface for defining NLP problems in standard form\n\nTNLP (Templated NLP) is the primary user-facing class for defining\noptimization problems. Users inherit from TNLP and implement:"
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpNLP.hpp",
            "meta": {
              "brief": "Internal NLP representation using Vector/Matrix abstractions\n\nNLP is Ipopt's internal problem representation with equality constraints\nseparated from inequalities:\n  min  f(x)\n  s.t. c(x) = 0           (equality constraints)\n       d_L <= d(x) <= d_U (inequality constraints)\n       x_L <= x <= x_U    (variable bounds)\n\nUnlike TNLP (user interface with arrays), NLP uses Vector and Matrix\nobjects for all operations. TNLPAdapter converts TNLP to this form."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
            "meta": {
              "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
            "meta": {
              "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpHessianUpdater.hpp",
            "meta": {
              "brief": "Strategy interface for Hessian computation/approximation\n\nHessianUpdater is the abstract base for strategies that provide\nthe Hessian of the Lagrangian (or an approximation) to the algorithm.\nThe result is stored in IpData.W()."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
            "meta": {
              "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpZeroSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix with all zero entries\n\nZeroSymMatrix represents a symmetric zero matrix (n x n).\nNo storage required. Inherits from SymMatrix for type safety."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
            "meta": {
              "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP.hpp",
            "meta": {
              "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
            "meta": {
              "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgo.h",
            "meta": {
              "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoRC.h",
            "meta": {
              "brief": "Relax-and-Cut algorithm (Lagrangian relaxation with cuts)\n\nDecompAlgoRC implements Lagrangian relaxation:\n- Dualize complicating constraints with multipliers u\n- Solve Lagrangian subproblem: min (c - u'A'')x s.t. A'x >= b'\n- Update multipliers via subgradient optimization\n- Add cuts to improve bounds"
            }
          },
          {
            "id": "Dip/Dip/src/Decomp.h",
            "meta": {
              "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
            }
          },
          {
            "id": "Gravity/include/gravity/constraint.h",
            "meta": {
              "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
            "meta": {
              "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
            }
          }
        ]
      }
    },
    "complementary_slackness": {
      "id": "complementary_slackness",
      "name": "Complementary Slackness",
      "category": "optimality",
      "definition": "At optimality, either a constraint is tight (g_i = 0) or its multiplier is zero (\u03bb_i = 0).",
      "intuition": "You don't pay for slack constraints. If constraint is loose, its price is zero.",
      "key_equations": [
        "\u03bb_i g_i(x) = 0"
      ],
      "relationships": {
        "requires": [
          {
            "id": "KKT_conditions"
          }
        ],
        "implemented_in": [
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpHelperFunctions.hpp",
            "meta": {
              "brief": "BLAS-1 style dense vector operations for Clp"
            }
          },
          {
            "id": "Clp/src/ClpPredictorCorrector.hpp",
            "meta": {
              "brief": "Mehrotra's predictor-corrector interior point algorithm"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
            "meta": {
              "brief": "Online QP Benchmark Collection interface"
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpIpoptApplication.hpp",
            "meta": {
              "brief": "Main application class for calling Ipopt from C++\n\nIpoptApplication is the entry point for C++ applications using Ipopt.\nProvides methods for initialization, option handling, and solving."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpProbingMuOracle.hpp",
            "meta": {
              "brief": "Mehrotra's probing heuristic for barrier parameter selection\n\nProbingMuOracle implements Mehrotra's predictor-corrector approach\nto compute the barrier parameter mu. This is the strategy used in\nmany interior point codes like LOQO and PCx.\n\nAlgorithm:\n1. Compute affine scaling direction (predictor step) with sigma=0\n2. Find maximum step to boundary (alpha_aff)\n3. Compute complementarity after affine step: mu_aff\n4. Compute centering parameter: sigma = (mu_aff/mu)^3\n5. Use sigma in corrector step\n\nThe centering parameter sigma controls the balance between:\n- sigma=0: Pure affine scaling (aggressive, may overshoot)\n- sigma=1: Pure centering (conservative, slow progress)\n\nKey parameter:\n- sigma_max_: Upper bound on sigma to prevent excessive centering"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoRestoPhase.hpp",
            "meta": {
              "brief": "Recursive restoration for separable n,p variable initialization\n\nRestoRestorationPhase provides a specialized \"restoration within\nrestoration\" procedure for the MinC_1NrmRestorationPhase. It computes\noptimal values for the slack variables (n_c, p_c, n_d, p_d) by\ntreating them as separable from x and s."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIterateInitializer.hpp",
            "meta": {
              "brief": "Strategy interface for computing initial iterates\n\nIterateInitializer is the abstract base for strategies that\ncompute the starting point (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\nfor the interior point algorithm."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMuOracle.hpp",
            "meta": {
              "brief": "Strategy interface for suggesting barrier parameter values\n\nMuOracle is the abstract interface for components that compute\nsuggested values for the barrier parameter mu in adaptive (non-monotone)\nbarrier updates."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpConvCheck.hpp",
            "meta": {
              "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLoqoMuOracle.hpp",
            "meta": {
              "brief": "LOQO formula for barrier parameter selection\n\nLoqoMuOracle computes the barrier parameter using the heuristic\nfrom the LOQO solver (Vanderbei). This provides a simple formula\nbased on current complementarity.\n\nThe LOQO formula typically uses:\n  sigma = min(0.1, 100*mu)\n  mu_new = sigma * (current_complementarity / n)\n\nThis is a simple, stateless oracle that doesn't require solving\nan additional linear system (unlike probing or quality function).\n\nCompared to other strategies:\n- ProbingMuOracle: Requires affine step computation\n- QualityFunctionMuOracle: Requires 1D optimization\n- LoqoMuOracle: Direct formula, no extra computation"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
            "meta": {
              "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoMinC_1Nrm.hpp",
            "meta": {
              "brief": "Restoration phase minimizing 1-norm of constraint violation\n\nMinC_1NrmRestorationPhase is the main restoration phase implementation.\nWhen the line search cannot make progress, it minimizes constraint\nviolation to find a feasible point from which optimization can continue.\n\nRestoration NLP formulation:\n  min  \u03c1 * ||[p_c; n_c; p_d; n_d]||_1 + (\u03b7/2) * ||D_r(x - x_ref)||_2^2\n  s.t. c(x) - p_c + n_c = 0\n       d_L <= d(x) - p_d + n_d <= d_U\n       x_L <= x <= x_U\n       p_c, n_c, p_d, n_d >= 0\n\nWhere:\n- \u03c1: Penalty on infeasibility (resto_penalty_parameter)\n- \u03b7: Proximity weight (resto_proximity_weight * sqrt(mu))\n- D_r: Diagonal scaling based on reference point\n- x_ref: Starting point for restoration\n\nKey behaviors:\n- Uses nested IpoptAlgorithm to solve restoration NLP\n- eq_mult_calculator_ reinitializes multipliers after restoration\n- bound_mult_reset_threshold_: Limits post-restoration bound multipliers\n- count_restorations_: Tracks restoration phase calls"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpDefaultIterateInitializer.hpp",
            "meta": {
              "brief": "Standard initialization procedure for IPM iterates\n\nDefaultIterateInitializer computes starting points for all primal\nand dual variables based on user options and problem bounds.\n\nPrimal initialization (x, s):\n- Start from user-provided x0 or NLP default\n- Push away from bounds: x_new = max(x_L + \u03b5, min(x, x_U - \u03b5))\n- bound_push_, bound_frac_: Absolute/relative push parameters\n- least_square_init_primal_: Fit linearized constraints\n\nDual initialization:\n- Equality multipliers (y_c, y_d): Least-squares or zero\n- eq_mult_calculator_: Computes min ||y|| s.t. KKT gradient\n- constr_mult_init_max_: Reject large multiplier estimates\n- Bound multipliers (z_L, z_U, v_L, v_U):\n  - B_CONSTANT: bound_mult_init_val_\n  - B_MU_BASED: mu_init_ / slack\n\nWarm start:\n- warm_start_init_point_: Use warm_start_initializer_ instead\n- Delegates to WarmStartIterateInitializer\n\nStatic utilities:\n- push_variables(): Move point away from bounds\n- least_square_mults(): Compute y from gradient conditions"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMuUpdate.hpp",
            "meta": {
              "brief": "Strategy interface for updating barrier parameter mu\n\nMuUpdate is the abstract base for strategies that determine the\nbarrier parameter mu and fraction-to-boundary parameter tau for\neach iteration of the interior point method."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
            "meta": {
              "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
            "meta": {
              "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDFullSpaceSolver.hpp",
            "meta": {
              "brief": "Full-space primal-dual system solver with inertia correction\n\nPDFullSpaceSolver is the main implementation of PDSystemSolver.\nIt reduces the 8x8 primal-dual system to the 4x4 augmented system\nby eliminating bound multiplier equations:\n  d_z = S^{-1}(rhs_z - Z*P^T*d_x)\n\nKey features:\n- Iterative refinement with quality monitoring (residual_ratio)\n- Inertia correction via PDPerturbationHandler (adds delta_x, delta_c)\n- Automatic retries with increased pivot tolerance\n- Handles singular systems by adding regularization\n\nParameters:\n- min/max_refinement_steps: Iterative refinement bounds\n- residual_ratio_max: Acceptable solution quality threshold\n- neg_curv_test_tol: Tolerance for inertia heuristics"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
            "meta": {
              "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneComplBranchingObject.hpp",
            "meta": {
              "brief": "Branching object for complementarity constraints"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneComplObject.hpp",
            "meta": {
              "brief": "Branching object for complementarity constraints"
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/iterate.h",
            "meta": {
              "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/crossover.h",
            "meta": {
              "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/ipm.h",
            "meta": {
              "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
            }
          }
        ]
      }
    },
    "convexity": {
      "id": "convexity",
      "name": "Convexity",
      "category": "structure",
      "definition": "A set is convex if line segments between any two points stay in the set. A function is convex if its epigraph is convex.",
      "intuition": "No \"dents\" or \"holes\". Can't get stuck in local optima because there's only one valley.",
      "key_equations": [
        "f(\u03b8x + (1-\u03b8)y) \u2264 \u03b8f(x) + (1-\u03b8)f(y)"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "Clp/src/ClpQuadraticObjective.hpp",
            "meta": {
              "brief": "Quadratic objective function for convex QP (x'Qx/2 + c'x)\n\nImplements convex quadratic objectives for quadratic programming.\nThe quadratic term is stored as a CoinPackedMatrix Q, supporting\nboth full symmetric and half (lower triangular) storage."
            }
          },
          {
            "id": "Clp/src/ClpConstraintQuadratic.hpp",
            "meta": {
              "brief": "Quadratic constraint implementation: x'Qx + c'x \u2264 b\n\nImplements ClpConstraint for quadratic constraints. The constraint\nfunction is: 0.5 * sum_{ij}(Q_ij * x_i * x_j) + sum_j(c_j * x_j) \u2264 b"
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/drivers/psdrivers.h",
            "meta": {
              "brief": "Drivers for piecewise smooth (PS) functions with abs-normal form\n\nProvides differentiation tools for functions containing absolute values\nand other piecewise linear operations. These functions are not classically\ndifferentiable at kink points, but have well-defined generalized derivatives."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDW.hpp",
            "meta": {
              "brief": "Dantzig-Wolfe decomposition based heuristic\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDW: Advanced heuristic exploiting block structure.\nVery compute-intensive - detects and exploits Dantzig-Wolfe\ndecomposable structure in the constraint matrix."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
            "meta": {
              "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
            "meta": {
              "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
            "meta": {
              "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaDecBase.hpp",
            "meta": {
              "brief": "Base class for Outer Approximation (OA) decomposition algorithms\n\nImplements the foundation for OA-based MINLP algorithms. OA iterates between\nsolving MILP subproblems and NLP subproblems, generating linear outer\napproximations of the nonlinear constraints.\n\n**OA algorithm outline:**\n1. Solve MILP relaxation \u2192 get integer solution x*\n2. Fix integers to x*, solve NLP \u2192 get nonlinear solution y*\n3. Generate linearization cuts at y* (gradient-based)\n4. Add cuts to MILP, repeat until convergence\n\n**Key components:**\n- solverManip: RAII helper to save/restore solver state\n- performOa(): Virtual method implementing specific OA variant\n- post_nlp_solve(): Handle NLP solution and update bounds\n\n**Parameters:**\n- global_: Add cuts globally (valid at all nodes)\n- addOnlyViolated_: Only add cuts violated by current solution\n- maxLocalSearch_: Limit on local search iterations"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
            "meta": {
              "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
            "meta": {
              "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
            }
          },
          {
            "id": "Bonmin/experimental/Separable/BonHeuristicInnerApproximation.hpp",
            "meta": {
              "brief": "Bonmin inner approximation heuristic for MINLP\n\nPrimal heuristic using inner approximation of feasible region.\nGenerates feasible MINLP solutions from LP relaxations."
            }
          },
          {
            "id": "Bonmin/experimental/Separable/BonOuterDescription.hpp",
            "meta": {
              "brief": "Bonmin outer approximation description for convex MINLP\n\nOuter approximation (OA) cut management for MINLP.\nLinearization-based approach for convex MINLP."
            }
          },
          {
            "id": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
            "meta": {
              "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection for branching in global optimization"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
            "meta": {
              "brief": "Three-way spatial branching for continuous variables"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneBranchingObject.hpp",
            "meta": {
              "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneObject.hpp",
            "meta": {
              "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
            "meta": {
              "brief": "Orbital branching object using symmetry"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneSOSObject.hpp",
            "meta": {
              "brief": "Special Ordered Set (SOS) branching for Couenne"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneChooseStrong.hpp",
            "meta": {
              "brief": "Strong branching for global MINLP optimization\n\nExtends Bonmin's strong branching to handle nonconvex constraints\nby evaluating actual LP bound improvement from branching."
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneAggrProbing.hpp",
            "meta": {
              "brief": "Aggressive probing for bound tightening\n\nImplements Optimality-Based Bound Tightening (OBBT) through aggressive\nprobing. Temporarily fixes a variable bound and solves the resulting\nsubproblem to determine if a tighter bound is achievable."
            }
          },
          {
            "id": "Couenne/src/problem/CouenneProblem.hpp",
            "meta": {
              "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneFeasPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprPow.hpp",
            "meta": {
              "brief": "Power expression w = x^k with convexification"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprMul.hpp",
            "meta": {
              "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
            "meta": {
              "brief": "Quadratic expression with alpha-convexification"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
            "meta": {
              "brief": "Trilinear product expression w = x*y*z"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
            "meta": {
              "brief": "Bound tightening from pairs of linear constraints"
            }
          },
          {
            "id": "Couenne/src/cut/crossconv/CouenneCrossConv.hpp",
            "meta": {
              "brief": "Cuts from redundant relationships between auxiliary variables"
            }
          },
          {
            "id": "Dip/Dip/src/DecompVar.h",
            "meta": {
              "brief": "Column generation variable (lambda) representation\n\nDecompVar represents a column in the Dantzig-Wolfe reformulation.\nEach lambda_s corresponds to an extreme point s of a subproblem\npolyhedron: conv{x : A'x >= b', x integer}."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoPC.h",
            "meta": {
              "brief": "Price-and-Cut algorithm (Dantzig-Wolfe decomposition with cuts)\n\nDecompAlgoPC implements the most powerful DIP algorithm combining:\n- Column generation (pricing subproblems)\n- Cut generation (violated inequalities)\n- Branch-and-bound integration via ALPS"
            }
          },
          {
            "id": "Gravity/include/gravity/expr.h",
            "meta": {
              "brief": "Expression tree nodes for unary and binary operations\n\nExpressions are the building blocks for functions and constraints."
            }
          },
          {
            "id": "Gravity/include/gravity/func.h",
            "meta": {
              "brief": "Expression functions with automatic differentiation and convexity tracking\n\nThe func class represents mathematical expressions with symbolic analysis."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/factor.hpp",
            "meta": {
              "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
            "meta": {
              "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
            }
          }
        ]
      }
    },
    "sparsity": {
      "id": "sparsity",
      "name": "Sparsity",
      "category": "structure",
      "definition": "Matrix has mostly zero entries. Enables efficient storage and computation.",
      "intuition": "Real-world problems often have structure\u2014each variable affects only a few constraints.",
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinPresolveZeros.hpp",
            "meta": {
              "brief": "Drop and reintroduce explicit zero coefficients"
            }
          },
          {
            "id": "CoinUtils/src/CoinSimpFactorization.hpp",
            "meta": {
              "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
            }
          },
          {
            "id": "CoinUtils/src/CoinPackedMatrix.hpp",
            "meta": {
              "brief": "Sparse matrix stored in compressed row or column format\n\nCoinPackedMatrix represents a sparse matrix using compressed storage.\nCan be stored row-major or column-major. Efficient for major-dimension\noperations (accessing rows in row-major, columns in column-major)."
            }
          },
          {
            "id": "CoinUtils/src/CoinOslFactorization.hpp",
            "meta": {
              "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
            }
          },
          {
            "id": "CoinUtils/src/CoinIndexedVector.hpp",
            "meta": {
              "brief": "Sparse vector with dense backing array for O(1) element access\n\nCoinIndexedVector combines sparse index storage with a dense values array,\nenabling O(1) random access while tracking which positions are non-zero.\nDesigned for simplex operations where sparse updates need fast access.\nHas optional \"packed\" mode that behaves more like CoinPackedVector."
            }
          },
          {
            "id": "CoinUtils/src/CoinPackedVector.hpp",
            "meta": {
              "brief": "Sparse vector that owns its index/value storage\n\nCoinPackedVector stores a sparse vector as parallel arrays of indices\nand values. Unlike CoinShallowPackedVector, this class owns its storage\nand supports modification operations."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Sanitize.hpp",
            "meta": {
              "brief": "Matrix preprocessing for graph partitioning\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nMatrix sanitization prepares input for partitioning: sanitizeMatrix\nhandles symmetry and binary weights, removeDiagonal strips self-loops,\nmirrorTriangular expands triangular to symmetric. Ensures valid\nundirected graph representation for algorithms."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_IO.hpp",
            "meta": {
              "brief": "Matrix Market file I/O for graphs and matrices\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nFile I/O for Mongoose: read_graph creates Graph from Matrix Market file,\nread_matrix creates cs struct. Handles symmetrization (A+A')/2 for\nasymmetric matrices, extracts largest connected component, removes\ndiagonal. Accepts C string or std::string filenames."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Graph.hpp",
            "meta": {
              "brief": "Graph data structure for Mongoose partitioning\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nGraph class stores adjacency in CSC format (p, i arrays) with optional\nedge weights (x) and vertex weights (w). Factory methods create from\nraw arrays or CSparse matrices. Shallow copy flags track ownership."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_CSparse.hpp",
            "meta": {
              "brief": "Sparse matrix operations subset from CSparse library\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nProvides CSparse subset for sparse matrix operations: cs struct\n(compressed column/triplet format), cs_add (matrix addition),\ncs_transpose, cs_compress (triplet to CSC), and allocation.\nUses int64_t (csi) matching Mongoose's Int type."
            }
          },
          {
            "id": "SuiteSparse/SPQR/Include/SuiteSparseQR.hpp",
            "meta": {
              "brief": "User C++ API for sparse multifrontal QR factorization\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nMain user interface for SPQR: SuiteSparseQR overloads for [Q,R,E]=qr(A),\nX=A\\B, qmult. Structures: spqr_symbolic (pattern analysis), spqr_numeric\n(R values, Householder H), spqr_gpu (GPU staging). Expert functions:\nSuiteSparseQR_factorize, _solve, _min2norm, _symbolic, _numeric for\nfactorization reuse. Supports real/complex, int32/int64."
            }
          },
          {
            "id": "SuiteSparse/SPQR/Include/spqr.hpp",
            "meta": {
              "brief": "Internal SPQR implementation functions and data structures\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nNon-user-callable routines: spqr_analyze (symbolic), spqr_factorize (numeric),\nspqr_kernel (parallel front factorization), spqr_assemble/cpack/rhpack (front\nassembly). Support: spqr_tol, stranspose1/2, larftb (block reflectors),\nhapply, panel, 1colamd, 1fixed. Helper structs: spqr_work, spqr_blob.\nMacros: FLIP/UNFLIP for marking, INDEX for column-major."
            }
          },
          {
            "id": "SuiteSparse/ParU/Source/paru_internal.hpp",
            "meta": {
              "brief": "Internal data structures and functions for ParU sparse LU\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis.\nGPL-3.0-or-later license.\n\nCore ParU structures: ParU_Symbolic_struct (row-form S, singletons, fronts,\ntask tree), ParU_Numeric_struct (LU factors, permutations, scaling),\nParU_Control_struct (tolerances, threading). paru_element (contribution\nblock), paru_work (workspace), paru_tuple (element lists). Internal\nfunctions: front assembly/factorization, heap management, BLAS threading.\nIncludes UMFPACK SymbolicType/SWType for singleton detection."
            }
          },
          {
            "id": "SuiteSparse/RBio/Include/RBio.h",
            "meta": {
              "brief": "Rutherford-Boeing sparse matrix I/O library\nCopyright (c) 2009-2023, Timothy A. Davis. GPL-2.0+ license.\n\nRBio reads and writes sparse matrices in Rutherford-Boeing format,\na standard format for exchanging sparse matrices. Supports real, complex,\ninteger, and pattern-only matrices in assembled or elemental forms."
            }
          },
          {
            "id": "SuiteSparse/CSparse/Include/cs.h",
            "meta": {
              "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
            }
          },
          {
            "id": "SuiteSparse/UMFPACK/Source/umf_internal.h",
            "meta": {
              "brief": "Internal definitions for UMFPACK sparse LU factorization\nCopyright (c) 2005-2023, Timothy A. Davis. GPL-2.0+ license.\n\nUMFPACK is an unsymmetric multifrontal sparse LU factorization package.\nComputes P\u00b7A\u00b7Q = L\u00b7U via supernodal factorization with partial pivoting.\nHandles real and complex matrices in single and double precision."
            }
          },
          {
            "id": "SuiteSparse/BTF/Include/btf_internal.h",
            "meta": {
              "brief": "Internal definitions for BTF (Block Triangular Form) permutation\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nBTF finds permutation matrices P and Q such that P\u00b7A\u00b7Q has block upper\ntriangular form with square diagonal blocks that are irreducible\n(strongly connected components). Essential preprocessing for sparse LU."
            }
          },
          {
            "id": "SuiteSparse/KLU/Include/klu_internal.h",
            "meta": {
              "brief": "Internal definitions for KLU sparse LU factorization\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nKLU is a sparse LU factorization package designed for circuit simulation\nmatrices, which are typically highly sparse with near-diagonal structure.\nUses BTF (Block Triangular Form) permutation to exploit structure."
            }
          },
          {
            "id": "SuiteSparse/CHOLMOD/Include/cholmod_internal.h",
            "meta": {
              "brief": "Internal definitions for CHOLMOD sparse Cholesky factorization\nCopyright (C) 2005-2023, Timothy A. Davis. Apache-2.0 license.\n\nCHOLMOD is a comprehensive sparse Cholesky factorization package supporting\nsupernodal and simplicial methods, update/downdate, and multiple orderings.\nHandles symmetric positive definite systems A\u00b7x = b via L\u00b7L' = A."
            }
          },
          {
            "id": "SuiteSparse/LDL/Include/ldl.h",
            "meta": {
              "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
            }
          },
          {
            "id": "SuiteSparse/ParU/Include/ParU.h",
            "meta": {
              "brief": "Parallel unsymmetric multifrontal sparse LU factorization\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis. GPL-3.0-or-later.\n\nParU is a parallel sparse direct solver using OpenMP tasking for task-based\nparallelism combined with parallel BLAS (nested parallelism). Solves Ax = b\nfor sparse A via LU factorization with partial pivoting."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyPardiso.hpp",
            "meta": {
              "brief": "Intel MKL Pardiso sparse direct solver for Cholesky factorization\n\nWraps Intel's Pardiso solver from the Math Kernel Library (MKL) for\nCholesky factorization of normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyUfl.hpp",
            "meta": {
              "brief": "SuiteSparse CHOLMOD interface for Cholesky factorization\n\nWraps the CHOLMOD library from SuiteSparse (University of Florida) for\nCholesky factorization of normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/AbcSimplexPrimal.hpp",
            "meta": {
              "brief": "AVX-optimized primal simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpConstraintLinear.hpp",
            "meta": {
              "brief": "Linear constraint implementation for nonlinear extensions\n\nImplements ClpConstraint for a linear constraint: sum(a_j * x_j) = b.\nUsed with ClpSimplexNonlinear when linear constraints appear alongside\nnonlinear objective or other nonlinear constraints."
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpDummyMatrix.hpp",
            "meta": {
              "brief": "Placeholder matrix with dimensions but no data\n\nImplements ClpMatrixBase with only dimensions (rows, columns, elements)\nbut no actual matrix data. Used primarily with ClpPdco where the user\nprovides custom matrix-vector products via callbacks."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyMumps.hpp",
            "meta": {
              "brief": "MUMPS sparse direct solver interface for Cholesky factorization\n\nWraps the MUMPS (MUltifrontal Massively Parallel sparse direct Solver)\nlibrary for Cholesky factorization of normal equations in interior point."
            }
          },
          {
            "id": "Clp/src/ClpConstraint.hpp",
            "meta": {
              "brief": "Abstract base class for nonlinear constraints\n\nDefines the interface for general (potentially nonlinear) constraints\nused in nonlinear programming extensions. The standard LP constraints\n(Ax \u2264 b) are handled directly by ClpModel; this class is for more\ngeneral constraint forms g(x) \u2264 0."
            }
          },
          {
            "id": "Clp/src/AbcSimplexFactorization.hpp",
            "meta": {
              "brief": "LU factorization wrapper for ABC simplex"
            }
          },
          {
            "id": "Clp/src/CoinAbcDenseFactorization.hpp",
            "meta": {
              "brief": "Abstract base class for ABC factorization and dense submatrix handling"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyBase.hpp",
            "meta": {
              "brief": "Cholesky factorization base class for interior point methods\n\nProvides Cholesky factorization of the normal equations matrix A*D*A'\nused in predictor-corrector interior point methods. The factorization\nuses AMD ordering to reduce fill-in.\n\nThe base class provides a simple sparse Cholesky implementation with\nsupernodal dense blocks. Derived classes can interface to more\nsophisticated factorizations (MUMPS, Pardiso, TAUCS, etc.).\n\nKey methods:\n- order(): Compute fill-reducing ordering (AMD by default)\n- symbolic(): Set up sparsity structure of factor\n- factorize(): Numeric factorization of A*D*A'\n- solve(): Solve system using computed factors"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyWssmp.hpp",
            "meta": {
              "brief": "WSSMP sparse direct solver interface for Cholesky factorization\n\nWraps IBM's Watson Sparse Matrix Package (WSSMP) for Cholesky factorization\nof normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "CppAD/include/cppad/core/sparse_jac.hpp",
            "meta": {
              "brief": "Sparse Jacobian computation using graph coloring"
            }
          },
          {
            "id": "CppAD/include/cppad/core/sparse_hes.hpp",
            "meta": {
              "brief": "Sparse Hessian computation using automatic differentiation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/ConstraintProduct.hpp",
            "meta": {
              "brief": "User-defined constraint evaluation interface for structured matrices"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SparseSolver.hpp",
            "meta": {
              "brief": "Sparse linear solver interfaces for Schur-complement QP method"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
            "meta": {
              "brief": "Sparse QP solver using Schur complement for active-set updates"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblem.hpp",
            "meta": {
              "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Matrices.hpp",
            "meta": {
              "brief": "Matrix classes for QP data with working-set-aware operations"
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/sparse/sparsedrivers.h",
            "meta": {
              "brief": "High-level drivers for sparse Jacobian and Hessian computation\n\nProvides efficient computation of sparse derivatives by exploiting\nsparsity structure using graph coloring and compressed computation."
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpTNLP.hpp",
            "meta": {
              "brief": "User interface for defining NLP problems in standard form\n\nTNLP (Templated NLP) is the primary user-facing class for defining\noptimization problems. Users inherit from TNLP and implement:"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLeastSquareMults.hpp",
            "meta": {
              "brief": "Least-squares estimation of equality constraint multipliers\n\nLeastSquareMultipliers computes initial estimates for the equality\nconstraint multipliers y_c and y_d by solving a least-squares problem.\n\nFormulation: Find y minimizing ||\u2207_x L(x,y)||^2 where\n  \u2207_x L = \u2207f(x) + J_c^T y_c + J_d^T y_d - z_L + z_U\n\nThis is equivalent to solving the normal equations:\n  [J_c J_c^T    0    ] [y_c]   [-J_c (\u2207f - z_L + z_U)]\n  [   0     J_d J_d^T] [y_d] = [-J_d (\u2207f - z_L + z_U)]\n\nActually solved via augmented system:\n  [0  J_c^T  J_d^T] [r  ]   [\u2207f - z_L + z_U]\n  [J_c  0     0   ] [y_c] = [     0        ]\n  [J_d  0     0   ] [y_d]   [     0        ]\n\nUses AugSystemSolver to solve the linear system with W=0.\n\nUsage:\n- DefaultIterateInitializer: Initial multiplier estimates\n- MinC_1NrmRestorationPhase: Post-restoration multiplier reset"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
            "meta": {
              "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpTimingStatistics.hpp",
            "meta": {
              "brief": "Collection of timing statistics for algorithm profiling\n\nTimingStatistics aggregates TimedTask objects for all major\nalgorithm components, enabling performance profiling and\nbottleneck identification.\n\nTiming categories:\n- Algorithm phases: InitializeIterates, UpdateHessian, OutputIteration,\n  UpdateBarrierParameter, ComputeSearchDirection, etc.\n- Linear system: PDSystemSolverTotal, LinearSystemFactorization,\n  LinearSystemBackSolve, LinearSystemScaling\n- NLP evaluations: f_eval_time, grad_f_eval_time, c_eval_time,\n  jac_c_eval_time, d_eval_time, jac_d_eval_time, h_eval_time\n- Auxiliary: Task1-Task6 for ad-hoc profiling\n\nKey methods:\n- ResetTimes(): Clear all accumulated times\n- EnableTimes()/DisableTimes(): Control timing overhead\n- PrintAllTimingStatistics(): Output formatted timing report\n- TotalFunctionEvaluationCpuTime(): Sum of NLP evaluation times\n\nEach TimedTask tracks CPU time, system time, and wall-clock time."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
            "meta": {
              "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpSumMatrix.hpp",
            "meta": {
              "brief": "Matrix representing weighted sum of matrices: M = sum(alpha_i * M_i)\n\nSumMatrix represents a matrix as a sum of terms, each with its own\nscalar factor: M = alpha_0*M_0 + alpha_1*M_1 + ... + alpha_n*M_n"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpMatrix.hpp",
            "meta": {
              "brief": "Abstract base class for all (unsymmetric) matrix types\n\nMatrix provides the abstraction for general (non-symmetric) matrices.\nPrimary operations: MultVector (y = \u03b1*A*x + \u03b2*y) and TransMultVector."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpExpandedMultiVectorMatrix.hpp",
            "meta": {
              "brief": "Short-fat matrix V^T*P^T with expansion for KKT construction\n\nExpandedMultiVectorMatrix represents a k x n matrix (k << n) as\nV^T * P^T where V is a MultiVectorMatrix-like collection of row\nvectors and P is an optional ExpansionMatrix."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
            "meta": {
              "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMc19TSymScalingMethod.hpp",
            "meta": {
              "brief": "Matrix scaling using HSL MC19 equilibration\n\nMc19TSymScalingMethod uses the HSL subroutine MC19 to compute\nequilibration scaling factors for symmetric matrices."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpWsmpSolverInterface.hpp",
            "meta": {
              "brief": "Interface to IBM WSMP sparse symmetric direct solver\n\nWsmpSolverInterface wraps the Watson Sparse Matrix Package (WSMP),\na high-performance parallel direct solver developed at IBM for\nsparse symmetric indefinite linear systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
            "meta": {
              "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa28TDependencyDetector.hpp",
            "meta": {
              "brief": "Dependency detector using HSL MA28 unsymmetric solver\n\nMa28TDependencyDetector uses the unsymmetric sparse solver MA28\nto detect linearly dependent rows in the constraint Jacobian.\nUnlike the symmetric solvers, MA28 handles general rectangular\nmatrices, making it suitable for analyzing the constraint Jacobian\ndirectly.\n\nThe detection works by attempting LU factorization with threshold\npivoting. When a pivot falls below tolerance (ma28_pivtol_), the\ncorresponding row is flagged as linearly dependent.\n\nInput format: Triplet (row, col, val) for general matrices\n\nUsed by Ipopt's constraint degeneracy detection mechanism."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
            "meta": {
              "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa77SolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA77 out-of-core sparse symmetric solver\n\nMa77SolverInterface wraps the HSL MA77 solver, designed for\nlarge-scale problems that may not fit entirely in memory."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
            "meta": {
              "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/TMatrices/IpTripletHelper.hpp",
            "meta": {
              "brief": "Recursive conversion of abstract matrices to triplet format\n\nTripletHelper provides static methods for extracting COO (Coordinate)\nsparse format from Ipopt's abstract Matrix hierarchy. Used to interface\nwith external linear solvers expecting triplet format."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/TMatrices/IpGenTMatrix.hpp",
            "meta": {
              "brief": "General sparse matrix in triplet (COO) format\n\nGenTMatrix stores a general (non-symmetric) sparse matrix using\ntriplet/coordinate format: three arrays for row indices, column\nindices, and values."
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/CSP.hpp",
            "meta": {
              "brief": "Cutting stock problem definitions"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_matrix.hpp",
            "meta": {
              "brief": "Matrix and vector representations for BCP LP relaxation"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP.hpp",
            "meta": {
              "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
            "meta": {
              "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
            "meta": {
              "brief": "Quadratic expression with alpha-convexification"
            }
          },
          {
            "id": "Gravity/include/gravity/func.h",
            "meta": {
              "brief": "Expression functions with automatic differentiation and convexity tracking\n\nThe func class represents mathematical expressions with symbolic analysis."
            }
          },
          {
            "id": "Gravity/include/gravity/model.h",
            "meta": {
              "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkk.h",
            "meta": {
              "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkPrimal.h",
            "meta": {
              "brief": "Phase 2 primal simplex solver for HiGHS"
            }
          },
          {
            "id": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
            "meta": {
              "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
            }
          },
          {
            "id": "SHOT/src/Model/Problem.h",
            "meta": {
              "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
            }
          }
        ]
      }
    },
    "LP_relaxation": {
      "id": "LP_relaxation",
      "name": "LP Relaxation",
      "category": "structure",
      "definition": "Drop integrality constraints from MIP to get an LP. Provides lower bound on MIP optimal value.",
      "intuition": "Allow fractional solutions. Easier to solve; optimal value \u2264 true MIP optimum.",
      "relationships": {
        "requires": [
          {
            "id": "linear_programming"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_ImproveQP.hpp",
            "meta": {
              "brief": "Quadratic programming partition improvement via continuous relaxation\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQP improvement relaxes discrete partition to continuous [0,1] variables,\noptimizes via gradient projection with balance constraints, then rounds\nto discrete partition. Complements FM by exploring continuous solution\nspace; combined in waterdance for best results."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Internal.hpp",
            "meta": {
              "brief": "Internal type definitions and enumerations for Mongoose\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nDefines Int type (int64_t), matching strategies (Random, HEM, HEMSR,\nHEMSRdeg), initial cut types (QP, Random, NaturalOrder), and match\ntypes (Orphan, Standard, Brotherly, Community) used throughout Mongoose."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_GuessCut.hpp",
            "meta": {
              "brief": "Initial partition generation at coarsest level\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nGuessCut creates initial partition for coarsest graph before refinement\nbegins. Strategies include QP relaxation, random assignment, or natural\nvertex order. Quality of initial guess affects final partition quality\ndespite refinement. Selected via initial_cut_type option."
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Waterdance.hpp",
            "meta": {
              "brief": "Alternating FM/QP refinement passes for partition improvement\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nWaterdance alternates between FM (discrete swaps) and QP (continuous\noptimization) refinement passes. The interplay (\"dance\") between methods\nescapes local minima that either method alone would get stuck in.\nNumber of dances controlled by num_dances option."
            }
          },
          {
            "id": "Clp/src/Idiot.hpp",
            "meta": {
              "brief": "Heuristic crash procedure for finding initial LP solutions\n\nThe \"Idiot\" algorithm is a simple heuristic that finds approximate primal\nsolutions quickly. Despite its self-deprecating name (which is copylefted!),\nit serves as an effective \"crash\" procedure to warm-start the simplex method."
            }
          },
          {
            "id": "Osi/src/Osi/OsiChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection strategies for branch-and-bound\n\nIn MIP solving, choosing which variable to branch on significantly\naffects tree size and solve time. This file provides:\n\n- OsiChooseVariable: Base class for branching variable selection\n- OsiChooseStrong: Strong branching (evaluates candidates by solving LPs)"
            }
          },
          {
            "id": "Osi/src/Osi/OsiCut.hpp",
            "meta": {
              "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
            }
          },
          {
            "id": "Cbc/src/CbcLinked.hpp",
            "meta": {
              "brief": "Extended solver for nonlinear and bilinear problems"
            }
          },
          {
            "id": "Cbc/src/CbcModel.hpp",
            "meta": {
              "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
            }
          },
          {
            "id": "Cbc/src/CbcNode.hpp",
            "meta": {
              "brief": "Search tree node for branch-and-cut\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicFPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic (Fischetti, Glover & Lodi)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicRINS.hpp",
            "meta": {
              "brief": "RINS - Relaxation Induced Neighborhood Search (Danna et al.)\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRINS: Implements RINS (Danna, Rothberg & Le Pape, 2005).\nUses LP relaxation to define a neighborhood around the incumbent solution."
            }
          },
          {
            "id": "Cbc/src/CbcCompareEstimate.hpp",
            "meta": {
              "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDive.hpp",
            "meta": {
              "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicRENS.hpp",
            "meta": {
              "brief": "RENS - Relaxation Enforced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRENS: Fixes variables based on LP relaxation solution.\nUnlike RINS (which needs an incumbent), RENS works from LP alone."
            }
          },
          {
            "id": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
            "meta": {
              "brief": "Simplex algorithm for Lift-and-Project cut generation"
            }
          },
          {
            "id": "Bcp/Applications/MaxCut/include/MC_lp.hpp",
            "meta": {
              "brief": "Max-cut LP relaxation for BCP"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_vargen.hpp",
            "meta": {
              "brief": "MKC variable generation (pricing)"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_lp.hpp",
            "meta": {
              "brief": "MKC LP relaxation for BCP"
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/CSP_lp.hpp",
            "meta": {
              "brief": "CSP LP relaxation for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_matrix.hpp",
            "meta": {
              "brief": "Matrix and vector representations for BCP LP relaxation"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_pool.hpp",
            "meta": {
              "brief": "Cut and variable pools for LP process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_main_loop.hpp",
            "meta": {
              "brief": "LP process main loop entry point"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp.hpp",
            "meta": {
              "brief": "LP process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_main_fun.hpp",
            "meta": {
              "brief": "Process entry point functions for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_result.hpp",
            "meta": {
              "brief": "LP solve results for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
            "meta": {
              "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
            "meta": {
              "brief": "Abstract interface for NLP solvers used in branch-and-bound"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
            "meta": {
              "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
            "meta": {
              "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
            "meta": {
              "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
            "meta": {
              "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic for MINLP\n\nImplements the Feasibility Pump algorithm adapted for nonlinear problems.\nAlternates between:\n1. Rounding to nearest integer solution\n2. Projecting back to feasible continuous space via NLP\n\n**Classes:**\n- HeuristicFPump: Main feasibility pump heuristic (CbcHeuristic)\n- RoundingFPump: Helper for intelligent rounding considering constraints"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
            "meta": {
              "brief": "Base class for heuristics using local NLP/MINLP solves"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicDive.hpp",
            "meta": {
              "brief": "Base class for diving heuristics in MINLP"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
            "meta": {
              "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
            "meta": {
              "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonChooseVariable.hpp",
            "meta": {
              "brief": "Strong branching and pseudo-cost based variable selection for MINLP\n\nImplements branching variable selection for nonlinear branch-and-bound.\nCombines strong branching (solving LP/NLP relaxations) with pseudo-costs\n(estimates from historical branching information).\n\n**Key classes:**\n- BonChooseVariable: Main branching decision maker (extends OsiChooseVariable)\n- HotInfo: Stores strong branching results for a candidate\n\n**Branching decision process:**\n1. setupList(): Identify fractional variables, rank by pseudo-costs\n2. doStrongBranching(): Evaluate top candidates via LP/NLP solves\n3. chooseVariable(): Select best candidate based on objective change\n\n**Pseudo-cost computation:**\n- Estimates objective change per unit change in variable value\n- Updated after each branching decision using actual results\n- Used to avoid expensive strong branching after trust is established"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
            "meta": {
              "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
            "meta": {
              "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
            "meta": {
              "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
            "meta": {
              "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
            "meta": {
              "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
            "meta": {
              "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
            }
          },
          {
            "id": "Bonmin/experimental/Separable/BonOuterDescription.hpp",
            "meta": {
              "brief": "Bonmin outer approximation description for convex MINLP\n\nOuter approximation (OA) cut management for MINLP.\nLinearization-based approach for convex MINLP."
            }
          },
          {
            "id": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
            "meta": {
              "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection for branching in global optimization"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneBranchingObject.hpp",
            "meta": {
              "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneObject.hpp",
            "meta": {
              "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneAggrProbing.hpp",
            "meta": {
              "brief": "Aggressive probing for bound tightening\n\nImplements Optimality-Based Bound Tightening (OBBT) through aggressive\nprobing. Temporarily fixes a variable bound and solves the resulting\nsubproblem to determine if a tighter bound is achievable."
            }
          },
          {
            "id": "Couenne/src/problem/CouenneProblem.hpp",
            "meta": {
              "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneFeasPump.hpp",
            "meta": {
              "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
            "meta": {
              "brief": "Iterative rounding heuristic for nonconvex MINLP"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprMul.hpp",
            "meta": {
              "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
            "meta": {
              "brief": "Trilinear product expression w = x*y*z"
            }
          },
          {
            "id": "Couenne/src/cut/crossconv/CouenneCrossConv.hpp",
            "meta": {
              "brief": "Cuts from redundant relationships between auxiliary variables"
            }
          },
          {
            "id": "Couenne/src/cut/sdpcuts/CouenneSdpCuts.hpp",
            "meta": {
              "brief": "SDP-based cutting planes using matrix positive semidefiniteness\n\nGenerates cuts exploiting that product matrices X = (x_ij) where x_ij = x_i*x_j\nmust be positive semidefinite. These cuts strengthen the LP relaxation beyond\nwhat McCormick envelopes provide."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoRC.h",
            "meta": {
              "brief": "Relax-and-Cut algorithm (Lagrangian relaxation with cuts)\n\nDecompAlgoRC implements Lagrangian relaxation:\n- Dualize complicating constraints with multipliers u\n- Solve Lagrangian subproblem: min (c - u'A'')x s.t. A'x >= b'\n- Update multipliers via subgradient optimization\n- Add cuts to improve bounds"
            }
          },
          {
            "id": "Dip/Dip/src/Decomp.h",
            "meta": {
              "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoC.h",
            "meta": {
              "brief": "Cutting Plane Method algorithm (no column generation)\n\nDecompAlgoC implements classic cutting plane method:\n- Solve LP relaxation\n- Find violated cuts\n- Add cuts and resolve\n- Repeat until integer or no cuts found"
            }
          },
          {
            "id": "SYMPHONY/include/sym_lp.h",
            "meta": {
              "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
            }
          },
          {
            "id": "SYMPHONY/include/sym_primal_heuristics.h",
            "meta": {
              "brief": "Primal heuristics for finding feasible solutions\n\nCollection of heuristics to find feasible MIP solutions quickly.\nCalled during B&C to improve incumbent and provide bounds."
            }
          },
          {
            "id": "SYMPHONY/include/symphony.h",
            "meta": {
              "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSearch.h",
            "meta": {
              "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsMipSolver.h",
            "meta": {
              "brief": "Branch-and-cut MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsCutGeneration.h",
            "meta": {
              "brief": "Class that generates cuts from single row relaxations"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparation.h",
            "meta": {
              "brief": "Cut generation orchestration for MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparator.h",
            "meta": {
              "brief": "Abstract base class for cut separators"
            }
          }
        ]
      }
    },
    "convexification": {
      "id": "convexification",
      "name": "Convexification",
      "category": "structure",
      "definition": "Replace nonconvex functions with convex under/over-estimators. Tightest convex relaxation is the convex envelope.",
      "intuition": "Wrap the nonconvex function in a convex \"envelope\". Gives valid bounds for global optimization.",
      "aliases": [
        "convex relaxation",
        "convex envelope"
      ],
      "relationships": {
        "contains": [
          {
            "id": "McCormick_envelopes"
          }
        ],
        "implemented_in": [
          {
            "id": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
            "meta": {
              "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
            }
          },
          {
            "id": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
            "meta": {
              "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
            "meta": {
              "brief": "Three-way spatial branching for continuous variables"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneBranchingObject.hpp",
            "meta": {
              "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneObject.hpp",
            "meta": {
              "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
            "meta": {
              "brief": "Orbital branching object using symmetry"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneSOSObject.hpp",
            "meta": {
              "brief": "Special Ordered Set (SOS) branching for Couenne"
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "Couenne/src/problem/CouenneProblem.hpp",
            "meta": {
              "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprPow.hpp",
            "meta": {
              "brief": "Power expression w = x^k with convexification"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprMul.hpp",
            "meta": {
              "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
            "meta": {
              "brief": "Quadratic expression with alpha-convexification"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
            "meta": {
              "brief": "Trilinear product expression w = x*y*z"
            }
          },
          {
            "id": "Couenne/src/cut/crossconv/CouenneCrossConv.hpp",
            "meta": {
              "brief": "Cuts from redundant relationships between auxiliary variables"
            }
          }
        ]
      }
    },
    "McCormick_envelopes": {
      "id": "McCormick_envelopes",
      "name": "McCormick Envelopes",
      "category": "structure",
      "definition": "Convex and concave envelopes for bilinear terms w = xy over a box. Four linear inequalities that tightly bound the product.",
      "intuition": "The product xy is nonconvex, but on a bounded box we can \"wrap\" it with four planes.",
      "key_equations": [
        "w \u2265 l_x y + x l_y - l_x l_y",
        "w \u2265 u_x y + x u_y - u_x u_y",
        "w \u2264 u_x y + x l_y - u_x l_y",
        "w \u2264 l_x y + x u_y - l_x u_y"
      ],
      "relationships": {
        "requires": [
          {
            "id": "convexification"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/"
          },
          {
            "id": "Cbc/src/CbcLinked.hpp",
            "meta": {
              "brief": "Extended solver for nonlinear and bilinear problems"
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprMul.hpp",
            "meta": {
              "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
            }
          }
        ]
      }
    },
    "basis": {
      "id": "basis",
      "name": "Basis",
      "category": "structure",
      "definition": "Set of m linearly independent columns of A in LP standard form. Basic solution: set non-basic variables to zero, solve for basic variables.",
      "intuition": "A vertex of the polytope corresponds to a basis. Simplex moves between bases.",
      "aliases": [
        "basic solution"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinFactorization.hpp"
          },
          {
            "id": "CoinUtils/src/CoinWarmStart.hpp",
            "meta": {
              "brief": "Abstract interfaces for warm start information in optimization solvers"
            }
          },
          {
            "id": "CoinUtils/src/CoinFactorization.hpp",
            "meta": {
              "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
            }
          },
          {
            "id": "CoinUtils/src/CoinOslFactorization.hpp",
            "meta": {
              "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
            }
          },
          {
            "id": "CoinUtils/src/CoinWarmStartBasis.hpp",
            "meta": {
              "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
            }
          },
          {
            "id": "Clp/src/AbcDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for ABC dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpGubMatrix.hpp",
            "meta": {
              "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplex.hpp",
            "meta": {
              "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
            }
          },
          {
            "id": "Clp/src/ClpNode.hpp",
            "meta": {
              "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/AbcSimplexPrimal.hpp",
            "meta": {
              "brief": "AVX-optimized primal simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpNetworkMatrix.hpp",
            "meta": {
              "brief": "Specialized matrix for pure network LP problems\n\nImplements efficient storage for network flow problems where each column\n(arc) has exactly two nonzeros: +1 at the head node and -1 at the tail node.\nThis representation requires only O(n) storage for row indices vs O(2n) for\na general sparse matrix."
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpPEPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Positive Edge enhanced Dantzig pricing for primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpPEPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Positive Edge enhanced steepest edge for primal simplex"
            }
          },
          {
            "id": "Clp/src/AbcWarmStart.hpp",
            "meta": {
              "brief": "Extended warm start with factorization caching for ABC"
            }
          },
          {
            "id": "Clp/src/ClpDualRowDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/ClpHelperFunctions.hpp",
            "meta": {
              "brief": "BLAS-1 style dense vector operations for Clp"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplexDual.hpp",
            "meta": {
              "brief": "AVX-optimized dual simplex algorithm"
            }
          },
          {
            "id": "Clp/src/AbcPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for ABC primal simplex pivot selection"
            }
          },
          {
            "id": "Clp/src/ClpSimplexOther.hpp",
            "meta": {
              "brief": "Auxiliary simplex operations: ranging, parametrics, and utilities"
            }
          },
          {
            "id": "Clp/src/ClpSimplexNonlinear.hpp",
            "meta": {
              "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
            }
          },
          {
            "id": "Clp/src/ClpNetworkBasis.hpp",
            "meta": {
              "brief": "Specialized factorization for pure network problems"
            }
          },
          {
            "id": "Clp/src/ClpModel.hpp",
            "meta": {
              "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnPivot.hpp",
            "meta": {
              "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
            }
          },
          {
            "id": "Clp/src/ClpDualRowPivot.hpp",
            "meta": {
              "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/CoinAbcDenseFactorization.hpp",
            "meta": {
              "brief": "Abstract base class for ABC factorization and dense submatrix handling"
            }
          },
          {
            "id": "Clp/src/ClpPEDualRowDantzig.hpp",
            "meta": {
              "brief": "Positive Edge enhanced Dantzig pricing for dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpGubDynamicMatrix.hpp",
            "meta": {
              "brief": "Dynamic column generation with Generalized Upper Bound structure\n\nCombines GUB constraints with dynamic column generation. Columns are\npartitioned into GUB sets where at most one column per set can be basic."
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
            }
          },
          {
            "id": "Clp/src/Clp_C_Interface.h",
            "meta": {
              "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/adtl.h",
            "meta": {
              "brief": "Tape-less (traceless) forward-mode automatic differentiation\n\nProvides the adtl::adouble class for direct forward-mode AD without\ntape recording. Each adouble carries both its value and directional\nderivatives, which are propagated immediately through operations."
            }
          },
          {
            "id": "Cbc/src/CbcNodeInfo.hpp",
            "meta": {
              "brief": "Persistent information for recreating search tree nodes"
            }
          },
          {
            "id": "Cbc/src/CbcPartialNodeInfo.hpp",
            "meta": {
              "brief": "Incremental subproblem storage as differences from parent"
            }
          },
          {
            "id": "Cbc/src/CbcSubProblem.hpp",
            "meta": {
              "brief": "Compact subproblem state for diving heuristics"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicPivotAndFix.hpp",
            "meta": {
              "brief": "Pivot and Fix heuristic using simplex pivots\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicPivotAndFix: Exploits LP basis structure.\nPerforms simplex pivots to explore nearby basic solutions,\nthen fixes integer variables at their current values."
            }
          },
          {
            "id": "Cbc/src/CbcFullNodeInfo.hpp",
            "meta": {
              "brief": "Complete subproblem state storage (typically for root node)"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Cgl/src/CglCommon/CglCutGenerator.hpp",
            "meta": {
              "brief": "Abstract base class for all CGL cutting plane generators\n\nDefines the interface that all cut generators must implement. In MIP\nbranch-and-cut, cutting planes tighten the LP relaxation to cut off\nfractional solutions while keeping all integer-feasible points."
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart_basis.hpp",
            "meta": {
              "brief": "BCP warm start basis implementation"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_functions.hpp",
            "meta": {
              "brief": "Warmstart serialization utilities"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
            "meta": {
              "brief": "LP warm start information for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
            "meta": {
              "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
            }
          },
          {
            "id": "Dip/Dip/src/DecompVar.h",
            "meta": {
              "brief": "Column generation variable (lambda) representation\n\nDecompVar represents a column in the Dantzig-Wolfe reformulation.\nEach lambda_s corresponds to an extreme point s of a subproblem\npolyhedron: conv{x : A'x >= b', x integer}."
            }
          },
          {
            "id": "SYMPHONY/include/sym_tm.h",
            "meta": {
              "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
            "meta": {
              "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/basis.hpp",
            "meta": {
              "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkDual.h",
            "meta": {
              "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSearch.h",
            "meta": {
              "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparation.h",
            "meta": {
              "brief": "Cut generation orchestration for MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparator.h",
            "meta": {
              "brief": "Abstract base class for cut separators"
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/crossover.h",
            "meta": {
              "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
            "meta": {
              "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
            }
          }
        ]
      }
    },
    "LU_factorization": {
      "id": "LU_factorization",
      "name": "LU Factorization",
      "category": "technique",
      "definition": "Decompose matrix A = LU where L is lower triangular, U is upper triangular. Enables efficient solving of Ax = b via forward/back substitution.",
      "intuition": "Break matrix into triangular pieces. Solving triangular systems is O(n\u00b2) not O(n\u00b3).",
      "aliases": [
        "LU decomposition"
      ],
      "key_equations": [
        "A = LU",
        "Solve Ly = b, then Ux = y"
      ],
      "relationships": {
        "requires": [
          {
            "id": "sparsity"
          }
        ],
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinFactorization.hpp"
          },
          {
            "id": "CoinUtils/src/CoinSimpFactorization.hpp",
            "meta": {
              "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
            }
          },
          {
            "id": "CoinUtils/src/CoinFactorization.hpp",
            "meta": {
              "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
            }
          },
          {
            "id": "CoinUtils/src/CoinOslFactorization.hpp",
            "meta": {
              "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
            }
          },
          {
            "id": "CoinUtils/src/CoinDenseFactorization.hpp",
            "meta": {
              "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
            }
          },
          {
            "id": "SuiteSparse/SPQR/Include/SuiteSparseQR.hpp",
            "meta": {
              "brief": "User C++ API for sparse multifrontal QR factorization\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nMain user interface for SPQR: SuiteSparseQR overloads for [Q,R,E]=qr(A),\nX=A\\B, qmult. Structures: spqr_symbolic (pattern analysis), spqr_numeric\n(R values, Householder H), spqr_gpu (GPU staging). Expert functions:\nSuiteSparseQR_factorize, _solve, _min2norm, _symbolic, _numeric for\nfactorization reuse. Supports real/complex, int32/int64."
            }
          },
          {
            "id": "SuiteSparse/SPQR/Include/spqr.hpp",
            "meta": {
              "brief": "Internal SPQR implementation functions and data structures\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nNon-user-callable routines: spqr_analyze (symbolic), spqr_factorize (numeric),\nspqr_kernel (parallel front factorization), spqr_assemble/cpack/rhpack (front\nassembly). Support: spqr_tol, stranspose1/2, larftb (block reflectors),\nhapply, panel, 1colamd, 1fixed. Helper structs: spqr_work, spqr_blob.\nMacros: FLIP/UNFLIP for marking, INDEX for column-major."
            }
          },
          {
            "id": "SuiteSparse/ParU/Source/paru_internal.hpp",
            "meta": {
              "brief": "Internal data structures and functions for ParU sparse LU\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis.\nGPL-3.0-or-later license.\n\nCore ParU structures: ParU_Symbolic_struct (row-form S, singletons, fronts,\ntask tree), ParU_Numeric_struct (LU factors, permutations, scaling),\nParU_Control_struct (tolerances, threading). paru_element (contribution\nblock), paru_work (workspace), paru_tuple (element lists). Internal\nfunctions: front assembly/factorization, heap management, BLAS threading.\nIncludes UMFPACK SymbolicType/SWType for singleton detection."
            }
          },
          {
            "id": "SuiteSparse/CSparse/Include/cs.h",
            "meta": {
              "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
            }
          },
          {
            "id": "SuiteSparse/UMFPACK/Include/umfpack.h",
            "meta": {
              "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
            }
          },
          {
            "id": "SuiteSparse/UMFPACK/Source/umf_internal.h",
            "meta": {
              "brief": "Internal definitions for UMFPACK sparse LU factorization\nCopyright (c) 2005-2023, Timothy A. Davis. GPL-2.0+ license.\n\nUMFPACK is an unsymmetric multifrontal sparse LU factorization package.\nComputes P\u00b7A\u00b7Q = L\u00b7U via supernodal factorization with partial pivoting.\nHandles real and complex matrices in single and double precision."
            }
          },
          {
            "id": "SuiteSparse/KLU/Include/klu_internal.h",
            "meta": {
              "brief": "Internal definitions for KLU sparse LU factorization\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nKLU is a sparse LU factorization package designed for circuit simulation\nmatrices, which are typically highly sparse with near-diagonal structure.\nUses BTF (Block Triangular Form) permutation to exploit structure."
            }
          },
          {
            "id": "SuiteSparse/CHOLMOD/Include/cholmod_internal.h",
            "meta": {
              "brief": "Internal definitions for CHOLMOD sparse Cholesky factorization\nCopyright (C) 2005-2023, Timothy A. Davis. Apache-2.0 license.\n\nCHOLMOD is a comprehensive sparse Cholesky factorization package supporting\nsupernodal and simplicial methods, update/downdate, and multiple orderings.\nHandles symmetric positive definite systems A\u00b7x = b via L\u00b7L' = A."
            }
          },
          {
            "id": "SuiteSparse/LDL/Include/ldl.h",
            "meta": {
              "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
            }
          },
          {
            "id": "SuiteSparse/ParU/Include/ParU.h",
            "meta": {
              "brief": "Parallel unsymmetric multifrontal sparse LU factorization\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis. GPL-3.0-or-later.\n\nParU is a parallel sparse direct solver using OpenMP tasking for task-based\nparallelism combined with parallel BLAS (nested parallelism). Solves Ax = b\nfor sparse A via LU factorization with partial pivoting."
            }
          },
          {
            "id": "Clp/src/AbcDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for ABC dual simplex"
            }
          },
          {
            "id": "Clp/src/ClpGubMatrix.hpp",
            "meta": {
              "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
            }
          },
          {
            "id": "Clp/src/ClpLsqr.hpp",
            "meta": {
              "brief": "LSQR iterative solver for sparse least-squares problems\n\nImplements the LSQR algorithm of Paige and Saunders (1982) for solving:\n- Ax = b (exact solve)\n- min ||b - Ax||_2 (least squares)\n- min ||(b) - (A    )x||_2 (damped/regularized)\n      ||(0)   (damp*I)  ||"
            }
          },
          {
            "id": "Clp/src/ClpSimplexDual.hpp",
            "meta": {
              "brief": "Dual simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyPardiso.hpp",
            "meta": {
              "brief": "Intel MKL Pardiso sparse direct solver for Cholesky factorization\n\nWraps Intel's Pardiso solver from the Math Kernel Library (MKL) for\nCholesky factorization of normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/AbcSimplex.hpp",
            "meta": {
              "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
            }
          },
          {
            "id": "Clp/src/ClpNode.hpp",
            "meta": {
              "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
            }
          },
          {
            "id": "Clp/src/AbcMatrix.hpp",
            "meta": {
              "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyUfl.hpp",
            "meta": {
              "brief": "SuiteSparse CHOLMOD interface for Cholesky factorization\n\nWraps the CHOLMOD library from SuiteSparse (University of Florida) for\nCholesky factorization of normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/ClpDualRowSteepest.hpp",
            "meta": {
              "brief": "Steepest edge pivot selection for dual simplex"
            }
          },
          {
            "id": "Clp/src/AbcSimplexPrimal.hpp",
            "meta": {
              "brief": "AVX-optimized primal simplex algorithm"
            }
          },
          {
            "id": "Clp/src/ClpFactorization.hpp",
            "meta": {
              "brief": "Wrapper around CoinFactorization for use within Clp simplex"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex pivot selection for primal simplex"
            }
          },
          {
            "id": "Clp/src/AbcWarmStart.hpp",
            "meta": {
              "brief": "Extended warm start with factorization caching for ABC"
            }
          },
          {
            "id": "Clp/src/ClpInterior.hpp",
            "meta": {
              "brief": "Interior point (barrier) method for LP"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyDense.hpp",
            "meta": {
              "brief": "Dense Cholesky factorization for interior point methods\n\nImplements Cholesky factorization when A*D*A' becomes effectively dense.\nUses blocked recursive algorithms for cache efficiency and supports\nparallel execution via ClpCholeskySpawn."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyTaucs.hpp",
            "meta": {
              "brief": "TAUCS sparse solver interface for Cholesky factorization\n\nWraps Sivan Toledo's TAUCS library for Cholesky factorization of normal\nequations in interior point methods."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyWssmpKKT.hpp",
            "meta": {
              "brief": "WSSMP solver for KKT system (augmented system) formulation\n\nVariant of ClpCholeskyWssmp that solves the KKT/augmented system directly\ninstead of forming and factoring the normal equations A*D*A'."
            }
          },
          {
            "id": "Clp/src/ClpCholeskyMumps.hpp",
            "meta": {
              "brief": "MUMPS sparse direct solver interface for Cholesky factorization\n\nWraps the MUMPS (MUltifrontal Massively Parallel sparse direct Solver)\nlibrary for Cholesky factorization of normal equations in interior point."
            }
          },
          {
            "id": "Clp/src/ClpHelperFunctions.hpp",
            "meta": {
              "brief": "BLAS-1 style dense vector operations for Clp"
            }
          },
          {
            "id": "Clp/src/ClpSimplexPrimal.hpp",
            "meta": {
              "brief": "Primal simplex algorithm implementation"
            }
          },
          {
            "id": "Clp/src/AbcSimplexDual.hpp",
            "meta": {
              "brief": "AVX-optimized dual simplex algorithm"
            }
          },
          {
            "id": "Clp/src/AbcPrimalColumnSteepest.hpp",
            "meta": {
              "brief": "Steepest edge and Devex for ABC primal simplex"
            }
          },
          {
            "id": "Clp/src/ClpSimplexNonlinear.hpp",
            "meta": {
              "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
            }
          },
          {
            "id": "Clp/src/ClpNetworkBasis.hpp",
            "meta": {
              "brief": "Specialized factorization for pure network problems"
            }
          },
          {
            "id": "Clp/src/AbcSimplexFactorization.hpp",
            "meta": {
              "brief": "LU factorization wrapper for ABC simplex"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyBase.hpp",
            "meta": {
              "brief": "Cholesky factorization base class for interior point methods\n\nProvides Cholesky factorization of the normal equations matrix A*D*A'\nused in predictor-corrector interior point methods. The factorization\nuses AMD ordering to reduce fill-in.\n\nThe base class provides a simple sparse Cholesky implementation with\nsupernodal dense blocks. Derived classes can interface to more\nsophisticated factorizations (MUMPS, Pardiso, TAUCS, etc.).\n\nKey methods:\n- order(): Compute fill-reducing ordering (AMD by default)\n- symbolic(): Set up sparsity structure of factor\n- factorize(): Numeric factorization of A*D*A'\n- solve(): Solve system using computed factors"
            }
          },
          {
            "id": "Clp/src/ClpCholeskyWssmp.hpp",
            "meta": {
              "brief": "WSSMP sparse direct solver interface for Cholesky factorization\n\nWraps IBM's Watson Sparse Matrix Package (WSSMP) for Cholesky factorization\nof normal equations in interior point methods."
            }
          },
          {
            "id": "Clp/src/CoinAbcFactorization.hpp",
            "meta": {
              "brief": "ABC optimized LU factorization variants"
            }
          },
          {
            "id": "Clp/src/AbcPrimalColumnPivot.hpp",
            "meta": {
              "brief": "Abstract base class for primal pivot column selection in ABC"
            }
          },
          {
            "id": "Clp/src/CoinAbcBaseFactorization.hpp",
            "meta": {
              "brief": "Core ABC SIMD-optimized LU factorization implementation"
            }
          },
          {
            "id": "Clp/src/CoinAbcCommonFactorization.hpp",
            "meta": {
              "brief": "Common infrastructure for ABC SIMD-optimized factorization"
            }
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SparseSolver.hpp",
            "meta": {
              "brief": "Sparse linear solver interfaces for Schur-complement QP method"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
            "meta": {
              "brief": "Sparse QP solver using Schur complement for active-set updates"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblem.hpp",
            "meta": {
              "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Flipper.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "qpOASES/include/qpOASES/LapackBlasReplacement.hpp",
            "meta": {
              "brief": "LAPACK/BLAS interface declarations for qpOASES linear algebra"
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpIpoptApplication.hpp",
            "meta": {
              "brief": "Main application class for calling Ipopt from C++\n\nIpoptApplication is the entry point for C++ applications using Ipopt.\nProvides methods for initialization, option handling, and solving."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpGenAugSystemSolver.hpp",
            "meta": {
              "brief": "Augmented system solver using GenKKTSolverInterface\n\nGenAugSystemSolver adapts the AugSystemSolver interface to use\nGenKKTSolverInterface, which provides a more generic linear solver\ninterface supporting iterative methods.\n\nThis class:\n- Extracts raw Number* arrays from Vector objects\n- Passes Matrix objects directly from the NLP\n- Manages caching to avoid redundant matrix updates\n\nMultiSolve() implementation:\n1. Check if augmented system matrices have changed (via tags)\n2. If changed, update solver_interface_ with new matrices\n3. Extract RHS vectors to raw arrays\n4. Call solver_interface_->Solve()\n5. Copy solutions back to Vector objects\n\nTag-based caching tracks:\n- W matrix and W_factor\n- Diagonal matrices D_x, D_s, D_c, D_d\n- Jacobians J_c, J_d\n- Regularization deltas\n\nInertia and quality:\n- NumberOfNegEVals(): Query solver for eigenvalue count\n- ProvidesInertia(): Check if solver supports this\n- IncreaseQuality(): Request better pivoting/tolerance"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLowRankSSAugSystemSolver.hpp",
            "meta": {
              "brief": "Low-rank Hessian handling via single backsolve (iterative solver friendly)\n\nLowRankSSAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS) by augmenting the system rather than using\nSherman-Morrison. This requires only ONE factorization/backsolve."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAugRestoSystemSolver.hpp",
            "meta": {
              "brief": "Augmented system solver exploiting restoration phase structure\n\nAugRestoSystemSolver is a decorator that exploits the known structure\nof the restoration phase problem to reduce the augmented system to\nthe original problem size."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAugSystemSolver.hpp",
            "meta": {
              "brief": "Abstract interface for solving the 4x4 augmented KKT system\n\nAugSystemSolver defines the interface for solving the reduced\naugmented system obtained by eliminating bound multiplier equations:\n\n  [W + Dx + \u03b4x*I      0        Jc^T      Jd^T  ] [sol_x]   [rhs_x]\n  [    0         Ds + \u03b4s*I     0         -I   ] [sol_s] = [rhs_s]\n  [   Jc             0      Dc - \u03b4c*I    0    ] [sol_c]   [rhs_c]\n  [   Jd            -I         0      Dd - \u03b4d*I] [sol_d]   [rhs_d]"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
            "meta": {
              "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
            "meta": {
              "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpTimingStatistics.hpp",
            "meta": {
              "brief": "Collection of timing statistics for algorithm profiling\n\nTimingStatistics aggregates TimedTask objects for all major\nalgorithm components, enabling performance profiling and\nbottleneck identification.\n\nTiming categories:\n- Algorithm phases: InitializeIterates, UpdateHessian, OutputIteration,\n  UpdateBarrierParameter, ComputeSearchDirection, etc.\n- Linear system: PDSystemSolverTotal, LinearSystemFactorization,\n  LinearSystemBackSolve, LinearSystemScaling\n- NLP evaluations: f_eval_time, grad_f_eval_time, c_eval_time,\n  jac_c_eval_time, d_eval_time, jac_d_eval_time, h_eval_time\n- Auxiliary: Task1-Task6 for ad-hoc profiling\n\nKey methods:\n- ResetTimes(): Clear all accumulated times\n- EnableTimes()/DisableTimes(): Control timing overhead\n- PrintAllTimingStatistics(): Output formatted timing report\n- TotalFunctionEvaluationCpuTime(): Sum of NLP evaluation times\n\nEach TimedTask tracks CPU time, system time, and wall-clock time."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
            "meta": {
              "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpDenseGenMatrix.hpp",
            "meta": {
              "brief": "Dense general (non-symmetric) matrix with linear algebra operations\n\nDenseGenMatrix stores elements in column-major (Fortran) format\nand provides direct factorization capabilities:\n- Cholesky factorization (for positive definite matrices)\n- LU factorization with pivoting (for general matrices)\n- Forward/back substitution solves"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpLapack.hpp",
            "meta": {
              "brief": "C++ wrappers for LAPACK (Linear Algebra PACKage) routines\n\nProvides platform-independent access to LAPACK for dense matrices."
            }
          },
          {
            "id": "Ipopt/src/contrib/CGPenalty/IpCGPerturbationHandler.hpp",
            "meta": {
              "brief": "Perturbation handler for Chen-Goldfarb penalty method"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactAlgBuilder.hpp",
            "meta": {
              "brief": "Builder for inexact step computation algorithm variant\n\nInexactAlgorithmBuilder constructs the complete IpoptAlgorithm\nconfigured for inexact Newton methods using iterative linear solvers."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
            "meta": {
              "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoMKLSolverInterface.hpp",
            "meta": {
              "brief": "Interface to Intel MKL PARDISO sparse solver\n\nPardisoMKLSolverInterface wraps Intel's MKL implementation of PARDISO.\nWhile sharing the same API as pardiso-project.org's version, Intel MKL\nPARDISO has some differences in features and behavior."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTSymLinearSolver.hpp",
            "meta": {
              "brief": "Driver connecting SymMatrix to sparse linear solver interfaces\n\nTSymLinearSolver is the main driver that connects Ipopt's SymMatrix\nobjects to concrete sparse linear solvers. It handles:\n- Matrix format conversion (SymMatrix to triplet/CSR)\n- Optional matrix scaling\n- Delegation to SparseSymLinearSolverInterface implementations"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMc19TSymScalingMethod.hpp",
            "meta": {
              "brief": "Matrix scaling using HSL MC19 equilibration\n\nMc19TSymScalingMethod uses the HSL subroutine MC19 to compute\nequilibration scaling factors for symmetric matrices."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpWsmpSolverInterface.hpp",
            "meta": {
              "brief": "Interface to IBM WSMP sparse symmetric direct solver\n\nWsmpSolverInterface wraps the Watson Sparse Matrix Package (WSMP),\na high-performance parallel direct solver developed at IBM for\nsparse symmetric indefinite linear systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMumpsSolverInterface.hpp",
            "meta": {
              "brief": "Interface to MUMPS parallel sparse direct solver\n\nMumpsSolverInterface wraps MUMPS (MUltifrontal Massively Parallel\nsparse direct Solver), a freely available solver supporting MPI\nparallelism for distributed memory systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSpralSolverInterface.hpp",
            "meta": {
              "brief": "Interface to SPRAL SSIDS sparse symmetric solver\n\nSpralSolverInterface wraps SPRAL (Sparse Parallel Robust Algorithms\nLibrary), an open-source alternative to HSL solvers developed by\nSTFC RAL. SSIDS is SPRAL's symmetric indefinite direct solver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa28TDependencyDetector.hpp",
            "meta": {
              "brief": "Dependency detector using HSL MA28 unsymmetric solver\n\nMa28TDependencyDetector uses the unsymmetric sparse solver MA28\nto detect linearly dependent rows in the constraint Jacobian.\nUnlike the symmetric solvers, MA28 handles general rectangular\nmatrices, making it suitable for analyzing the constraint Jacobian\ndirectly.\n\nThe detection works by attempting LU factorization with threshold\npivoting. When a pivot falls below tolerance (ma28_pivtol_), the\ncorresponding row is flagged as linearly dependent.\n\nInput format: Triplet (row, col, val) for general matrices\n\nUsed by Ipopt's constraint degeneracy detection mechanism."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTSymDependencyDetector.hpp",
            "meta": {
              "brief": "Dependency detection using symmetric linear solver\n\nTSymDependencyDetector detects linearly dependent constraint rows\nby using a TSymLinearSolver that provides degeneracy detection.\n\nMethod:\nSome symmetric linear solvers (e.g., MA57 via ProvidesDegeneracyDetection)\ncan identify dependent rows during factorization. This class\nleverages that capability.\n\nAlgorithm:\n1. Form symmetric matrix J*J^T (or equivalent structure)\n2. Attempt factorization with the TSymLinearSolver\n3. If solver detects singularity, query dependent row indices\n4. Return list of dependent rows in c_deps\n\nRequirements:\n- The underlying linear solver must implement\n  ProvidesDegeneracyDetection() returning true\n- Must implement DetermineDependentRows() for the sparse format\n\nThis is preferred over MA28-based detection when using a solver\nthat already provides this capability."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
            "meta": {
              "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
            "meta": {
              "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa57TSolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA57 sparse symmetric indefinite solver\n\nMa57TSolverInterface wraps the Harwell MA57 subroutine, an improved\nmultifrontal solver over MA27 with better memory management and\nnumerical stability."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpIterativeWsmpSolverInterface.hpp",
            "meta": {
              "brief": "Interface to IBM WSMP iterative (WISMP) solver\n\nIterativeWsmpSolverInterface wraps the iterative variant of WSMP\n(called WISMP), which uses incomplete LU factorization as a\npreconditioner for iterative refinement."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoSolverInterface.hpp",
            "meta": {
              "brief": "Interface to PARDISO sparse solver from pardiso-project.org\n\nPardisoSolverInterface wraps the PARDISO solver distributed by\npardiso-project.org (not to be confused with Intel MKL's PARDISO).\nPARDISO is a high-performance parallel direct solver for sparse\nsymmetric indefinite systems."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa77SolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA77 out-of-core sparse symmetric solver\n\nMa77SolverInterface wraps the HSL MA77 solver, designed for\nlarge-scale problems that may not fit entirely in memory."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
            "meta": {
              "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpMa27TSolverInterface.hpp",
            "meta": {
              "brief": "Interface to HSL MA27 sparse symmetric indefinite solver\n\nMa27TSolverInterface wraps the Harwell MA27 subroutine for solving\nsparse symmetric indefinite linear systems using multifrontal\nfactorization with threshold pivoting."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
            "meta": {
              "brief": "Abstract base class for strong branching NLP solves"
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/factor.hpp",
            "meta": {
              "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/a_quass.hpp",
            "meta": {
              "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/basis.hpp",
            "meta": {
              "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkk.h",
            "meta": {
              "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
            }
          },
          {
            "id": "HiGHS/highs/simplex/HEkkDual.h",
            "meta": {
              "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/forrest_tomlin.h",
            "meta": {
              "brief": "Forrest-Tomlin LU Update for Basis Maintenance\n\nImplements the Forrest-Tomlin update to maintain LU factorization when\na single column of the basis matrix changes (basis exchange/pivot)."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/crossover.h",
            "meta": {
              "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/kkt_solver.h",
            "meta": {
              "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
            "meta": {
              "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
            }
          }
        ]
      }
    },
    "presolve": {
      "id": "presolve",
      "name": "Presolve",
      "category": "technique",
      "definition": "Simplify problem before solving: remove redundant constraints, fix variables, tighten bounds, detect infeasibility.",
      "intuition": "Clean up the problem first. Often dramatically reduces size and improves conditioning.",
      "aliases": [
        "preprocessing"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinPresolveMatrix.hpp"
          },
          {
            "id": "Clp/src/ClpPresolve.hpp"
          },
          {
            "id": "CoinUtils/src/CoinPresolveZeros.hpp",
            "meta": {
              "brief": "Drop and reintroduce explicit zero coefficients"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveMatrix.hpp",
            "meta": {
              "brief": "Core presolve data structures and action base class\n\nDefines CoinPrePostsolveMatrix (common base), CoinPresolveMatrix (for\npresolve), CoinPostsolveMatrix (for postsolve), and CoinPresolveAction\n(base class for all presolve transformations)."
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveUseless.hpp",
            "meta": {
              "brief": "Remove useless (redundant) constraints"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveForcing.hpp",
            "meta": {
              "brief": "Forcing and useless constraint detection"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveImpliedFree.hpp",
            "meta": {
              "brief": "Detect and process implied free variables"
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveTighten.hpp",
            "meta": {
              "brief": "Tighten variable bounds using constraint propagation"
            }
          },
          {
            "id": "CoinUtils/src/CoinStaticConflictGraph.hpp",
            "meta": {
              "brief": "static CoinConflictGraph implementation with fast queries"
            }
          },
          {
            "id": "SuiteSparse/Mongoose/Include/Mongoose_Sanitize.hpp",
            "meta": {
              "brief": "Matrix preprocessing for graph partitioning\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nMatrix sanitization prepares input for partitioning: sanitizeMatrix\nhandles symmetry and binary weights, removeDiagonal strips self-loops,\nmirrorTriangular expands triangular to symmetric. Ensures valid\nundirected graph representation for algorithms."
            }
          },
          {
            "id": "SuiteSparse/KLU/Include/klu.h",
            "meta": {
              "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
            }
          },
          {
            "id": "Clp/src/ClpSolve.hpp",
            "meta": {
              "brief": "Algorithm selection and configuration for ClpSimplex::initialSolve()"
            }
          },
          {
            "id": "Clp/src/ClpPresolve.hpp",
            "meta": {
              "brief": "Clp interface to CoinPresolve for LP preprocessing"
            }
          },
          {
            "id": "Osi/src/Osi/OsiPresolve.hpp",
            "meta": {
              "brief": "OSI interface to problem simplification (presolve)\n\nPresolve reduces problem size before solving by applying\ntransformations that preserve optimal solutions:\n- Singleton row/column removal\n- Bound tightening\n- Coefficient reduction\n- Duplicate row/column detection"
            }
          },
          {
            "id": "Osi/src/Osi/OsiColCut.hpp",
            "meta": {
              "brief": "Column-based cuts for variable bound tightening\n\nColumn cuts represent bound changes on variables rather than\nadding new constraints. They are used for:\n- Bound tightening from probing\n- Implication-based bound strengthening\n- Reduced cost fixing"
            }
          },
          {
            "id": "Cbc/src/CbcConsequence.hpp",
            "meta": {
              "brief": "Abstract base for bound implications from branching"
            }
          },
          {
            "id": "Cbc/src/CbcFathom.hpp",
            "meta": {
              "brief": "Fathoming methods to complete subproblems"
            }
          },
          {
            "id": "Cbc/src/CbcSolverHeuristics.hpp",
            "meta": {
              "brief": "Heuristic setup and execution routines for cbc-generic"
            }
          },
          {
            "id": "Cbc/src/CbcParameters.hpp",
            "meta": {
              "brief": "Central parameter collection for Cbc algorithm control\nCopyright (C) 2007, Lou Hafer, IBM Corporation and others.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcParameters: Master class holding all Cbc solver parameters.\nUsed by cbc-generic to configure and control the MIP solver.\n\nMajor subsystems configured:\n- Cut generators: Gomory, MIR, Probing, Clique, FlowCover, etc.\n- Heuristics: FPump, RINS, RENS, DINS, Diving variants, VND, etc.\n- Search strategy: Node selection, preprocessing, orbital branching\n- Limits: Time, nodes, gap tolerance, solution count\n\nIncludes instances of CGL cut generators and Cbc heuristics.\nLinks to ClpParameters for underlying LP solver control.\n\nKey methods:\n- init(): Initialize with strategy preset\n- setModel(): Associate with CbcModel\n- Various getters/setters for each parameter category\n\nStrategy presets provide common configurations:\n- Default aggressive cutting at root\n- Balanced cut/heuristic emphasis\n- Heuristic-focused for quick solutions"
            }
          },
          {
            "id": "Cbc/src/CbcStrategy.hpp",
            "meta": {
              "brief": "Strategy pattern for configuring CbcModel components"
            }
          },
          {
            "id": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
            "meta": {
              "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
            }
          },
          {
            "id": "Cgl/src/CglProbing/CglProbing.hpp",
            "meta": {
              "brief": "Probing cut generator - variable fixing and implications\n\nProbing systematically tests setting integer variables to bounds,\npropagating implications to derive:\n- Variable fixings (column cuts)\n- Bound tightenings\n- Disaggregation cuts (row cuts)\n- Coefficient strengthening\n- Clique structures\n\nProbing outcomes when testing x_j = 0 vs x_j = 1:\n1. One direction infeasible \u2192 fix variable (column cut)\n2. Both infeasible \u2192 problem infeasible\n3. Both feasible, y fixed same way \u2192 y can be fixed\n4. Both feasible, y fixed opposite \u2192 can substitute y = 1-x_j\n5. Constraint went slack by c \u2192 strengthen coefficient\n\nKey structures:\n- disaggregationAction: What gets fixed when probing a variable\n- cutVector_: Stores implications for each integer\n- Clique arrays: oneFixStart_, zeroFixStart_ for clique membership\n\nModes:\n- mode_ 0: Only unsatisfied integers, use snapshot (fast, global)\n- mode_ 1: Unsatisfied integers with current bounds\n- mode_ 2: All integers with current bounds\n\nCglImplication (separate class):\n- Generates cuts directly from stored implication info\n- Uses CglTreeProbingInfo built during probing"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpProbingMuOracle.hpp",
            "meta": {
              "brief": "Mehrotra's probing heuristic for barrier parameter selection\n\nProbingMuOracle implements Mehrotra's predictor-corrector approach\nto compute the barrier parameter mu. This is the strategy used in\nmany interior point codes like LOQO and PCx.\n\nAlgorithm:\n1. Compute affine scaling direction (predictor step) with sigma=0\n2. Find maximum step to boundary (alpha_aff)\n3. Compute complementarity after affine step: mu_aff\n4. Compute centering parameter: sigma = (mu_aff/mu)^3\n5. Use sigma in corrector step\n\nThe centering parameter sigma controls the balance between:\n- sigma=0: Pure affine scaling (aggressive, may overshoot)\n- sigma=1: Pure centering (conservative, slow progress)\n\nKey parameter:\n- sigma_max_: Upper bound on sigma to prevent excessive centering"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMuOracle.hpp",
            "meta": {
              "brief": "Strategy interface for suggesting barrier parameter values\n\nMuOracle is the abstract interface for components that compute\nsuggested values for the barrier parameter mu in adaptive (non-monotone)\nbarrier updates."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpMuUpdate.hpp",
            "meta": {
              "brief": "Strategy interface for updating barrier parameter mu\n\nMuUpdate is the abstract base for strategies that determine the\nbarrier parameter mu and fraction-to-boundary parameter tau for\neach iteration of the interior point method."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
            "meta": {
              "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoSolverInterface.hpp",
            "meta": {
              "brief": "Interface to PARDISO sparse solver from pardiso-project.org\n\nPardisoSolverInterface wraps the PARDISO solver distributed by\npardiso-project.org (not to be confused with Intel MKL's PARDISO).\nPARDISO is a high-performance parallel direct solver for sparse\nsymmetric indefinite systems."
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_param.hpp",
            "meta": {
              "brief": "LP process parameters for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_enum_branch.hpp",
            "meta": {
              "brief": "Branching-related enumerations for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_branch.hpp",
            "meta": {
              "brief": "LP-side branching objects for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
            "meta": {
              "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
            "meta": {
              "brief": "Fixpoint-based bound tightening via constraint propagation\n\nImplements Feasibility-Based Bound Tightening (FBBT) using fixpoint\niteration. Propagates bounds through expression DAG until no further\ntightening is possible."
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneMultiVarProbe.hpp",
            "meta": {
              "brief": "Multi-variable probing for bound tightening"
            }
          },
          {
            "id": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
            "meta": {
              "brief": "Trilinear product expression w = x*y*z"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
            "meta": {
              "brief": "Bound tightening from pairs of linear constraints"
            }
          },
          {
            "id": "SYMPHONY/include/sym_prep.h",
            "meta": {
              "brief": "MIP preprocessing (presolve) for SYMPHONY\n\nPreprocessing reduces problem size before B&C by fixing variables,\nremoving redundant constraints, and tightening bounds."
            }
          },
          {
            "id": "SYMPHONY/include/sym_master.h",
            "meta": {
              "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsMipSolver.h",
            "meta": {
              "brief": "Branch-and-cut MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparation.h",
            "meta": {
              "brief": "Cut generation orchestration for MIP solver"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSeparator.h",
            "meta": {
              "brief": "Abstract base class for cut separators"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsImplications.h",
            "meta": {
              "brief": "Implication graphs and variable bound relationships for MIP"
            }
          },
          {
            "id": "HiGHS/highs/ipm/ipx/iterate.h",
            "meta": {
              "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
            }
          }
        ]
      }
    },
    "warm_start": {
      "id": "warm_start",
      "name": "Warm Start",
      "category": "technique",
      "definition": "Initialize solver with information from a previous solve (basis, solution, bounds). Reduces iterations needed for similar problems.",
      "intuition": "Don't start from scratch. Use the old answer as a starting point for the modified problem.",
      "aliases": [
        "hot start"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinWarmStart.hpp"
          },
          {
            "id": "Clp/src/ClpSimplex.hpp"
          },
          {
            "id": "CoinUtils/src/CoinWarmStart.hpp",
            "meta": {
              "brief": "Abstract interfaces for warm start information in optimization solvers"
            }
          },
          {
            "id": "CoinUtils/src/CoinWarmStartBasis.hpp",
            "meta": {
              "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
            }
          },
          {
            "id": "Clp/src/AbcWarmStart.hpp",
            "meta": {
              "brief": "Extended warm start with factorization caching for ABC"
            }
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
            }
          },
          {
            "id": "Clp/src/Clp_C_Interface.h",
            "meta": {
              "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
            }
          },
          {
            "id": "Osi/src/Osi/OsiSolverInterface.hpp",
            "meta": {
              "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
            }
          },
          {
            "id": "Cbc/src/CbcNodeInfo.hpp",
            "meta": {
              "brief": "Persistent information for recreating search tree nodes"
            }
          },
          {
            "id": "Cbc/src/CbcFullNodeInfo.hpp",
            "meta": {
              "brief": "Complete subproblem state storage (typically for root node)"
            }
          },
          {
            "id": "Cbc/src/Cbc_C_Interface.h",
            "meta": {
              "brief": "Creates an empty problem"
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpIpoptApplication.hpp",
            "meta": {
              "brief": "Main application class for calling Ipopt from C++\n\nIpoptApplication is the entry point for C++ applications using Ipopt.\nProvides methods for initialization, option handling, and solving."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIterateInitializer.hpp",
            "meta": {
              "brief": "Strategy interface for computing initial iterates\n\nIterateInitializer is the abstract base for strategies that\ncompute the starting point (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\nfor the interior point algorithm."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpWarmStartIterateInitializer.hpp",
            "meta": {
              "brief": "Warm start initialization from previous solution\n\nWarmStartIterateInitializer initializes IPM iterates from a\npreviously computed solution, enabling faster convergence for\nrelated problems (e.g., MPC, parametric optimization).\n\nWarm start sources:\n- warm_start_entire_iterate_: Use GetWarmStartIterate() from NLP\n- Otherwise: Use initialization vectors from NLP\n\nProcessing steps:\n1. Push primals away from bounds (warm_start_bound_push/frac_)\n2. Push slacks (warm_start_slack_bound_push/frac_)\n3. Clip multipliers (warm_start_mult_init_max_)\n4. Ensure bound multipliers positive (warm_start_mult_bound_push_)\n\nTarget mu adjustment (warm_start_target_mu_):\n- Adjusts slack/multiplier pairs toward target complementarity\n- process_target_mu(): Scales to achieve s*z \u2248 target_mu\n- adapt_to_target_mu(): Fine-tunes pairing\n\nKey parameters:\n- warm_start_bound_push_: Absolute bound push\n- warm_start_bound_frac_: Relative bound push\n- warm_start_mult_init_max_: Maximum multiplier magnitude\n- warm_start_target_mu_: Target barrier parameter"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
            "meta": {
              "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart_basis.hpp",
            "meta": {
              "brief": "BCP warm start basis implementation"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_node_change.hpp",
            "meta": {
              "brief": "Complete node delta encoding for tree storage"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp.hpp",
            "meta": {
              "brief": "LP process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
            "meta": {
              "brief": "LP warm start information for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_USER.hpp",
            "meta": {
              "brief": "User initialization and packing interface for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm_param.hpp",
            "meta": {
              "brief": "Tree Manager parameters for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
            "meta": {
              "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
            "meta": {
              "brief": "Abstract interface for NLP solvers used in branch-and-bound"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
            "meta": {
              "brief": "OsiSolverInterface wrapper for TMINLP problems"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
            "meta": {
              "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
            "meta": {
              "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
            }
          },
          {
            "id": "SYMPHONY/include/sym_master.h",
            "meta": {
              "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
            }
          },
          {
            "id": "SYMPHONY/include/sym_lp.h",
            "meta": {
              "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
            }
          },
          {
            "id": "Gravity/include/gravity/solver.h",
            "meta": {
              "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
            }
          },
          {
            "id": "SHOT/src/NLPSolver/NLPSolverIpoptBase.h",
            "meta": {
              "brief": "Ipopt implementation of INLPSolver interface\n\nProvides NLP solving for SHOT's primal problem using Ipopt interior point.\n\n**IpoptProblem Class (Ipopt::TNLP):**\n- Implements Ipopt's TNLP interface\n- Provides callbacks for function/gradient/Hessian evaluation\n- Sparse Jacobian/Hessian via index placement maps\n\n**TNLP Callbacks:**\n- get_nlp_info(): Problem dimensions and sparsity\n- get_bounds_info(): Variable and constraint bounds\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint function values\n- eval_jac_g(): Constraint Jacobian (sparse)\n- eval_h(): Lagrangian Hessian (sparse)\n- finalize_solution(): Store optimal point\n\n**NLPSolverIpoptBase Class:**\n- Wraps IpoptApplication for solve control\n- Variable fixing for integer-fixed NLP subproblems\n- Starting point management\n\n**IpoptJournal:**\n- Routes Ipopt output through SHOT logging system\n\n@note Used for fixed-integer NLP subproblems in primal bound computation"
            }
          },
          {
            "id": "SHOT/src/MIPSolver/IMIPSolver.h",
            "meta": {
              "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
            }
          }
        ]
      }
    },
    "bound_tightening": {
      "id": "bound_tightening",
      "name": "Bound Tightening",
      "category": "technique",
      "definition": "Infer tighter variable bounds from constraints. FBBT: propagate through constraint graph. OBBT: solve optimization subproblems.",
      "intuition": "If x + y \u2264 10 and y \u2265 3, then x \u2264 7. Propagate these implications to shrink the search space.",
      "aliases": [
        "domain reduction"
      ],
      "relationships": {
        "contains": [
          {
            "id": "FBBT"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/src/bound_tightening/CouenneFixPoint.hpp"
          },
          {
            "id": "CoinUtils/src/CoinDynamicConflictGraph.hpp",
            "meta": {
              "brief": "CoinConflictGraph implementation which supports modifications."
            }
          },
          {
            "id": "CoinUtils/src/CoinPresolveTighten.hpp",
            "meta": {
              "brief": "Tighten variable bounds using constraint propagation"
            }
          },
          {
            "id": "Clp/src/ClpPresolve.hpp",
            "meta": {
              "brief": "Clp interface to CoinPresolve for LP preprocessing"
            }
          },
          {
            "id": "Osi/src/Osi/OsiPresolve.hpp",
            "meta": {
              "brief": "OSI interface to problem simplification (presolve)\n\nPresolve reduces problem size before solving by applying\ntransformations that preserve optimal solutions:\n- Singleton row/column removal\n- Bound tightening\n- Coefficient reduction\n- Duplicate row/column detection"
            }
          },
          {
            "id": "Osi/src/Osi/OsiColCut.hpp",
            "meta": {
              "brief": "Column-based cuts for variable bound tightening\n\nColumn cuts represent bound changes on variables rather than\nadding new constraints. They are used for:\n- Bound tightening from probing\n- Implication-based bound strengthening\n- Reduced cost fixing"
            }
          },
          {
            "id": "Cbc/src/CbcObject.hpp",
            "meta": {
              "brief": "Abstract base for branching entities (variables, SOS, etc.)"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveVectorLength.hpp",
            "meta": {
              "brief": "Dive heuristic based on constraint participation\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveVectorLength: Selects variables by column density.\nVariables appearing in many constraints are fixed first."
            }
          },
          {
            "id": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
            "meta": {
              "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneSOSObject.hpp",
            "meta": {
              "brief": "Special Ordered Set (SOS) branching for Couenne"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
            "meta": {
              "brief": "Fixpoint-based bound tightening via constraint propagation\n\nImplements Feasibility-Based Bound Tightening (FBBT) using fixpoint\niteration. Propagates bounds through expression DAG until no further\ntightening is possible."
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneMultiVarProbe.hpp",
            "meta": {
              "brief": "Multi-variable probing for bound tightening"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneAggrProbing.hpp",
            "meta": {
              "brief": "Aggressive probing for bound tightening\n\nImplements Optimality-Based Bound Tightening (OBBT) through aggressive\nprobing. Temporarily fixes a variable bound and solves the resulting\nsubproblem to determine if a tighter bound is achievable."
            }
          },
          {
            "id": "Couenne/src/problem/CouenneProblem.hpp",
            "meta": {
              "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
            }
          },
          {
            "id": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
            "meta": {
              "brief": "Bound tightening from pairs of linear constraints"
            }
          },
          {
            "id": "Gravity/include/gravity/expr.h",
            "meta": {
              "brief": "Expression tree nodes for unary and binary operations\n\nExpressions are the building blocks for functions and constraints."
            }
          },
          {
            "id": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
            "meta": {
              "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
            }
          },
          {
            "id": "SHOT/src/Tasks/TaskPerformBoundTightening.h",
            "meta": {
              "brief": "Tighten variable bounds via optimization\n\nUses optimization-based bound tightening (OBBT).\n\n**TaskPerformBoundTightening Class:**\n- POASolver: Polyhedral outer approximation solver\n- createPOA(): Build relaxed problem for bound tightening\n\n**OBBT Algorithm:**\n- For each variable: min/max subject to relaxation\n- Tightens bounds beyond constraint propagation\n- Improves relaxation quality"
            }
          }
        ]
      }
    },
    "FBBT": {
      "id": "FBBT",
      "name": "Feasibility-Based Bound Tightening",
      "category": "technique",
      "definition": "Propagate bounds through constraint graph without solving subproblems. Fast but may miss tightenings that require global reasoning.",
      "intuition": "Local constraint propagation\u2014what can I infer about each variable from its immediate constraints?",
      "relationships": {
        "requires": [
          {
            "id": "bound_tightening"
          }
        ],
        "implemented_in": [
          {
            "id": "Couenne/src/bound_tightening/CouenneFixPoint.hpp"
          },
          {
            "id": "Cbc/src/CbcSimpleIntegerPseudoCost.hpp",
            "meta": {
              "brief": "Integer variable with static pseudocosts\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSimpleIntegerPseudoCost: Extends CbcSimpleInteger with static\npseudocost estimates for branch direction preference:\n- upPseudoCost_: Estimated objective increase per unit ceiling\n- downPseudoCost_: Estimated objective increase per unit floor"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneSOSObject.hpp",
            "meta": {
              "brief": "Special Ordered Set (SOS) branching for Couenne"
            }
          },
          {
            "id": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
            "meta": {
              "brief": "Fixpoint-based bound tightening via constraint propagation\n\nImplements Feasibility-Based Bound Tightening (FBBT) using fixpoint\niteration. Propagates bounds through expression DAG until no further\ntightening is possible."
            }
          },
          {
            "id": "Couenne/src/problem/CouenneProblem.hpp",
            "meta": {
              "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
            }
          },
          {
            "id": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
            "meta": {
              "brief": "Bound tightening from pairs of linear constraints"
            }
          }
        ]
      }
    },
    "branching": {
      "id": "branching",
      "name": "Branching",
      "category": "technique",
      "definition": "Choose which variable to branch on and what value to split at. Strong branching: test candidates. Pseudocost: use history.",
      "intuition": "Which split will help most? Try a few candidates (expensive) or use past experience (cheap).",
      "aliases": [
        "variable selection"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "Cbc/src/CbcBranchActual.hpp"
          },
          {
            "id": "Clp/src/ClpGubMatrix.hpp",
            "meta": {
              "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
            }
          },
          {
            "id": "Clp/src/ClpNode.hpp",
            "meta": {
              "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
            }
          },
          {
            "id": "Clp/src/ClpDualRowDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/ClpDualRowPivot.hpp",
            "meta": {
              "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
            }
          },
          {
            "id": "Clp/src/ClpPrimalColumnDantzig.hpp",
            "meta": {
              "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
            }
          },
          {
            "id": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
            "meta": {
              "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
            }
          },
          {
            "id": "Osi/src/Osi/OsiBranchingObject.hpp",
            "meta": {
              "brief": "Branch-and-bound objects and branching decisions\n\nThis file defines the object-oriented framework for branching in MIP:\n\n- **OsiObject**: Abstract base for anything that can be branched on\n  (integer variables, SOS constraints, etc.)\n- **OsiBranchingObject**: Describes how to perform a specific branch\n- **OsiBranchingInformation**: Solver state passed to branching decisions"
            }
          },
          {
            "id": "Osi/src/Osi/OsiChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection strategies for branch-and-bound\n\nIn MIP solving, choosing which variable to branch on significantly\naffects tree size and solve time. This file provides:\n\n- OsiChooseVariable: Base class for branching variable selection\n- OsiChooseStrong: Strong branching (evaluates candidates by solving LPs)"
            }
          },
          {
            "id": "Osi/src/Osi/OsiCut.hpp",
            "meta": {
              "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
            }
          },
          {
            "id": "Cbc/src/CbcConsequence.hpp",
            "meta": {
              "brief": "Abstract base for bound implications from branching"
            }
          },
          {
            "id": "Cbc/src/CbcSOS.hpp",
            "meta": {
              "brief": "Special Ordered Sets (SOS) Type 1 and Type 2 branching\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSOS: Branching for Special Ordered Sets (Beale & Tomlin, 1970):\n\nSOS Type 1: At most ONE variable can be nonzero\n- Common for selection between alternatives (choose one option)\n- SUM x_i <= 1 (or = 1 for exactly one)\n- Binary SOS1 is a special case of clique\n\nSOS Type 2: At most TWO CONSECUTIVE variables can be nonzero\n- Used for piecewise linear approximation (interpolation)\n- Variables ordered by weights; sum to 1\n- Represents point between two breakpoints"
            }
          },
          {
            "id": "Cbc/src/CbcBranchDecision.hpp",
            "meta": {
              "brief": "Abstract base for branching variable selection\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcFathom.hpp",
            "meta": {
              "brief": "Fathoming methods to complete subproblems"
            }
          },
          {
            "id": "Cbc/src/CbcGeneralDepth.hpp",
            "meta": {
              "brief": "Depth-limited partial evaluation branching"
            }
          },
          {
            "id": "Cbc/src/CbcObject.hpp",
            "meta": {
              "brief": "Abstract base for branching entities (variables, SOS, etc.)"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveFractional.hpp",
            "meta": {
              "brief": "Dive heuristic selecting most fractional variable\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveFractional: Simplest diving strategy.\nSelects the variable with value closest to 0.5 (most fractional)."
            }
          },
          {
            "id": "Cbc/src/CbcSymmetry.hpp",
            "meta": {
              "brief": "Symmetry detection and orbital branching using nauty\nAuthors: Pietro Belotti (Lehigh), Andreas Waechter (IBM)\nAdapted from Couenne (Carnegie-Mellon University, 2006-11)\nThis file is licensed under the Eclipse Public License (EPL)\n\nCbcSymmetry: Detects problem symmetry and exploits it for faster solving.\nUses the nauty library for automorphism group computation."
            }
          },
          {
            "id": "Cbc/src/CbcBranchActual.hpp",
            "meta": {
              "brief": "Aggregator for concrete branching classes"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveCoefficient.hpp",
            "meta": {
              "brief": "Dive heuristic based on objective coefficients\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveCoefficient: Selects variables based on objective impact.\nPrioritizes fractional variables with large objective coefficients."
            }
          },
          {
            "id": "Cbc/src/CbcBranchBase.hpp",
            "meta": {
              "brief": "Base includes for CBC branching model"
            }
          },
          {
            "id": "Cbc/src/CbcGeneral.hpp",
            "meta": {
              "brief": "Abstract base for general multi-way branching"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveGuided.hpp",
            "meta": {
              "brief": "Dive heuristic guided by incumbent solution\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveGuided: Uses existing incumbent to guide diving.\nRequires a feasible solution (canHeuristicRun checks this)."
            }
          },
          {
            "id": "Cbc/src/CbcLinked.hpp",
            "meta": {
              "brief": "Extended solver for nonlinear and bilinear problems"
            }
          },
          {
            "id": "Cbc/src/CbcSimpleIntegerDynamicPseudoCost.hpp",
            "meta": {
              "brief": "Integer variable with dynamic (learning) pseudocosts\nCopyright (C) 2005, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSimpleIntegerDynamicPseudoCost: Implements reliability branching\nbased on Achterberg, Koch & Martin's work. Pseudocosts are learned\nfrom actual branching history rather than being static estimates.\n\nKey statistics tracked per variable:\n- sumUpCost_/sumDownCost_: Cumulative objective changes\n- numberTimesUp_/Down_: Branch count for averaging\n- numberBeforeTrust_: Initialization threshold before trusting estimates"
            }
          },
          {
            "id": "Cbc/src/CbcSimpleIntegerPseudoCost.hpp",
            "meta": {
              "brief": "Integer variable with static pseudocosts\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSimpleIntegerPseudoCost: Extends CbcSimpleInteger with static\npseudocost estimates for branch direction preference:\n- upPseudoCost_: Estimated objective increase per unit ceiling\n- downPseudoCost_: Estimated objective increase per unit floor"
            }
          },
          {
            "id": "Cbc/src/CbcDummyBranchingObject.hpp",
            "meta": {
              "brief": "No-op branching object for special cases"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDiveVectorLength.hpp",
            "meta": {
              "brief": "Dive heuristic based on constraint participation\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveVectorLength: Selects variables by column density.\nVariables appearing in many constraints are fixed first."
            }
          },
          {
            "id": "Cbc/src/CbcBranchingObject.hpp",
            "meta": {
              "brief": "Abstract base for branching actions"
            }
          },
          {
            "id": "Cbc/src/CbcNWay.hpp",
            "meta": {
              "brief": "N-way branching (exactly one variable at upper bound)\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcNWay: Multi-way (N-ary) branching for selection constraints.\nExactly one variable at upper bound, all others at lower bound.\nCreates N children, each fixing one variable to its UB."
            }
          },
          {
            "id": "Cbc/src/CbcTreeLocal.hpp",
            "meta": {
              "brief": "Local branching search tree (Fischetti-Lodi 2002)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcBranchLotsize.hpp",
            "meta": {
              "brief": "Lot-sizing variable with discrete valid values\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcLotsize: Variable restricted to specific discrete values (lot sizes).\nUnlike integers (any value in range), lot-sizing variables can only\ntake values from a predefined set: {v1, v2, ..., vn}."
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDivePseudoCost.hpp",
            "meta": {
              "brief": "Dive heuristic using pseudocost estimates\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDivePseudoCost: Most informed diving strategy.\nUses pseudocosts to estimate objective change from fixing."
            }
          },
          {
            "id": "Cbc/src/CbcFollowOn.hpp",
            "meta": {
              "brief": "Follow-on branching for crew scheduling problems\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcFollowOn: Specialized branching for air-crew scheduling and\nsimilar set-partitioning problems. When crew can fly in on flight A\nand out on flight B (or other flights), branch on the connection."
            }
          },
          {
            "id": "Cbc/src/CbcObjectUpdateData.hpp",
            "meta": {
              "brief": "Data carrier for updating branching objects after branching"
            }
          },
          {
            "id": "Cbc/src/CbcBranchDynamic.hpp",
            "meta": {
              "brief": "Dynamic pseudocost-based branching decision\nCopyright (C) 2005, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchDynamicDecision: Selects branches using dynamic pseudocosts.\n- Before first solution: Uses infeasibility counts\n- After first solution: Uses objective change estimates\n\nPseudocosts are updated during search based on observed\nobjective changes from actual branching decisions."
            }
          },
          {
            "id": "Cbc/src/CbcNode.hpp",
            "meta": {
              "brief": "Search tree node for branch-and-cut\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcBranchAllDifferent.hpp",
            "meta": {
              "brief": "All-different constraint for integer variables\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchAllDifferent: Enforces that a set of integer variables\nmust all have different values. When two variables i,j have the\nsame value, creates branching disjunction:\n  x_i <= x_j - 1  OR  x_i >= x_j + 1"
            }
          },
          {
            "id": "Cbc/src/CbcCompareEstimate.hpp",
            "meta": {
              "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
            }
          },
          {
            "id": "Cbc/src/CbcFixVariable.hpp",
            "meta": {
              "brief": "Fix variable bounds as branching consequence"
            }
          },
          {
            "id": "Cbc/src/CbcHeuristicDive.hpp",
            "meta": {
              "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
            }
          },
          {
            "id": "Cbc/src/CbcClique.hpp",
            "meta": {
              "brief": "Clique branching for binary variable sets\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcClique: Branching for cliques (sets of binary variables with\nat most one at its \"strong\" value). Generalizes binary SOS1.\n\nStandard form: x1 + x2 + ... + xn <= 1 (all strong at 1)\nGeneral form allows negated variables (y_j = 1 - x_j).\n\nMember types (type_[i]):\n- 1: SOS-style, coefficient +1, strong value is 1\n- 0: Non-SOS, coefficient -1, strong value is 0"
            }
          },
          {
            "id": "Cbc/src/CbcTree.hpp",
            "meta": {
              "brief": "Heap-based storage for live search tree nodes\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcSimpleInteger.hpp",
            "meta": {
              "brief": "Integer variable branching object"
            }
          },
          {
            "id": "Cbc/src/CbcStrategy.hpp",
            "meta": {
              "brief": "Strategy pattern for configuring CbcModel components"
            }
          },
          {
            "id": "Cbc/src/CbcBranchCut.hpp",
            "meta": {
              "brief": "Branching by adding cuts (split disjunctions)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchCut and CbcCutBranchingObject: Branch by adding cuts\nrather than tightening variable bounds. Implements split disjunctions\nwhere each branch arm adds a different cut to the LP."
            }
          },
          {
            "id": "Cbc/src/CbcBranchDefaultDecision.hpp",
            "meta": {
              "brief": "Default branching variable selection\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchDefaultDecision: Simple selection algorithm without pseudocosts."
            }
          },
          {
            "id": "Cbc/src/CbcFeasibilityBase.hpp",
            "meta": {
              "brief": "User-defined feasibility checking"
            }
          },
          {
            "id": "Cbc/src/CbcStatistics.hpp",
            "meta": {
              "brief": "Statistics gathering for node processing"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_var.hpp",
            "meta": {
              "brief": "MKC variable/column definitions"
            }
          },
          {
            "id": "Bcp/Applications/Mkc/include/MKC_lp.hpp",
            "meta": {
              "brief": "MKC LP relaxation for BCP"
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/CSP_lp.hpp",
            "meta": {
              "brief": "CSP LP relaxation for BCP"
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/CSP_colgen.hpp",
            "meta": {
              "brief": "CSP column generation"
            }
          },
          {
            "id": "Bcp/Applications/Csp/include/CSP_lp_param.hpp",
            "meta": {
              "brief": "CSP LP parameters"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_user.hpp",
            "meta": {
              "brief": "User customization interface for LP process"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_functions.hpp",
            "meta": {
              "brief": "LP process internal function declarations"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_param.hpp",
            "meta": {
              "brief": "LP process parameters for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_branch.hpp",
            "meta": {
              "brief": "Internal branching object for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_cut.hpp",
            "meta": {
              "brief": "Cut (constraint) representation for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_process.hpp",
            "meta": {
              "brief": "BCP process base class and scheduler"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp.hpp",
            "meta": {
              "brief": "LP process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_enum_branch.hpp",
            "meta": {
              "brief": "Branching-related enumerations for BCP"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_lp_branch.hpp",
            "meta": {
              "brief": "LP-side branching objects for BCP Branch-Cut-Price"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
            "meta": {
              "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
            "meta": {
              "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonCutStrengthener.hpp",
            "meta": {
              "brief": "Strengthening OA cuts via NLP optimization\n\nImproves outer approximation cuts by solving auxiliary NLPs to find\ntighter bounds on linearizations. Also supports disjunctive cuts."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
            "meta": {
              "brief": "Abstract base class for strong branching NLP solves"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonCurvatureEstimator.hpp",
            "meta": {
              "brief": "Curvature estimation for branching decisions (NOT SUPPORTED)"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
            "meta": {
              "brief": "Base class for heuristics using local NLP/MINLP solves"
            }
          },
          {
            "id": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicLocalBranching.hpp",
            "meta": {
              "brief": "Local Branching heuristic for MINLP improvement"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonPseudoCosts.hpp",
            "meta": {
              "brief": "Pseudo-cost storage and update for MINLP branching\n\nExtends OsiPseudoCosts to track branching history for integer variables.\nPseudo-costs estimate the objective change per unit change in a variable,\nenabling efficient branching decisions without expensive strong branching."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
            "meta": {
              "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
            "meta": {
              "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonChooseVariable.hpp",
            "meta": {
              "brief": "Strong branching and pseudo-cost based variable selection for MINLP\n\nImplements branching variable selection for nonlinear branch-and-bound.\nCombines strong branching (solving LP/NLP relaxations) with pseudo-costs\n(estimates from historical branching information).\n\n**Key classes:**\n- BonChooseVariable: Main branching decision maker (extends OsiChooseVariable)\n- HotInfo: Stores strong branching results for a candidate\n\n**Branching decision process:**\n1. setupList(): Identify fractional variables, rank by pseudo-costs\n2. doStrongBranching(): Evaluate top candidates via LP/NLP solves\n3. chooseVariable(): Select best candidate based on objective change\n\n**Pseudo-cost computation:**\n- Estimates objective change per unit change in variable value\n- Updated after each branching decision using actual results\n- Used to avoid expensive strong branching after trust is established"
            }
          },
          {
            "id": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
            "meta": {
              "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
            }
          },
          {
            "id": "Couenne/src/expression/CouenneExprAux.hpp",
            "meta": {
              "brief": "Auxiliary variable class for reformulated nonlinear expressions\n\nAuxiliary variables replace nonlinear terms during standardization,\nenabling generation of convex relaxations. If w = f(x), then cuts\nare generated for the relation between w and f(x)."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneChooseVariable.hpp",
            "meta": {
              "brief": "Variable selection for branching in global optimization"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
            "meta": {
              "brief": "Three-way spatial branching for continuous variables"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneVarObject.hpp",
            "meta": {
              "brief": "Variable-based branching object for MINLP"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneComplBranchingObject.hpp",
            "meta": {
              "brief": "Branching object for complementarity constraints"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneBranchingObject.hpp",
            "meta": {
              "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneOrbitObj.hpp",
            "meta": {
              "brief": "Orbital branching using symmetry detection (DISABLED)"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneVTObject.hpp",
            "meta": {
              "brief": "Violation transfer branching for MINLP variables"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneComplObject.hpp",
            "meta": {
              "brief": "Branching object for complementarity constraints"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneNauty.hpp",
            "meta": {
              "brief": "Interface to nauty library for symmetry detection\n\nWraps the nauty graph automorphism library to detect symmetries\nin MINLP problems. Symmetry information enables orbital branching\nand isomorphism pruning to reduce the search space."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneObject.hpp",
            "meta": {
              "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
            }
          },
          {
            "id": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
            "meta": {
              "brief": "Orbital branching object using symmetry"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneSOSObject.hpp",
            "meta": {
              "brief": "Special Ordered Set (SOS) branching for Couenne"
            }
          },
          {
            "id": "Couenne/src/branch/CouenneChooseStrong.hpp",
            "meta": {
              "brief": "Strong branching for global MINLP optimization\n\nExtends Bonmin's strong branching to handle nonconvex constraints\nby evaluating actual LP bound improvement from branching."
            }
          },
          {
            "id": "Couenne/src/convex/CouenneCutGenerator.hpp",
            "meta": {
              "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
            }
          },
          {
            "id": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
            "meta": {
              "brief": "Iterative rounding heuristic for nonconvex MINLP"
            }
          },
          {
            "id": "Dip/Dip/src/DecompApp.h",
            "meta": {
              "brief": "User application interface - derive to define your decomposition\n\nDecompApp is the main user-facing class. Derive from it to define:\n- Model decomposition (core vs relaxed constraints)\n- Subproblem solvers\n- Problem-specific heuristics"
            }
          },
          {
            "id": "Dip/Dip/src/DecompAlgoPC.h",
            "meta": {
              "brief": "Price-and-Cut algorithm (Dantzig-Wolfe decomposition with cuts)\n\nDecompAlgoPC implements the most powerful DIP algorithm combining:\n- Column generation (pricing subproblems)\n- Cut generation (violated inequalities)\n- Branch-and-bound integration via ALPS"
            }
          },
          {
            "id": "SYMPHONY/include/sym_lp.h",
            "meta": {
              "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
            }
          },
          {
            "id": "SYMPHONY/include/sym_primal_heuristics.h",
            "meta": {
              "brief": "Primal heuristics for finding feasible solutions\n\nCollection of heuristics to find feasible MIP solutions quickly.\nCalled during B&C to improve incumbent and provide bounds."
            }
          },
          {
            "id": "SYMPHONY/include/symphony.h",
            "meta": {
              "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
            }
          },
          {
            "id": "SYMPHONY/include/sym_tm.h",
            "meta": {
              "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
            }
          },
          {
            "id": "HiGHS/highs/Highs.h",
            "meta": {
              "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsSearch.h",
            "meta": {
              "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
            }
          },
          {
            "id": "HiGHS/highs/mip/HighsNodeQueue.h",
            "meta": {
              "brief": "Priority queue for branch-and-bound nodes"
            }
          }
        ]
      }
    },
    "node_selection": {
      "id": "node_selection",
      "name": "Node Selection",
      "category": "technique",
      "definition": "Choose which node in the B&B tree to explore next. Best-first: chase best bound. Depth-first: find feasible solutions fast.",
      "intuition": "Explore the tree strategically. Best-bound proves optimality; depth-first finds solutions.",
      "relationships": {
        "implemented_in": [
          {
            "id": "Cbc/src/CbcCompareActual.hpp"
          },
          {
            "id": "CoinUtils/src/CoinSearchTree.hpp",
            "meta": {
              "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
            }
          },
          {
            "id": "Cbc/src/CbcCompareDefault.hpp",
            "meta": {
              "brief": "Default adaptive node comparison strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcCompareDepth.hpp",
            "meta": {
              "brief": "Depth-first node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareDepth: Implements depth-first search (DFS).\nDefault strategy before first solution is found.\n\ntest(x,y) returns true if y is deeper than x in the tree.\nDeepest nodes explored first -> LIFO stack behavior."
            }
          },
          {
            "id": "Cbc/src/CbcCompareEstimate.hpp",
            "meta": {
              "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
            }
          },
          {
            "id": "Cbc/src/CbcTree.hpp",
            "meta": {
              "brief": "Heap-based storage for live search tree nodes\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
            }
          },
          {
            "id": "Cbc/src/CbcCompareBase.hpp",
            "meta": {
              "brief": "Abstract base class for node comparison/selection"
            }
          },
          {
            "id": "Cbc/src/CbcCompareObjective.hpp",
            "meta": {
              "brief": "Best-bound (objective-based) node selection\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareObjective: Implements best-first search.\nAlways explores node with best (lowest for min) LP bound.\n\ntest(x,y) returns true if y has smaller objective than x.\nPrioritizes most promising nodes for optimality proof."
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm.hpp",
            "meta": {
              "brief": "Tree Manager process for BCP Branch-Cut-Price framework"
            }
          },
          {
            "id": "Bcp/Bcp/src/include/BCP_tm_user.hpp",
            "meta": {
              "brief": "User customization interface for Tree Manager process"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
            "meta": {
              "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
            }
          },
          {
            "id": "SYMPHONY/include/symphony.h",
            "meta": {
              "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
            }
          },
          {
            "id": "SYMPHONY/include/sym_tm.h",
            "meta": {
              "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
            }
          }
        ]
      }
    },
    "linear_system_solve": {
      "id": "linear_system_solve",
      "name": "Linear System Solve",
      "category": "technique",
      "definition": "Solve Ax = b for x. Foundation of most numerical optimization.",
      "intuition": "The workhorse computation. Interior point needs it for Newton; simplex for basis updates.",
      "relationships": {
        "contains": [
          {
            "id": "LU_factorization"
          }
        ]
      }
    },
    "barrier_function": {
      "id": "barrier_function",
      "name": "Barrier Function",
      "category": "technique",
      "definition": "Add -\u03bc \u03a3 log(x_i) to objective to keep x > 0. As \u03bc \u2192 0, solutions approach boundary (constraint satisfaction).",
      "intuition": "Create a \"force field\" that repels from boundaries. Weaken it gradually to approach the optimum.",
      "aliases": [
        "log barrier"
      ],
      "key_equations": [
        "-\u03bc log(x)  \u2192  +\u221e as x \u2192 0"
      ],
      "relationships": {}
    },
    "hessian": {
      "id": "hessian",
      "name": "Hessian Matrix",
      "category": "technique",
      "definition": "Matrix of second partial derivatives. H_ij = \u2202\u00b2f/\u2202x_i\u2202x_j. Describes local curvature of the function.",
      "intuition": "How curved is the function? Positive definite Hessian means convex (bowl-shaped).",
      "relationships": {
        "implemented_in": [
          {
            "id": "CoinUtils/src/CoinMpsIO.hpp",
            "meta": {
              "brief": "MPS file format reader/writer for LP and MIP problems\n\nReads/writes standard MPS format including extensions for quadratic,\nconic, and SOS constraints. Supports free format and compression."
            }
          },
          {
            "id": "CppAD/include/cppad/core/sparse_hes.hpp",
            "meta": {
              "brief": "Sparse Hessian computation using automatic differentiation"
            }
          },
          {
            "id": "CppAD/include/cppad/core/forward/forward.hpp",
            "meta": {
              "brief": "Core AD functionality: forward mode differentiation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES.hpp",
            "meta": {
              "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/QProblemB.hpp",
            "meta": {
              "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/SQProblem.hpp",
            "meta": {
              "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Flipper.hpp",
            "meta": {
              "brief": ""
            }
          },
          {
            "id": "qpOASES/include/qpOASES/Matrices.hpp",
            "meta": {
              "brief": "Matrix classes for QP data with working-set-aware operations"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/SolutionAnalysis.hpp",
            "meta": {
              "brief": "Post-optimality analysis: KKT verification and sensitivity"
            }
          },
          {
            "id": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
            "meta": {
              "brief": "Online QP Benchmark Collection interface"
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/sparse/sparsedrivers.h",
            "meta": {
              "brief": "High-level drivers for sparse Jacobian and Hessian computation\n\nProvides efficient computation of sparse derivatives by exploiting\nsparsity structure using graph coloring and compressed computation."
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpTNLP.hpp",
            "meta": {
              "brief": "User interface for defining NLP problems in standard form\n\nTNLP (Templated NLP) is the primary user-facing class for defining\noptimization problems. Users inherit from TNLP and implement:"
            }
          },
          {
            "id": "Ipopt/src/Interfaces/IpNLP.hpp",
            "meta": {
              "brief": "Internal NLP representation using Vector/Matrix abstractions\n\nNLP is Ipopt's internal problem representation with equality constraints\nseparated from inequalities:\n  min  f(x)\n  s.t. c(x) = 0           (equality constraints)\n       d_L <= d(x) <= d_U (inequality constraints)\n       x_L <= x <= x_U    (variable bounds)\n\nUnlike TNLP (user interface with arrays), NLP uses Vector and Matrix\nobjects for all operations. TNLPAdapter converts TNLP to this form."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
            "meta": {
              "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpRestoIpoptNLP.hpp",
            "meta": {
              "brief": "IpoptNLP adapter for restoration phase feasibility problem\n\nRestoIpoptNLP transforms the original NLP into a feasibility problem\nfor the restoration phase. It introduces slack variables to allow\nconstraint violations and penalizes them in the objective."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptNLP.hpp",
            "meta": {
              "brief": "Internal NLP interface with caching and scaling\n\nIpoptNLP abstracts the optimization problem for internal use:\n  min f(x)  s.t.  c(x) = 0, d_L <= d(x) <= d_U, x_L <= x <= x_U"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLowRankSSAugSystemSolver.hpp",
            "meta": {
              "brief": "Low-rank Hessian handling via single backsolve (iterative solver friendly)\n\nLowRankSSAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS) by augmenting the system rather than using\nSherman-Morrison. This requires only ONE factorization/backsolve."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpHessianUpdater.hpp",
            "meta": {
              "brief": "Strategy interface for Hessian computation/approximation\n\nHessianUpdater is the abstract base for strategies that provide\nthe Hessian of the Lagrangian (or an approximation) to the algorithm.\nThe result is stored in IpData.W()."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpNLPScaling.hpp",
            "meta": {
              "brief": "NLP scaling framework for problem conditioning\n\nNLPScalingObject is the abstract base for applying diagonal scaling\nto the NLP to improve numerical conditioning. Transforms:\n  min s_f*f(S_x^{-1}*x\u0303)  s.t.  s_c*c(S_x^{-1}*x\u0303)=0, ..."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpNLPBoundsRemover.hpp",
            "meta": {
              "brief": "NLP adapter that converts variable bounds to inequality constraints\n\nNLPBoundsRemover is an NLP adapter primarily used for inexact/iterative\nlinear solvers that require the KKT system to have a specific structure\nwithout bound constraints."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAugRestoSystemSolver.hpp",
            "meta": {
              "brief": "Augmented system solver exploiting restoration phase structure\n\nAugRestoSystemSolver is a decorator that exploits the known structure\nof the restoration phase problem to reduce the augmented system to\nthe original problem size."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
            "meta": {
              "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpTimingStatistics.hpp",
            "meta": {
              "brief": "Collection of timing statistics for algorithm profiling\n\nTimingStatistics aggregates TimedTask objects for all major\nalgorithm components, enabling performance profiling and\nbottleneck identification.\n\nTiming categories:\n- Algorithm phases: InitializeIterates, UpdateHessian, OutputIteration,\n  UpdateBarrierParameter, ComputeSearchDirection, etc.\n- Linear system: PDSystemSolverTotal, LinearSystemFactorization,\n  LinearSystemBackSolve, LinearSystemScaling\n- NLP evaluations: f_eval_time, grad_f_eval_time, c_eval_time,\n  jac_c_eval_time, d_eval_time, jac_d_eval_time, h_eval_time\n- Auxiliary: Task1-Task6 for ad-hoc profiling\n\nKey methods:\n- ResetTimes(): Clear all accumulated times\n- EnableTimes()/DisableTimes(): Control timing overhead\n- PrintAllTimingStatistics(): Output formatted timing report\n- TotalFunctionEvaluationCpuTime(): Sum of NLP evaluation times\n\nEach TimedTask tracks CPU time, system time, and wall-clock time."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
            "meta": {
              "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
            "meta": {
              "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpLowRankAugSystemSolver.hpp",
            "meta": {
              "brief": "Low-rank Hessian handling via Sherman-Morrison (multiple backsolves)\n\nLowRankAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS quasi-Newton) using the Sherman-Morrison formula.\n\nL-BFGS Hessian: W = sigma*I + V*M*V^T (compact representation)\n- V: n x 2k matrix of gradient/step differences\n- M: 2k x 2k small dense matrix\n- k: number of stored corrections (limited memory)\n\nSherman-Morrison approach:\n(A + UV^T)^{-1} = A^{-1} - A^{-1}U(I + V^TA^{-1}U)^{-1}V^TA^{-1}\n\nImplementation:\n1. Solve diagonal system: Vtilde = A^{-1}*V (2k backsolves)\n2. Form small dense matrix: J = I + V^T*Vtilde\n3. Solve J*y = V^T*A^{-1}*rhs (small dense solve)\n4. Correct: x = A^{-1}*rhs - Vtilde*y\n\nStorage:\n- J1_, J2_: Dense matrices for correction\n- Vtilde1_, Utilde2_: MultiVectorMatrix backsolve results\n- Wdiag_: Diagonal part passed to base solver"
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpOrigIpoptNLP.hpp",
            "meta": {
              "brief": "Standard IpoptNLP implementation wrapping user's NLP\n\nOrigIpoptNLP is the concrete implementation of IpoptNLP for standard\noptimization problems. It wraps the user's NLP (via TNLP/TNLPAdapter)\nand applies scaling transformations:\n\n  min s_f\u00b7f(S_x^{-1}\u00b7x\u0303)  s.t.  s_c\u00b7c(S_x^{-1}\u00b7x\u0303)=0, ..."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/IpAlgStrategy.hpp",
            "meta": {
              "brief": "Base class for all pluggable algorithm components\n\nAlgorithmStrategyObject is the abstract base for Ipopt's Strategy pattern\nimplementation. All pluggable algorithm components inherit from this:\n- LineSearch, MuUpdate, ConvergenceCheck\n- SearchDirectionCalculator, HessianUpdater\n- PDSystemSolver, AugSystemSolver"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
            "meta": {
              "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpLowRankUpdateSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix as low-rank update: M = D + V*V^T - U*U^T\n\nLowRankUpdateSymMatrix represents matrices in factored form:\n  M = P_LR * (D + V*V^T - U*U^T) * P_LR^T  (if reduced_diag)\n  M = D + P_LR * (V*V^T - U*U^T) * P_LR^T  (otherwise)"
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpZeroSymMatrix.hpp",
            "meta": {
              "brief": "Symmetric matrix with all zero entries\n\nZeroSymMatrix represents a symmetric zero matrix (n x n).\nNo storage required. Inherits from SymMatrix for type safety."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
            "meta": {
              "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpExpandedMultiVectorMatrix.hpp",
            "meta": {
              "brief": "Short-fat matrix V^T*P^T with expansion for KKT construction\n\nExpandedMultiVectorMatrix represents a k x n matrix (k << n) as\nV^T * P^T where V is a MultiVectorMatrix-like collection of row\nvectors and P is an optional ExpansionMatrix."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
            "meta": {
              "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
            }
          },
          {
            "id": "Ipopt/src/LinAlg/IpSymMatrix.hpp",
            "meta": {
              "brief": "Abstract base class for symmetric matrices\n\nSymMatrix extends Matrix for symmetric matrices (A = A^T).\nTransMultVector automatically delegates to MultVector since\ntranspose is a no-op for symmetric matrices."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
            "meta": {
              "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/Inexact/IpInexactCq.hpp",
            "meta": {
              "brief": "Cached quantities for inexact Newton / Chen-Goldfarb penalty method\n\nInexactCq provides precomputed and cached quantities specific to the\ninexact Newton algorithm, extending IpoptCalculatedQuantities."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
            "meta": {
              "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
            "meta": {
              "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
            }
          },
          {
            "id": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
            "meta": {
              "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
            "meta": {
              "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonCurvatureEstimator.hpp",
            "meta": {
              "brief": "Curvature estimation for branching decisions (NOT SUPPORTED)"
            }
          },
          {
            "id": "Bonmin/src/Interfaces/BonTMINLP.hpp",
            "meta": {
              "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
            }
          },
          {
            "id": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
            "meta": {
              "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
            }
          },
          {
            "id": "Gravity/include/gravity/func.h",
            "meta": {
              "brief": "Expression functions with automatic differentiation and convexity tracking\n\nThe func class represents mathematical expressions with symbolic analysis."
            }
          },
          {
            "id": "Gravity/include/gravity/model.h",
            "meta": {
              "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/factor.hpp",
            "meta": {
              "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
            }
          },
          {
            "id": "HiGHS/highs/qpsolver/basis.hpp",
            "meta": {
              "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
            }
          }
        ]
      }
    },
    "automatic_differentiation": {
      "id": "automatic_differentiation",
      "name": "Automatic Differentiation",
      "category": "technique",
      "definition": "Compute derivatives exactly by applying chain rule to program operations. Forward mode: Jacobian-vector products. Reverse mode: gradient.",
      "intuition": "Don't derive gradients by hand or use finite differences. Let the computer apply calculus rules automatically.",
      "aliases": [
        "AD",
        "autodiff"
      ],
      "relationships": {
        "implemented_in": [
          {
            "id": "CppAD/"
          },
          {
            "id": "ADOL-C/"
          },
          {
            "id": "CppAD/include/cppad/cppad.hpp",
            "meta": {
              "brief": "Contains all variables and functions defined by CppAD package"
            }
          },
          {
            "id": "CppAD/include/cppad/core/sparse_jac.hpp",
            "meta": {
              "brief": "Sparse Jacobian computation using graph coloring"
            }
          },
          {
            "id": "CppAD/include/cppad/core/reverse.hpp",
            "meta": {
              "brief": "Reverse mode automatic differentiation"
            }
          },
          {
            "id": "CppAD/include/cppad/core/ad.hpp",
            "meta": {
              "brief": "Core AD<Base> automatic differentiation scalar type\n\nAD<Base> is the fundamental type for automatic differentiation.\nOperations on AD<Base> values are recorded on a \"tape\" which can\nlater be used to compute derivatives."
            }
          },
          {
            "id": "CppAD/include/cppad/core/forward/forward.hpp",
            "meta": {
              "brief": "Core AD functionality: forward mode differentiation"
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/checkpointing.h",
            "meta": {
              "brief": "Checkpointing support for memory-efficient reverse mode AD\n\nImplements checkpointing (also known as \"time-stepping\" or \"revolve\")\nfor computing adjoints of long time-stepping computations with bounded\nmemory. Instead of storing all intermediate states, only selected\n\"checkpoints\" are stored, and segments are recomputed as needed."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/adolc.h",
            "meta": {
              "brief": "Master include file for ADOL-C automatic differentiation library\n\nADOL-C (Automatic Differentiation by Overloading in C++) computes derivatives\nof mathematical functions via operator overloading and tape-based recording.\nRecords computation as a \"tape\" then replays in forward/reverse mode."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/revolve.h",
            "meta": {
              "brief": "Optimal binomial checkpointing for memory-efficient reverse mode\n\nImplements the revolve algorithm (Griewank & Walther) for optimal\ncheckpoint placement in reverse mode automatic differentiation."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/adtl.h",
            "meta": {
              "brief": "Tape-less (traceless) forward-mode automatic differentiation\n\nProvides the adtl::adouble class for direct forward-mode AD without\ntape recording. Each adouble carries both its value and directional\nderivatives, which are propagated immediately through operations."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/tape_interface.h",
            "meta": {
              "brief": "Tape management interface for ADOL-C automatic differentiation\n\nProvides functions for managing the \"tape\" - a recorded sequence of\noperations that can be replayed in forward or reverse mode to compute\nderivatives."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/adtb_types.h",
            "meta": {
              "brief": "Core AD types: adouble, pdouble, and tape_location\n\nDefines the fundamental types for tape-based automatic differentiation:\n\n- **adouble**: Active double that records operations on the tape.\n  Use for variables whose derivatives you want to compute.\n\n- **pdouble**: Parameter double for non-differentiable constants that\n  can be changed without re-taping. Use for parameters you want to\n  vary across multiple derivative evaluations.\n\n- **tape_location<T>**: RAII wrapper managing tape location allocation\n  and deallocation for adouble/pdouble."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/interfaces.h",
            "meta": {
              "brief": "Low-level forward and reverse mode interfaces for tape evaluation\n\nProvides the core differentiation routines that evaluate recorded tapes\nin forward mode (computing directional derivatives) and reverse mode\n(computing adjoints/gradients). These are the building blocks used by\nhigher-level drivers like gradient() and hessian()."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/sparse/sparsedrivers.h",
            "meta": {
              "brief": "High-level drivers for sparse Jacobian and Hessian computation\n\nProvides efficient computation of sparse derivatives by exploiting\nsparsity structure using graph coloring and compressed computation."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/drivers/taylor.h",
            "meta": {
              "brief": "Higher-order derivative tensors and implicit function differentiation\n\nProvides drivers for computing higher-order derivative tensors and\ndifferentiating through implicit/inverse functions."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/drivers/odedrivers.h",
            "meta": {
              "brief": "Taylor-based ODE integration drivers\n\nProvides drivers for solving and differentiating ODEs of the form\nx' = f(x) using Taylor series expansion. The tape records f(x),\nthen these drivers compute higher-order Taylor coefficients."
            }
          },
          {
            "id": "ADOL-C/ADOL-C/include/adolc/drivers/drivers.h",
            "meta": {
              "brief": "High-level driver functions for derivative computation\n\nProvides convenient functions for computing common derivative quantities:\n- gradient(): First derivative of scalar function (\u2207f)\n- jacobian(): First derivative of vector function (\u2202F/\u2202x)\n- hessian(): Second derivative of scalar function (\u2207\u00b2f)\n- hess_vec(): Hessian-vector product (\u2207\u00b2f \u00b7 v)\n- jac_vec(): Jacobian-vector product (J \u00b7 v)\n- vec_jac(): Vector-Jacobian product (u^T \u00b7 J)\n\nThese drivers wrap the lower-level forward/reverse interfaces and handle\nmemory allocation and mode selection automatically. All functions require\na pre-recorded tape (via trace_on/trace_off)."
            }
          },
          {
            "id": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
            "meta": {
              "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
            }
          }
        ]
      }
    }
  },
  "relationships": [
    {
      "from": "linear_programming",
      "to": "quadratic_programming",
      "type": "generalizes"
    },
    {
      "from": "linear_programming",
      "to": "convexity",
      "type": "requires"
    },
    {
      "from": "quadratic_programming",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "quadratic_programming",
      "to": "nonlinear_programming",
      "type": "generalizes"
    },
    {
      "from": "nonlinear_programming",
      "to": "quadratic_programming",
      "type": "requires"
    },
    {
      "from": "nonlinear_programming",
      "to": "KKT_conditions",
      "type": "requires"
    },
    {
      "from": "mixed_integer_programming",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "mixed_integer_programming",
      "to": "mixed_integer_nonlinear_programming",
      "type": "generalizes"
    },
    {
      "from": "mixed_integer_programming",
      "to": "LP_relaxation",
      "type": "requires"
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "nonlinear_programming",
      "type": "requires"
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "mixed_integer_programming",
      "type": "requires"
    },
    {
      "from": "convex_optimization",
      "to": "convexity",
      "type": "requires"
    },
    {
      "from": "convex_optimization",
      "to": "linear_programming",
      "type": "contains"
    },
    {
      "from": "convex_optimization",
      "to": "quadratic_programming",
      "type": "contains"
    },
    {
      "from": "nonconvex_optimization",
      "to": "convexification",
      "type": "requires"
    },
    {
      "from": "simplex_method",
      "to": "linear_programming",
      "type": "solves"
    },
    {
      "from": "simplex_method",
      "to": "LU_factorization",
      "type": "requires"
    },
    {
      "from": "simplex_method",
      "to": "basis",
      "type": "requires"
    },
    {
      "from": "simplex_method",
      "to": "interior_point_method",
      "type": "alternative_to"
    },
    {
      "from": "interior_point_method",
      "to": "simplex_method",
      "type": "alternative_to"
    },
    {
      "from": "simplex_method",
      "to": "dual_simplex",
      "type": "contains"
    },
    {
      "from": "simplex_method",
      "to": "primal_simplex",
      "type": "contains"
    },
    {
      "from": "dual_simplex",
      "to": "simplex_method",
      "type": "requires"
    },
    {
      "from": "dual_simplex",
      "to": "LP_duality",
      "type": "requires"
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in"
    },
    {
      "from": "primal_simplex",
      "to": "simplex_method",
      "type": "requires"
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in"
    },
    {
      "from": "interior_point_method",
      "to": "linear_programming",
      "type": "solves"
    },
    {
      "from": "interior_point_method",
      "to": "nonlinear_programming",
      "type": "solves"
    },
    {
      "from": "interior_point_method",
      "to": "newton_method",
      "type": "requires"
    },
    {
      "from": "interior_point_method",
      "to": "barrier_function",
      "type": "requires"
    },
    {
      "from": "interior_point_method",
      "to": "KKT_conditions",
      "type": "requires"
    },
    {
      "from": "interior_point_method",
      "to": "simplex_method",
      "type": "alternative_to"
    },
    {
      "from": "simplex_method",
      "to": "interior_point_method",
      "type": "alternative_to"
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in"
    },
    {
      "from": "newton_method",
      "to": "hessian",
      "type": "requires"
    },
    {
      "from": "newton_method",
      "to": "linear_system_solve",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "mixed_integer_programming",
      "type": "solves"
    },
    {
      "from": "branch_and_bound",
      "to": "LP_relaxation",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "branching",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "node_selection",
      "type": "requires"
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcModel.hpp",
      "type": "implemented_in"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "branch_and_bound",
      "type": "requires"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "convexification",
      "type": "requires"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "bound_tightening",
      "type": "requires"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "nonconvex_optimization",
      "type": "solves"
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "Couenne/src/branch/CouenneObject.hpp",
      "type": "implemented_in"
    },
    {
      "from": "outer_approximation",
      "to": "mixed_integer_nonlinear_programming",
      "type": "solves"
    },
    {
      "from": "outer_approximation",
      "to": "convexity",
      "type": "requires"
    },
    {
      "from": "outer_approximation",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
      "type": "implemented_in"
    },
    {
      "from": "cutting_planes",
      "to": "LP_relaxation",
      "type": "requires"
    },
    {
      "from": "cutting_planes",
      "to": "Gomory_cuts",
      "type": "contains"
    },
    {
      "from": "cutting_planes",
      "to": "MIR_cuts",
      "type": "contains"
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/",
      "type": "implemented_in"
    },
    {
      "from": "Gomory_cuts",
      "to": "cutting_planes",
      "type": "requires"
    },
    {
      "from": "Gomory_cuts",
      "to": "basis",
      "type": "requires"
    },
    {
      "from": "Gomory_cuts",
      "to": "Cgl/src/CglGomory/CglGomory.hpp",
      "type": "implemented_in"
    },
    {
      "from": "MIR_cuts",
      "to": "cutting_planes",
      "type": "requires"
    },
    {
      "from": "MIR_cuts",
      "to": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
      "type": "implemented_in"
    },
    {
      "from": "active_set_method",
      "to": "quadratic_programming",
      "type": "solves"
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/",
      "type": "implemented_in"
    },
    {
      "from": "feasibility_pump",
      "to": "mixed_integer_programming",
      "type": "solves"
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp",
      "type": "implemented_in"
    },
    {
      "from": "KKT_conditions",
      "to": "Lagrangian",
      "type": "requires"
    },
    {
      "from": "KKT_conditions",
      "to": "complementary_slackness",
      "type": "contains"
    },
    {
      "from": "LP_duality",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "LP_duality",
      "to": "Lagrangian",
      "type": "requires"
    },
    {
      "from": "LP_duality",
      "to": "complementary_slackness",
      "type": "contains"
    },
    {
      "from": "Lagrangian",
      "to": "KKT_conditions",
      "type": "contains"
    },
    {
      "from": "complementary_slackness",
      "to": "KKT_conditions",
      "type": "requires"
    },
    {
      "from": "convexity",
      "to": "convex_optimization",
      "type": "required_by"
    },
    {
      "from": "sparsity",
      "to": "LU_factorization",
      "type": "enables"
    },
    {
      "from": "LP_relaxation",
      "to": "linear_programming",
      "type": "requires"
    },
    {
      "from": "LP_relaxation",
      "to": "branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "convexification",
      "to": "spatial_branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "convexification",
      "to": "McCormick_envelopes",
      "type": "contains"
    },
    {
      "from": "McCormick_envelopes",
      "to": "convexification",
      "type": "requires"
    },
    {
      "from": "McCormick_envelopes",
      "to": "Couenne/",
      "type": "implemented_in"
    },
    {
      "from": "basis",
      "to": "simplex_method",
      "type": "required_by"
    },
    {
      "from": "basis",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in"
    },
    {
      "from": "LU_factorization",
      "to": "simplex_method",
      "type": "required_by"
    },
    {
      "from": "LU_factorization",
      "to": "sparsity",
      "type": "requires"
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in"
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveMatrix.hpp",
      "type": "implemented_in"
    },
    {
      "from": "presolve",
      "to": "Clp/src/ClpPresolve.hpp",
      "type": "implemented_in"
    },
    {
      "from": "warm_start",
      "to": "CoinUtils/src/CoinWarmStart.hpp",
      "type": "implemented_in"
    },
    {
      "from": "warm_start",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in"
    },
    {
      "from": "bound_tightening",
      "to": "spatial_branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "bound_tightening",
      "to": "FBBT",
      "type": "contains"
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
      "type": "implemented_in"
    },
    {
      "from": "FBBT",
      "to": "bound_tightening",
      "type": "requires"
    },
    {
      "from": "FBBT",
      "to": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
      "type": "implemented_in"
    },
    {
      "from": "branching",
      "to": "branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchActual.hpp",
      "type": "implemented_in"
    },
    {
      "from": "node_selection",
      "to": "branch_and_bound",
      "type": "required_by"
    },
    {
      "from": "node_selection",
      "to": "Cbc/src/CbcCompareActual.hpp",
      "type": "implemented_in"
    },
    {
      "from": "linear_system_solve",
      "to": "LU_factorization",
      "type": "contains"
    },
    {
      "from": "linear_system_solve",
      "to": "newton_method",
      "type": "required_by"
    },
    {
      "from": "barrier_function",
      "to": "interior_point_method",
      "type": "required_by"
    },
    {
      "from": "hessian",
      "to": "newton_method",
      "type": "required_by"
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/",
      "type": "implemented_in"
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/",
      "type": "implemented_in"
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveZeros.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Drop and reintroduce explicit zero coefficients"
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core presolve data structures and action base class\n\nDefines CoinPrePostsolveMatrix (common base), CoinPresolveMatrix (for\npresolve), CoinPostsolveMatrix (for postsolve), and CoinPresolveAction\n(base class for all presolve transformations)."
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveUseless.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Remove useless (redundant) constraints"
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveForcing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Forcing and useless constraint detection"
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveImpliedFree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Detect and process implied free variables"
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinPresolveTighten.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds using constraint propagation"
      }
    },
    {
      "from": "presolve",
      "to": "CoinUtils/src/CoinStaticConflictGraph.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "static CoinConflictGraph implementation with fast queries"
      }
    },
    {
      "from": "presolve",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Sanitize.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix preprocessing for graph partitioning\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nMatrix sanitization prepares input for partitioning: sanitizeMatrix\nhandles symmetry and binary weights, removeDiagonal strips self-loops,\nmirrorTriangular expands triangular to symmetric. Ensures valid\nundirected graph representation for algorithms."
      }
    },
    {
      "from": "presolve",
      "to": "SuiteSparse/KLU/Include/klu.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
      }
    },
    {
      "from": "presolve",
      "to": "Clp/src/ClpSolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Algorithm selection and configuration for ClpSimplex::initialSolve()"
      }
    },
    {
      "from": "presolve",
      "to": "Clp/src/ClpPresolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clp interface to CoinPresolve for LP preprocessing"
      }
    },
    {
      "from": "presolve",
      "to": "Osi/src/Osi/OsiPresolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OSI interface to problem simplification (presolve)\n\nPresolve reduces problem size before solving by applying\ntransformations that preserve optimal solutions:\n- Singleton row/column removal\n- Bound tightening\n- Coefficient reduction\n- Duplicate row/column detection"
      }
    },
    {
      "from": "presolve",
      "to": "Osi/src/Osi/OsiColCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Column-based cuts for variable bound tightening\n\nColumn cuts represent bound changes on variables rather than\nadding new constraints. They are used for:\n- Bound tightening from probing\n- Implication-based bound strengthening\n- Reduced cost fixing"
      }
    },
    {
      "from": "presolve",
      "to": "Cbc/src/CbcConsequence.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for bound implications from branching"
      }
    },
    {
      "from": "presolve",
      "to": "Cbc/src/CbcFathom.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fathoming methods to complete subproblems"
      }
    },
    {
      "from": "presolve",
      "to": "Cbc/src/CbcSolverHeuristics.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Heuristic setup and execution routines for cbc-generic"
      }
    },
    {
      "from": "presolve",
      "to": "Cbc/src/CbcParameters.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central parameter collection for Cbc algorithm control\nCopyright (C) 2007, Lou Hafer, IBM Corporation and others.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcParameters: Master class holding all Cbc solver parameters.\nUsed by cbc-generic to configure and control the MIP solver.\n\nMajor subsystems configured:\n- Cut generators: Gomory, MIR, Probing, Clique, FlowCover, etc.\n- Heuristics: FPump, RINS, RENS, DINS, Diving variants, VND, etc.\n- Search strategy: Node selection, preprocessing, orbital branching\n- Limits: Time, nodes, gap tolerance, solution count\n\nIncludes instances of CGL cut generators and Cbc heuristics.\nLinks to ClpParameters for underlying LP solver control.\n\nKey methods:\n- init(): Initialize with strategy preset\n- setModel(): Associate with CbcModel\n- Various getters/setters for each parameter category\n\nStrategy presets provide common configurations:\n- Default aggressive cutting at root\n- Balanced cut/heuristic emphasis\n- Heuristic-focused for quick solutions"
      }
    },
    {
      "from": "presolve",
      "to": "Cbc/src/CbcStrategy.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy pattern for configuring CbcModel components"
      }
    },
    {
      "from": "presolve",
      "to": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
      }
    },
    {
      "from": "presolve",
      "to": "Cgl/src/CglProbing/CglProbing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Probing cut generator - variable fixing and implications\n\nProbing systematically tests setting integer variables to bounds,\npropagating implications to derive:\n- Variable fixings (column cuts)\n- Bound tightenings\n- Disaggregation cuts (row cuts)\n- Coefficient strengthening\n- Clique structures\n\nProbing outcomes when testing x_j = 0 vs x_j = 1:\n1. One direction infeasible \u2192 fix variable (column cut)\n2. Both infeasible \u2192 problem infeasible\n3. Both feasible, y fixed same way \u2192 y can be fixed\n4. Both feasible, y fixed opposite \u2192 can substitute y = 1-x_j\n5. Constraint went slack by c \u2192 strengthen coefficient\n\nKey structures:\n- disaggregationAction: What gets fixed when probing a variable\n- cutVector_: Stores implications for each integer\n- Clique arrays: oneFixStart_, zeroFixStart_ for clique membership\n\nModes:\n- mode_ 0: Only unsatisfied integers, use snapshot (fast, global)\n- mode_ 1: Unsatisfied integers with current bounds\n- mode_ 2: All integers with current bounds\n\nCglImplication (separate class):\n- Generates cuts directly from stored implication info\n- Uses CglTreeProbingInfo built during probing"
      }
    },
    {
      "from": "presolve",
      "to": "Ipopt/src/Algorithm/IpProbingMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's probing heuristic for barrier parameter selection\n\nProbingMuOracle implements Mehrotra's predictor-corrector approach\nto compute the barrier parameter mu. This is the strategy used in\nmany interior point codes like LOQO and PCx.\n\nAlgorithm:\n1. Compute affine scaling direction (predictor step) with sigma=0\n2. Find maximum step to boundary (alpha_aff)\n3. Compute complementarity after affine step: mu_aff\n4. Compute centering parameter: sigma = (mu_aff/mu)^3\n5. Use sigma in corrector step\n\nThe centering parameter sigma controls the balance between:\n- sigma=0: Pure affine scaling (aggressive, may overshoot)\n- sigma=1: Pure centering (conservative, slow progress)\n\nKey parameter:\n- sigma_max_: Upper bound on sigma to prevent excessive centering"
      }
    },
    {
      "from": "presolve",
      "to": "Ipopt/src/Algorithm/IpMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for suggesting barrier parameter values\n\nMuOracle is the abstract interface for components that compute\nsuggested values for the barrier parameter mu in adaptive (non-monotone)\nbarrier updates."
      }
    },
    {
      "from": "presolve",
      "to": "Ipopt/src/Algorithm/IpMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for updating barrier parameter mu\n\nMuUpdate is the abstract base for strategies that determine the\nbarrier parameter mu and fraction-to-boundary parameter tau for\neach iteration of the interior point method."
      }
    },
    {
      "from": "presolve",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
      }
    },
    {
      "from": "presolve",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to PARDISO sparse solver from pardiso-project.org\n\nPardisoSolverInterface wraps the PARDISO solver distributed by\npardiso-project.org (not to be confused with Intel MKL's PARDISO).\nPARDISO is a high-performance parallel direct solver for sparse\nsymmetric indefinite systems."
      }
    },
    {
      "from": "presolve",
      "to": "Bcp/Bcp/src/include/BCP_lp_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process parameters for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "presolve",
      "to": "Bcp/Bcp/src/include/BCP_enum_branch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching-related enumerations for BCP"
      }
    },
    {
      "from": "presolve",
      "to": "Bcp/Bcp/src/include/BCP_lp_branch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-side branching objects for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "presolve",
      "to": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
      }
    },
    {
      "from": "presolve",
      "to": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fixpoint-based bound tightening via constraint propagation\n\nImplements Feasibility-Based Bound Tightening (FBBT) using fixpoint\niteration. Propagates bounds through expression DAG until no further\ntightening is possible."
      }
    },
    {
      "from": "presolve",
      "to": "Couenne/src/bound_tightening/CouenneMultiVarProbe.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Multi-variable probing for bound tightening"
      }
    },
    {
      "from": "presolve",
      "to": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Trilinear product expression w = x*y*z"
      }
    },
    {
      "from": "presolve",
      "to": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bound tightening from pairs of linear constraints"
      }
    },
    {
      "from": "presolve",
      "to": "SYMPHONY/include/sym_prep.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP preprocessing (presolve) for SYMPHONY\n\nPreprocessing reduces problem size before B&C by fixing variables,\nremoving redundant constraints, and tightening bounds."
      }
    },
    {
      "from": "presolve",
      "to": "SYMPHONY/include/sym_master.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
      }
    },
    {
      "from": "presolve",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "presolve",
      "to": "HiGHS/highs/mip/HighsMipSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-cut MIP solver"
      }
    },
    {
      "from": "presolve",
      "to": "HiGHS/highs/mip/HighsSeparation.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut generation orchestration for MIP solver"
      }
    },
    {
      "from": "presolve",
      "to": "HiGHS/highs/mip/HighsSeparator.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cut separators"
      }
    },
    {
      "from": "presolve",
      "to": "HiGHS/highs/mip/HighsImplications.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Implication graphs and variable bound relationships for MIP"
      }
    },
    {
      "from": "presolve",
      "to": "HiGHS/highs/ipm/ipx/iterate.h",
      "type": "implemented_in",
      "meta": {
        "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinPresolveZeros.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Drop and reintroduce explicit zero coefficients"
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinSimpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinPackedMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse matrix stored in compressed row or column format\n\nCoinPackedMatrix represents a sparse matrix using compressed storage.\nCan be stored row-major or column-major. Efficient for major-dimension\noperations (accessing rows in row-major, columns in column-major)."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinOslFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinIndexedVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse vector with dense backing array for O(1) element access\n\nCoinIndexedVector combines sparse index storage with a dense values array,\nenabling O(1) random access while tracking which positions are non-zero.\nDesigned for simplex operations where sparse updates need fast access.\nHas optional \"packed\" mode that behaves more like CoinPackedVector."
      }
    },
    {
      "from": "sparsity",
      "to": "CoinUtils/src/CoinPackedVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse vector that owns its index/value storage\n\nCoinPackedVector stores a sparse vector as parallel arrays of indices\nand values. Unlike CoinShallowPackedVector, this class owns its storage\nand supports modification operations."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Sanitize.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix preprocessing for graph partitioning\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nMatrix sanitization prepares input for partitioning: sanitizeMatrix\nhandles symmetry and binary weights, removeDiagonal strips self-loops,\nmirrorTriangular expands triangular to symmetric. Ensures valid\nundirected graph representation for algorithms."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_IO.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix Market file I/O for graphs and matrices\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nFile I/O for Mongoose: read_graph creates Graph from Matrix Market file,\nread_matrix creates cs struct. Handles symmetrization (A+A')/2 for\nasymmetric matrices, extracts largest connected component, removes\ndiagonal. Accepts C string or std::string filenames."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Graph.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Graph data structure for Mongoose partitioning\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nGraph class stores adjacency in CSC format (p, i arrays) with optional\nedge weights (x) and vertex weights (w). Factory methods create from\nraw arrays or CSparse matrices. Shallow copy flags track ownership."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_CSparse.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse matrix operations subset from CSparse library\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nProvides CSparse subset for sparse matrix operations: cs struct\n(compressed column/triplet format), cs_add (matrix addition),\ncs_transpose, cs_compress (triplet to CSC), and allocation.\nUses int64_t (csi) matching Mongoose's Int type."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/SPQR/Include/SuiteSparseQR.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User C++ API for sparse multifrontal QR factorization\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nMain user interface for SPQR: SuiteSparseQR overloads for [Q,R,E]=qr(A),\nX=A\\B, qmult. Structures: spqr_symbolic (pattern analysis), spqr_numeric\n(R values, Householder H), spqr_gpu (GPU staging). Expert functions:\nSuiteSparseQR_factorize, _solve, _min2norm, _symbolic, _numeric for\nfactorization reuse. Supports real/complex, int32/int64."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/SPQR/Include/spqr.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal SPQR implementation functions and data structures\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nNon-user-callable routines: spqr_analyze (symbolic), spqr_factorize (numeric),\nspqr_kernel (parallel front factorization), spqr_assemble/cpack/rhpack (front\nassembly). Support: spqr_tol, stranspose1/2, larftb (block reflectors),\nhapply, panel, 1colamd, 1fixed. Helper structs: spqr_work, spqr_blob.\nMacros: FLIP/UNFLIP for marking, INDEX for column-major."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/ParU/Source/paru_internal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal data structures and functions for ParU sparse LU\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis.\nGPL-3.0-or-later license.\n\nCore ParU structures: ParU_Symbolic_struct (row-form S, singletons, fronts,\ntask tree), ParU_Numeric_struct (LU factors, permutations, scaling),\nParU_Control_struct (tolerances, threading). paru_element (contribution\nblock), paru_work (workspace), paru_tuple (element lists). Internal\nfunctions: front assembly/factorization, heap management, BLAS threading.\nIncludes UMFPACK SymbolicType/SWType for singleton detection."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/RBio/Include/RBio.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Rutherford-Boeing sparse matrix I/O library\nCopyright (c) 2009-2023, Timothy A. Davis. GPL-2.0+ license.\n\nRBio reads and writes sparse matrices in Rutherford-Boeing format,\na standard format for exchanging sparse matrices. Supports real, complex,\ninteger, and pattern-only matrices in assembled or elemental forms."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/CSparse/Include/cs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/UMFPACK/Source/umf_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for UMFPACK sparse LU factorization\nCopyright (c) 2005-2023, Timothy A. Davis. GPL-2.0+ license.\n\nUMFPACK is an unsymmetric multifrontal sparse LU factorization package.\nComputes P\u00b7A\u00b7Q = L\u00b7U via supernodal factorization with partial pivoting.\nHandles real and complex matrices in single and double precision."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/BTF/Include/btf_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for BTF (Block Triangular Form) permutation\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nBTF finds permutation matrices P and Q such that P\u00b7A\u00b7Q has block upper\ntriangular form with square diagonal blocks that are irreducible\n(strongly connected components). Essential preprocessing for sparse LU."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/KLU/Include/klu_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for KLU sparse LU factorization\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nKLU is a sparse LU factorization package designed for circuit simulation\nmatrices, which are typically highly sparse with near-diagonal structure.\nUses BTF (Block Triangular Form) permutation to exploit structure."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/CHOLMOD/Include/cholmod_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for CHOLMOD sparse Cholesky factorization\nCopyright (C) 2005-2023, Timothy A. Davis. Apache-2.0 license.\n\nCHOLMOD is a comprehensive sparse Cholesky factorization package supporting\nsupernodal and simplicial methods, update/downdate, and multiple orderings.\nHandles symmetric positive definite systems A\u00b7x = b via L\u00b7L' = A."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/LDL/Include/ldl.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
      }
    },
    {
      "from": "sparsity",
      "to": "SuiteSparse/ParU/Include/ParU.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Parallel unsymmetric multifrontal sparse LU factorization\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis. GPL-3.0-or-later.\n\nParU is a parallel sparse direct solver using OpenMP tasking for task-based\nparallelism combined with parallel BLAS (nested parallelism). Solves Ax = b\nfor sparse A via LU factorization with partial pivoting."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpCholeskyPardiso.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Intel MKL Pardiso sparse direct solver for Cholesky factorization\n\nWraps Intel's Pardiso solver from the Math Kernel Library (MKL) for\nCholesky factorization of normal equations in interior point methods."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpCholeskyUfl.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "SuiteSparse CHOLMOD interface for Cholesky factorization\n\nWraps the CHOLMOD library from SuiteSparse (University of Florida) for\nCholesky factorization of normal equations in interior point methods."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/AbcSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized primal simplex algorithm"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpConstraintLinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Linear constraint implementation for nonlinear extensions\n\nImplements ClpConstraint for a linear constraint: sum(a_j * x_j) = b.\nUsed with ClpSimplexNonlinear when linear constraints appear alongside\nnonlinear objective or other nonlinear constraints."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpDummyMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Placeholder matrix with dimensions but no data\n\nImplements ClpMatrixBase with only dimensions (rows, columns, elements)\nbut no actual matrix data. Used primarily with ClpPdco where the user\nprovides custom matrix-vector products via callbacks."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpCholeskyMumps.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MUMPS sparse direct solver interface for Cholesky factorization\n\nWraps the MUMPS (MUltifrontal Massively Parallel sparse direct Solver)\nlibrary for Cholesky factorization of normal equations in interior point."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpConstraint.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for nonlinear constraints\n\nDefines the interface for general (potentially nonlinear) constraints\nused in nonlinear programming extensions. The standard LP constraints\n(Ax \u2264 b) are handled directly by ClpModel; this class is for more\ngeneral constraint forms g(x) \u2264 0."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/AbcSimplexFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization wrapper for ABC simplex"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/CoinAbcDenseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for ABC factorization and dense submatrix handling"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpCholeskyBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cholesky factorization base class for interior point methods\n\nProvides Cholesky factorization of the normal equations matrix A*D*A'\nused in predictor-corrector interior point methods. The factorization\nuses AMD ordering to reduce fill-in.\n\nThe base class provides a simple sparse Cholesky implementation with\nsupernodal dense blocks. Derived classes can interface to more\nsophisticated factorizations (MUMPS, Pardiso, TAUCS, etc.).\n\nKey methods:\n- order(): Compute fill-reducing ordering (AMD by default)\n- symbolic(): Set up sparsity structure of factor\n- factorize(): Numeric factorization of A*D*A'\n- solve(): Solve system using computed factors"
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/ClpCholeskyWssmp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "WSSMP sparse direct solver interface for Cholesky factorization\n\nWraps IBM's Watson Sparse Matrix Package (WSSMP) for Cholesky factorization\nof normal equations in interior point methods."
      }
    },
    {
      "from": "sparsity",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "sparsity",
      "to": "CppAD/include/cppad/core/sparse_jac.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse Jacobian computation using graph coloring"
      }
    },
    {
      "from": "sparsity",
      "to": "CppAD/include/cppad/core/sparse_hes.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse Hessian computation using automatic differentiation"
      }
    },
    {
      "from": "sparsity",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "sparsity",
      "to": "qpOASES/include/qpOASES/ConstraintProduct.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User-defined constraint evaluation interface for structured matrices"
      }
    },
    {
      "from": "sparsity",
      "to": "qpOASES/include/qpOASES/SparseSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse linear solver interfaces for Schur-complement QP method"
      }
    },
    {
      "from": "sparsity",
      "to": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse QP solver using Schur complement for active-set updates"
      }
    },
    {
      "from": "sparsity",
      "to": "qpOASES/include/qpOASES/SQProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
      }
    },
    {
      "from": "sparsity",
      "to": "qpOASES/include/qpOASES/Matrices.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix classes for QP data with working-set-aware operations"
      }
    },
    {
      "from": "sparsity",
      "to": "ADOL-C/ADOL-C/include/adolc/sparse/sparsedrivers.h",
      "type": "implemented_in",
      "meta": {
        "brief": "High-level drivers for sparse Jacobian and Hessian computation\n\nProvides efficient computation of sparse derivatives by exploiting\nsparsity structure using graph coloring and compressed computation."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Interfaces/IpTNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User interface for defining NLP problems in standard form\n\nTNLP (Templated NLP) is the primary user-facing class for defining\noptimization problems. Users inherit from TNLP and implement:"
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/IpLeastSquareMults.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Least-squares estimation of equality constraint multipliers\n\nLeastSquareMultipliers computes initial estimates for the equality\nconstraint multipliers y_c and y_d by solving a least-squares problem.\n\nFormulation: Find y minimizing ||\u2207_x L(x,y)||^2 where\n  \u2207_x L = \u2207f(x) + J_c^T y_c + J_d^T y_d - z_L + z_U\n\nThis is equivalent to solving the normal equations:\n  [J_c J_c^T    0    ] [y_c]   [-J_c (\u2207f - z_L + z_U)]\n  [   0     J_d J_d^T] [y_d] = [-J_d (\u2207f - z_L + z_U)]\n\nActually solved via augmented system:\n  [0  J_c^T  J_d^T] [r  ]   [\u2207f - z_L + z_U]\n  [J_c  0     0   ] [y_c] = [     0        ]\n  [J_d  0     0   ] [y_d]   [     0        ]\n\nUses AugSystemSolver to solve the linear system with W=0.\n\nUsage:\n- DefaultIterateInitializer: Initial multiplier estimates\n- MinC_1NrmRestorationPhase: Post-restoration multiplier reset"
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/IpTimingStatistics.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Collection of timing statistics for algorithm profiling\n\nTimingStatistics aggregates TimedTask objects for all major\nalgorithm components, enabling performance profiling and\nbottleneck identification.\n\nTiming categories:\n- Algorithm phases: InitializeIterates, UpdateHessian, OutputIteration,\n  UpdateBarrierParameter, ComputeSearchDirection, etc.\n- Linear system: PDSystemSolverTotal, LinearSystemFactorization,\n  LinearSystemBackSolve, LinearSystemScaling\n- NLP evaluations: f_eval_time, grad_f_eval_time, c_eval_time,\n  jac_c_eval_time, d_eval_time, jac_d_eval_time, h_eval_time\n- Auxiliary: Task1-Task6 for ad-hoc profiling\n\nKey methods:\n- ResetTimes(): Clear all accumulated times\n- EnableTimes()/DisableTimes(): Control timing overhead\n- PrintAllTimingStatistics(): Output formatted timing report\n- TotalFunctionEvaluationCpuTime(): Sum of NLP evaluation times\n\nEach TimedTask tracks CPU time, system time, and wall-clock time."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/LinAlg/IpSumMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix representing weighted sum of matrices: M = sum(alpha_i * M_i)\n\nSumMatrix represents a matrix as a sum of terms, each with its own\nscalar factor: M = alpha_0*M_0 + alpha_1*M_1 + ... + alpha_n*M_n"
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/LinAlg/IpMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for all (unsymmetric) matrix types\n\nMatrix provides the abstraction for general (non-symmetric) matrices.\nPrimary operations: MultVector (y = \u03b1*A*x + \u03b2*y) and TransMultVector."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/LinAlg/IpExpandedMultiVectorMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Short-fat matrix V^T*P^T with expansion for KKT construction\n\nExpandedMultiVectorMatrix represents a k x n matrix (k << n) as\nV^T * P^T where V is a MultiVectorMatrix-like collection of row\nvectors and P is an optional ExpansionMatrix."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMc19TSymScalingMethod.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix scaling using HSL MC19 equilibration\n\nMc19TSymScalingMethod uses the HSL subroutine MC19 to compute\nequilibration scaling factors for symmetric matrices."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpWsmpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to IBM WSMP sparse symmetric direct solver\n\nWsmpSolverInterface wraps the Watson Sparse Matrix Package (WSMP),\na high-performance parallel direct solver developed at IBM for\nsparse symmetric indefinite linear systems."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa28TDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dependency detector using HSL MA28 unsymmetric solver\n\nMa28TDependencyDetector uses the unsymmetric sparse solver MA28\nto detect linearly dependent rows in the constraint Jacobian.\nUnlike the symmetric solvers, MA28 handles general rectangular\nmatrices, making it suitable for analyzing the constraint Jacobian\ndirectly.\n\nThe detection works by attempting LU factorization with threshold\npivoting. When a pivot falls below tolerance (ma28_pivtol_), the\ncorresponding row is flagged as linearly dependent.\n\nInput format: Triplet (row, col, val) for general matrices\n\nUsed by Ipopt's constraint degeneracy detection mechanism."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa77SolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA77 out-of-core sparse symmetric solver\n\nMa77SolverInterface wraps the HSL MA77 solver, designed for\nlarge-scale problems that may not fit entirely in memory."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/LinAlg/TMatrices/IpTripletHelper.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Recursive conversion of abstract matrices to triplet format\n\nTripletHelper provides static methods for extracting COO (Coordinate)\nsparse format from Ipopt's abstract Matrix hierarchy. Used to interface\nwith external linear solvers expecting triplet format."
      }
    },
    {
      "from": "sparsity",
      "to": "Ipopt/src/LinAlg/TMatrices/IpGenTMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "General sparse matrix in triplet (COO) format\n\nGenTMatrix stores a general (non-symmetric) sparse matrix using\ntriplet/coordinate format: three arrays for row indices, column\nindices, and values."
      }
    },
    {
      "from": "sparsity",
      "to": "Bcp/Applications/Csp/include/CSP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cutting stock problem definitions"
      }
    },
    {
      "from": "sparsity",
      "to": "Bcp/Bcp/src/include/BCP_matrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix and vector representations for BCP LP relaxation"
      }
    },
    {
      "from": "sparsity",
      "to": "Bonmin/src/Interfaces/BonTMINLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
      }
    },
    {
      "from": "sparsity",
      "to": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "sparsity",
      "to": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic expression with alpha-convexification"
      }
    },
    {
      "from": "sparsity",
      "to": "Gravity/include/gravity/func.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Expression functions with automatic differentiation and convexity tracking\n\nThe func class represents mathematical expressions with symbolic analysis."
      }
    },
    {
      "from": "sparsity",
      "to": "Gravity/include/gravity/model.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
      }
    },
    {
      "from": "sparsity",
      "to": "HiGHS/highs/simplex/HEkk.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
      }
    },
    {
      "from": "sparsity",
      "to": "HiGHS/highs/simplex/HEkkPrimal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Phase 2 primal simplex solver for HiGHS"
      }
    },
    {
      "from": "sparsity",
      "to": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
      }
    },
    {
      "from": "sparsity",
      "to": "SHOT/src/Model/Problem.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinBronKerbosch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bron-Kerbosch Algorithm for maximal clique enumeration"
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interfaces for warm start information in optimization solvers"
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinSimpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinOslFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinDenseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinSort.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sorting utilities for pairs, triples, and parallel arrays\n\nProvides CoinPair, CoinTriple, and sort functions for sorting\nmultiple related arrays together (e.g., indices and values)."
      }
    },
    {
      "from": "simplex_method",
      "to": "CoinUtils/src/CoinWarmStartBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/ParU/Source/paru_internal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal data structures and functions for ParU sparse LU\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis.\nGPL-3.0-or-later license.\n\nCore ParU structures: ParU_Symbolic_struct (row-form S, singletons, fronts,\ntask tree), ParU_Numeric_struct (LU factors, permutations, scaling),\nParU_Control_struct (tolerances, threading). paru_element (contribution\nblock), paru_work (workspace), paru_tuple (element lists). Internal\nfunctions: front assembly/factorization, heap management, BLAS threading.\nIncludes UMFPACK SymbolicType/SWType for singleton detection."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/AMD/Include/amd.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Approximate Minimum Degree ordering for sparse matrix factorization\n\nAMD computes a fill-reducing permutation P for sparse Cholesky or LU\nfactorization. Given a symmetric matrix A (or A+A' if A is unsymmetric),\nAMD finds P such that P*A*P' has fewer nonzeros in its Cholesky factor\nthan A would."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/UMFPACK/Include/umfpack.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/UMFPACK/Source/umf_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for UMFPACK sparse LU factorization\nCopyright (c) 2005-2023, Timothy A. Davis. GPL-2.0+ license.\n\nUMFPACK is an unsymmetric multifrontal sparse LU factorization package.\nComputes P\u00b7A\u00b7Q = L\u00b7U via supernodal factorization with partial pivoting.\nHandles real and complex matrices in single and double precision."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/KLU/Include/klu.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse LU factorization optimized for circuit simulation matrices\n\nKLU computes a sparse LU factorization of a square matrix A:\n  P*A*Q = L*U\nwhere P and Q are permutation matrices, L is unit lower triangular,\nand U is upper triangular.\n\nKLU is specifically designed for matrices arising from circuit simulation,\nwhich tend to be sparse and nearly block-triangular. The factorization\nproceeds in three phases:\n1. klu_analyze: BTF pre-ordering + fill-reducing ordering (AMD/COLAMD)\n2. klu_factor: Numerical LU factorization (left-looking, column-by-column)\n3. klu_solve: Forward/back substitution to solve Ax = b"
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/KLU/Include/klu_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for KLU sparse LU factorization\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nKLU is a sparse LU factorization package designed for circuit simulation\nmatrices, which are typically highly sparse with near-diagonal structure.\nUses BTF (Block Triangular Form) permutation to exploit structure."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/CHOLMOD/Include/cholmod_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for CHOLMOD sparse Cholesky factorization\nCopyright (C) 2005-2023, Timothy A. Davis. Apache-2.0 license.\n\nCHOLMOD is a comprehensive sparse Cholesky factorization package supporting\nsupernodal and simplicial methods, update/downdate, and multiple orderings.\nHandles symmetric positive definite systems A\u00b7x = b via L\u00b7L' = A."
      }
    },
    {
      "from": "simplex_method",
      "to": "SuiteSparse/ParU/Include/ParU.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Parallel unsymmetric multifrontal sparse LU factorization\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis. GPL-3.0-or-later.\n\nParU is a parallel sparse direct solver using OpenMP tasking for task-based\nparallelism combined with parallel BLAS (nested parallelism). Solves Ax = b\nfor sparse A via LU factorization with partial pivoting."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for ABC dual simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpGubMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpNonLinearCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Piecewise linear cost handling and bound infeasibility tracking\n\nManages piecewise linear objective functions and tracks bound violations\nduring primal simplex. When variables move outside their bounds, this class\ncomputes the appropriate infeasibility penalty costs."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpCholeskyPardiso.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Intel MKL Pardiso sparse direct solver for Cholesky factorization\n\nWraps Intel's Pardiso solver from the Math Kernel Library (MKL) for\nCholesky factorization of normal equations in interior point methods."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpCholeskyUfl.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "SuiteSparse CHOLMOD interface for Cholesky factorization\n\nWraps the CHOLMOD library from SuiteSparse (University of Florida) for\nCholesky factorization of normal equations in interior point methods."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized primal simplex algorithm"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpNetworkMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Specialized matrix for pure network LP problems\n\nImplements efficient storage for network flow problems where each column\n(arc) has exactly two nonzeros: +1 at the head node and -1 at the tail node.\nThis representation requires only O(n) storage for row indices vs O(2n) for\na general sparse matrix."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPEPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced Dantzig pricing for primal simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPEPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced steepest edge for primal simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Algorithm selection and configuration for ClpSimplex::initialSolve()"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended warm start with factorization caching for ABC"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/CoinAbcCommon.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Common definitions for ABC (A Better Coin) optimized simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpCholeskyWssmpKKT.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "WSSMP solver for KKT system (augmented system) formulation\n\nVariant of ClpCholeskyWssmp that solves the KKT/augmented system directly\ninstead of forming and factoring the normal equations A*D*A'."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpCholeskyMumps.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MUMPS sparse direct solver interface for Cholesky factorization\n\nWraps the MUMPS (MUltifrontal Massively Parallel sparse direct Solver)\nlibrary for Cholesky factorization of normal equations in interior point."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcCommon.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Configuration macros for ABC (A Better Clp) build modes"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpEventHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Callback interface for handling solver events during optimization\n\nProvides a mechanism for user code to receive callbacks during the solve\nprocess. Users derive from ClpEventHandler and override event() to handle\nevents like end of iteration, factorization, or presolve stages."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized dual simplex algorithm"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standalone Clp solver driver and command-line interface"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplexOther.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Auxiliary simplex operations: ranging, parametrics, and utilities"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex for ABC primal simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpSimplexNonlinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for ABC dual simplex pivot selection"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpNetworkBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Specialized factorization for pure network problems"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPrimalColumnPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpDualRowPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/CoinAbcDenseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for ABC factorization and dense submatrix handling"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPEDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced Dantzig pricing for dual simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPEDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced steepest edge for dual simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/ClpPESimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge anti-degeneracy framework for simplex"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/AbcPrimalColumnPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for primal pivot column selection in ABC"
      }
    },
    {
      "from": "simplex_method",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Osi/src/Osi/OsiRowCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
      }
    },
    {
      "from": "simplex_method",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "simplex_method",
      "to": "qpOASES/include/qpOASES/SparseSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse linear solver interfaces for Schur-complement QP method"
      }
    },
    {
      "from": "simplex_method",
      "to": "qpOASES/include/qpOASES/Constraints.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Working set management for general constraints in active-set QP"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cbc/src/CbcSolverHeuristics.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Heuristic setup and execution routines for cbc-generic"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cbc/src/CbcHeuristicPivotAndFix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Pivot and Fix heuristic using simplex pivots\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicPivotAndFix: Exploits LP basis structure.\nPerforms simplex pivots to explore nearby basic solutions,\nthen fixes integer variables at their current values."
      }
    },
    {
      "from": "simplex_method",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cgl/src/CglRedSplit/CglRedSplit.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Reduce-and-Split cuts for enhanced Gomory generation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cgl/src/CglLandP/CglLandP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Lift-and-Project cuts via simplex pivoting"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex algorithm for Lift-and-Project cut generation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Cgl/src/CglBKClique/CglBKClique.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clique cut separator using Bron-Kerbosch algorithm"
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/LinAlg/IpDenseGenMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense general (non-symmetric) matrix with linear algebra operations\n\nDenseGenMatrix stores elements in column-major (Fortran) format\nand provides direct factorization capabilities:\n- Cholesky factorization (for positive definite matrices)\n- LU factorization with pivoting (for general matrices)\n- Forward/back substitution solves"
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/LinAlg/IpLapack.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "C++ wrappers for LAPACK (Linear Algebra PACKage) routines\n\nProvides platform-independent access to LAPACK for dense matrices."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoMKLSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to Intel MKL PARDISO sparse solver\n\nPardisoMKLSolverInterface wraps Intel's MKL implementation of PARDISO.\nWhile sharing the same API as pardiso-project.org's version, Intel MKL\nPARDISO has some differences in features and behavior."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMc19TSymScalingMethod.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix scaling using HSL MC19 equilibration\n\nMc19TSymScalingMethod uses the HSL subroutine MC19 to compute\nequilibration scaling factors for symmetric matrices."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpWsmpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to IBM WSMP sparse symmetric direct solver\n\nWsmpSolverInterface wraps the Watson Sparse Matrix Package (WSMP),\na high-performance parallel direct solver developed at IBM for\nsparse symmetric indefinite linear systems."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMumpsSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to MUMPS parallel sparse direct solver\n\nMumpsSolverInterface wraps MUMPS (MUltifrontal Massively Parallel\nsparse direct Solver), a freely available solver supporting MPI\nparallelism for distributed memory systems."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTSymScalingMethod.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for matrix scaling in triplet format\n\nTSymScalingMethod is the abstract base class for computing diagonal\nscaling factors for symmetric matrices. Scaling improves numerical\nconditioning of the linear system.\n\nScaling transformation:\n  Original: A * x = b\n  Scaled:   (D*A*D) * (D^{-1}*x) = D*b\nwhere D = diag(scaling_factors).\n\nThe ComputeSymTScalingFactors method takes:\n- n: matrix dimension\n- nnz: number of nonzeros\n- airn, ajcn: row/column indices (triplet format)\n- a: matrix values\n- scaling_factors: output array of length n\n\nImplementations:\n- Mc19TSymScalingMethod: HSL MC19 equilibration\n- SlackBasedTSymScalingMethod: Simple slack-based scaling"
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSpralSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to SPRAL SSIDS sparse symmetric solver\n\nSpralSolverInterface wraps SPRAL (Sparse Parallel Robust Algorithms\nLibrary), an open-source alternative to HSL solvers developed by\nSTFC RAL. SSIDS is SPRAL's symmetric indefinite direct solver."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa86SolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA86 parallel sparse symmetric solver\n\nMa86SolverInterface wraps the HSL MA86 solver, a DAG-based\nparallel direct solver for symmetric indefinite systems."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa28TDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dependency detector using HSL MA28 unsymmetric solver\n\nMa28TDependencyDetector uses the unsymmetric sparse solver MA28\nto detect linearly dependent rows in the constraint Jacobian.\nUnlike the symmetric solvers, MA28 handles general rectangular\nmatrices, making it suitable for analyzing the constraint Jacobian\ndirectly.\n\nThe detection works by attempting LU factorization with threshold\npivoting. When a pivot falls below tolerance (ma28_pivtol_), the\ncorresponding row is flagged as linearly dependent.\n\nInput format: Triplet (row, col, val) for general matrices\n\nUsed by Ipopt's constraint degeneracy detection mechanism."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTSymDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dependency detection using symmetric linear solver\n\nTSymDependencyDetector detects linearly dependent constraint rows\nby using a TSymLinearSolver that provides degeneracy detection.\n\nMethod:\nSome symmetric linear solvers (e.g., MA57 via ProvidesDegeneracyDetection)\ncan identify dependent rows during factorization. This class\nleverages that capability.\n\nAlgorithm:\n1. Form symmetric matrix J*J^T (or equivalent structure)\n2. Attempt factorization with the TSymLinearSolver\n3. If solver detects singularity, query dependent row indices\n4. Return list of dependent rows in c_deps\n\nRequirements:\n- The underlying linear solver must implement\n  ProvidesDegeneracyDetection() returning true\n- Must implement DetermineDependentRows() for the sparse format\n\nThis is preferred over MA28-based detection when using a solver\nthat already provides this capability."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa57TSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA57 sparse symmetric indefinite solver\n\nMa57TSolverInterface wraps the Harwell MA57 subroutine, an improved\nmultifrontal solver over MA27 with better memory management and\nnumerical stability."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpIterativeWsmpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to IBM WSMP iterative (WISMP) solver\n\nIterativeWsmpSolverInterface wraps the iterative variant of WSMP\n(called WISMP), which uses incomplete LU factorization as a\npreconditioner for iterative refinement."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to PARDISO sparse solver from pardiso-project.org\n\nPardisoSolverInterface wraps the PARDISO solver distributed by\npardiso-project.org (not to be confused with Intel MKL's PARDISO).\nPARDISO is a high-performance parallel direct solver for sparse\nsymmetric indefinite systems."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa27TSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA27 sparse symmetric indefinite solver\n\nMa27TSolverInterface wraps the Harwell MA27 subroutine for solving\nsparse symmetric indefinite linear systems using multifrontal\nfactorization with threshold pivoting."
      }
    },
    {
      "from": "simplex_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa97SolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA97 modern parallel sparse symmetric solver\n\nMa97SolverInterface wraps the HSL MA97 solver, the most modern\nHSL solver for symmetric indefinite systems with advanced\nparallelism and scaling strategies."
      }
    },
    {
      "from": "simplex_method",
      "to": "Bcp/Applications/MaxCut/include/MC_lp_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Max-cut LP parameters"
      }
    },
    {
      "from": "simplex_method",
      "to": "Bcp/Applications/Csp/include/CSP_lp_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "CSP LP parameters"
      }
    },
    {
      "from": "simplex_method",
      "to": "Bcp/Bcp/src/include/BCP_warmstart_basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BCP warm start basis implementation"
      }
    },
    {
      "from": "simplex_method",
      "to": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP warm start information for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "simplex_method",
      "to": "Dip/Dip/src/DecompCut.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut representation in original x-space\n\nDecompCut represents a cutting plane (valid inequality) that can be\nadded to strengthen the formulation. Cuts are defined in original\nx-space and expanded to the master problem."
      }
    },
    {
      "from": "simplex_method",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/qpsolver/devexpricing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS Devex pricing for QP active set method\n\nDevex pricing strategy: approximate steepest edge using\nreference framework with periodic weight updates."
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/simplex/HEkkPrimal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Phase 2 primal simplex solver for HiGHS"
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/simplex/HEkkDual.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
      }
    },
    {
      "from": "simplex_method",
      "to": "HiGHS/highs/ipm/ipx/kkt_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
      }
    },
    {
      "from": "bound_tightening",
      "to": "CoinUtils/src/CoinDynamicConflictGraph.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "CoinConflictGraph implementation which supports modifications."
      }
    },
    {
      "from": "bound_tightening",
      "to": "CoinUtils/src/CoinPresolveTighten.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds using constraint propagation"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Clp/src/ClpPresolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clp interface to CoinPresolve for LP preprocessing"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Osi/src/Osi/OsiPresolve.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OSI interface to problem simplification (presolve)\n\nPresolve reduces problem size before solving by applying\ntransformations that preserve optimal solutions:\n- Singleton row/column removal\n- Bound tightening\n- Coefficient reduction\n- Duplicate row/column detection"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Osi/src/Osi/OsiColCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Column-based cuts for variable bound tightening\n\nColumn cuts represent bound changes on variables rather than\nadding new constraints. They are used for:\n- Bound tightening from probing\n- Implication-based bound strengthening\n- Reduced cost fixing"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Cbc/src/CbcObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for branching entities (variables, SOS, etc.)"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Cbc/src/CbcHeuristicDiveVectorLength.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic based on constraint participation\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveVectorLength: Selects variables by column density.\nVariables appearing in many constraints are fixed first."
      }
    },
    {
      "from": "bound_tightening",
      "to": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
      }
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/src/branch/CouenneSOSObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Special Ordered Set (SOS) branching for Couenne"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fixpoint-based bound tightening via constraint propagation\n\nImplements Feasibility-Based Bound Tightening (FBBT) using fixpoint\niteration. Propagates bounds through expression DAG until no further\ntightening is possible."
      }
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/src/bound_tightening/CouenneMultiVarProbe.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Multi-variable probing for bound tightening"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/src/bound_tightening/CouenneAggrProbing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Aggressive probing for bound tightening\n\nImplements Optimality-Based Bound Tightening (OBBT) through aggressive\nprobing. Temporarily fixes a variable bound and solves the resulting\nsubproblem to determine if a tighter bound is achievable."
      }
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/src/problem/CouenneProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
      }
    },
    {
      "from": "bound_tightening",
      "to": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bound tightening from pairs of linear constraints"
      }
    },
    {
      "from": "bound_tightening",
      "to": "Gravity/include/gravity/expr.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Expression tree nodes for unary and binary operations\n\nExpressions are the building blocks for functions and constraints."
      }
    },
    {
      "from": "bound_tightening",
      "to": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
      }
    },
    {
      "from": "bound_tightening",
      "to": "SHOT/src/Tasks/TaskPerformBoundTightening.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds via optimization\n\nUses optimization-based bound tightening (OBBT).\n\n**TaskPerformBoundTightening Class:**\n- POASolver: Polyhedral outer approximation solver\n- createPOA(): Build relaxed problem for bound tightening\n\n**OBBT Algorithm:**\n- For each variable: min/max subject to relaxation\n- Tightens bounds beyond constraint propagation\n- Improves relaxation quality"
      }
    },
    {
      "from": "interior_point_method",
      "to": "CoinUtils/src/CoinWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interfaces for warm start information in optimization solvers"
      }
    },
    {
      "from": "interior_point_method",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Waterdance.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Alternating FM/QP refinement passes for partition improvement\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nWaterdance alternates between FM (discrete swaps) and QP (continuous\noptimization) refinement passes. The interplay (\"dance\") between methods\nescapes local minima that either method alone would get stuck in.\nNumber of dances controlled by num_dances option."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Clp/src/ClpDummyMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Placeholder matrix with dimensions but no data\n\nImplements ClpMatrixBase with only dimensions (rows, columns, elements)\nbut no actual matrix data. Used primarily with ClpPdco where the user\nprovides custom matrix-vector products via callbacks."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Clp/src/ClpPdcoBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for PDCO problem customization\n\nStrategy pattern interface for defining custom convex objectives in PDCO."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Clp/src/ClpSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standalone Clp solver driver and command-line interface"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Clp/src/ClpModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Clp/src/ClpCholeskyBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cholesky factorization base class for interior point methods\n\nProvides Cholesky factorization of the normal equations matrix A*D*A'\nused in predictor-corrector interior point methods. The factorization\nuses AMD ordering to reduce fill-in.\n\nThe base class provides a simple sparse Cholesky implementation with\nsupernodal dense blocks. Derived classes can interface to more\nsophisticated factorizations (MUMPS, Pardiso, TAUCS, etc.).\n\nKey methods:\n- order(): Compute fill-reducing ordering (AMD by default)\n- symbolic(): Set up sparsity structure of factor\n- factorize(): Numeric factorization of A*D*A'\n- solve(): Solve system using computed factors"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpMonotoneMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard monotone barrier parameter update strategy\n\nMonotoneMuUpdate implements the classical IPM approach where the\nbarrier parameter mu is reduced monotonically as the subproblem\nconverges.\n\nUpdate rule:\n1. Solve barrier subproblem to tolerance barrier_tol_factor_ * mu\n2. Reduce mu: new_mu = max(mu_target_, min(kappa_mu * mu, mu^theta_mu))\n   where kappa_mu = mu_linear_decrease_factor_\n   and theta_mu = mu_superlinear_decrease_power_\n3. Update tau (fraction-to-boundary): tau = max(tau_min_, 1 - mu)\n\nKey parameters:\n- mu_init_: Initial barrier parameter\n- mu_linear_decrease_factor_: Linear decrease factor kappa_mu\n- mu_superlinear_decrease_power_: Superlinear power theta_mu\n- tau_min_: Minimum fraction-to-boundary parameter\n- mu_target_: Target mu for termination\n\nFast decrease heuristic:\n- mu_allow_fast_monotone_decrease_: Allow faster decrease when\n  complementarity is already small\n\nInteractions:\n- Calls linesearch_->Reset() when mu changes\n- Filter is cleared on barrier parameter update"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpOrigIterationOutput.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard iteration output for original NLP problem\n\nOrigIterationOutput displays the per-iteration summary line\nfor the original (non-restoration) NLP problem."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpRestoRestoPhase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Recursive restoration for separable n,p variable initialization\n\nRestoRestorationPhase provides a specialized \"restoration within\nrestoration\" procedure for the MinC_1NrmRestorationPhase. It computes\noptimal values for the slack variables (n_c, p_c, n_d, p_d) by\ntreating them as separable from x and s."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for suggesting barrier parameter values\n\nMuOracle is the abstract interface for components that compute\nsuggested values for the barrier parameter mu in adaptive (non-monotone)\nbarrier updates."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpRestoIpoptNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "IpoptNLP adapter for restoration phase feasibility problem\n\nRestoIpoptNLP transforms the original NLP into a feasibility problem\nfor the restoration phase. It introduces slack variables to allow\nconstraint violations and penalizes them in the objective."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpWarmStartIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Warm start initialization from previous solution\n\nWarmStartIterateInitializer initializes IPM iterates from a\npreviously computed solution, enabling faster convergence for\nrelated problems (e.g., MPC, parametric optimization).\n\nWarm start sources:\n- warm_start_entire_iterate_: Use GetWarmStartIterate() from NLP\n- Otherwise: Use initialization vectors from NLP\n\nProcessing steps:\n1. Push primals away from bounds (warm_start_bound_push/frac_)\n2. Push slacks (warm_start_slack_bound_push/frac_)\n3. Clip multipliers (warm_start_mult_init_max_)\n4. Ensure bound multipliers positive (warm_start_mult_bound_push_)\n\nTarget mu adjustment (warm_start_target_mu_):\n- Adjusts slack/multiplier pairs toward target complementarity\n- process_target_mu(): Scales to achieve s*z \u2248 target_mu\n- adapt_to_target_mu(): Fine-tunes pairing\n\nKey parameters:\n- warm_start_bound_push_: Absolute bound push\n- warm_start_bound_frac_: Relative bound push\n- warm_start_mult_init_max_: Maximum multiplier magnitude\n- warm_start_target_mu_: Target barrier parameter"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpLoqoMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LOQO formula for barrier parameter selection\n\nLoqoMuOracle computes the barrier parameter using the heuristic\nfrom the LOQO solver (Vanderbei). This provides a simple formula\nbased on current complementarity.\n\nThe LOQO formula typically uses:\n  sigma = min(0.1, 100*mu)\n  mu_new = sigma * (current_complementarity / n)\n\nThis is a simple, stateless oracle that doesn't require solving\nan additional linear system (unlike probing or quality function).\n\nCompared to other strategies:\n- ProbingMuOracle: Requires affine step computation\n- QualityFunctionMuOracle: Requires 1D optimization\n- LoqoMuOracle: Direct formula, no extra computation"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpRestoMinC_1Nrm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Restoration phase minimizing 1-norm of constraint violation\n\nMinC_1NrmRestorationPhase is the main restoration phase implementation.\nWhen the line search cannot make progress, it minimizes constraint\nviolation to find a feasible point from which optimization can continue.\n\nRestoration NLP formulation:\n  min  \u03c1 * ||[p_c; n_c; p_d; n_d]||_1 + (\u03b7/2) * ||D_r(x - x_ref)||_2^2\n  s.t. c(x) - p_c + n_c = 0\n       d_L <= d(x) - p_d + n_d <= d_U\n       x_L <= x <= x_U\n       p_c, n_c, p_d, n_d >= 0\n\nWhere:\n- \u03c1: Penalty on infeasibility (resto_penalty_parameter)\n- \u03b7: Proximity weight (resto_proximity_weight * sqrt(mu))\n- D_r: Diagonal scaling based on reference point\n- x_ref: Starting point for restoration\n\nKey behaviors:\n- Uses nested IpoptAlgorithm to solve restoration NLP\n- eq_mult_calculator_ reinitializes multipliers after restoration\n- bound_mult_reset_threshold_: Limits post-restoration bound multipliers\n- count_restorations_: Tracks restoration phase calls"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpBacktrackingLineSearch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "General backtracking line search with filter/restoration support\n\nBacktrackingLineSearch is the main LineSearch implementation,\nproviding a flexible framework for globalization strategies:\n\nCore algorithm:\n1. Start with full step alpha = alpha_max (fraction-to-boundary)\n2. Test acceptability via BacktrackingLSAcceptor\n3. If rejected, reduce alpha *= alpha_red_factor and retry\n4. If alpha becomes too small, trigger restoration phase\n\nAdvanced features:\n- Watchdog mechanism: Accept poor steps temporarily to escape local minima\n- Second-order correction (SOC): Improve constraint satisfaction\n- Soft restoration phase: Accept steps that reduce primal-dual error\n- Magic steps: Improve slack/bound multiplier pairing\n- Corrector steps: Improve local convergence rate\n\nKey parameters:\n- alpha_for_y: How to step in equality multipliers\n- watchdog_trial_iter_max: Watchdog iteration limit\n- max_soc: Maximum second-order corrections"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpRestoPhase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for restoration phase fallback\n\nRestorationPhase is the abstract base for the fallback mechanism\nwhen the line search cannot make progress. The restoration phase\nminimizes constraint violation to find a feasible point.\n\nTriggered when:\n- Line search step size becomes too small\n- No search direction can be computed (singular KKT system)\n- Algorithm explicitly requests fallback (ActivateFallbackMechanism)\n\nExceptions thrown on restoration failure:\n- RESTORATION_CONVERGED_TO_FEASIBLE_POINT: Success, found feasible point\n- RESTORATION_FAILED: Could not reduce infeasibility\n- RESTORATION_MAXITER_EXCEEDED: Hit iteration limit\n- RESTORATION_USER_STOP: User callback requested stop\n\nMain implementation: RestoIterationOutput minimizes ||c(x)||^2 + ||d(x)-s||^2\nusing the interior point method on a modified feasibility problem."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpFilterLSAcceptor.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Filter line search acceptor using W\u00e4chter-Biegler method\n\nFilterLSAcceptor implements the filter globalization strategy where\nstep acceptance is based on improvement in either constraint violation\n(theta) or barrier objective (phi).\n\nAcceptance criteria:\n- Armijo sufficient decrease in barrier function, OR\n- Sufficient reduction in constraint violation (switching condition)\n- Point must be acceptable to current filter\n\nKey parameters:\n- theta_max_fact_: Upper bound factor on infeasibility\n- gamma_phi_, gamma_theta_: Margin parameters for filter\n- eta_phi_: Armijo parameter\n- s_phi_, s_theta_: Exponents in switching condition\n\nSecond-order correction (SOC):\n- When step is rejected, solves for constraint linearization error\n- Up to max_soc_ corrections tried\n- kappa_soc_ controls required constraint reduction between SOCs\n\nCorrector steps:\n- Affine or primal-dual corrector for fast local convergence\n- Applied even when step is acceptable\n\nFilter management:\n- Dominated entries removed on filter augmentation\n- Filter reset heuristic when repeatedly rejected by filter"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpRestoConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for restoration phase convergence checking\n\nRestoConvergenceCheck extends OptimalityErrorConvergenceCheck for\nthe restoration phase, adding termination criteria based on\nacceptability to the original problem's globalization mechanism."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpDefaultIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard initialization procedure for IPM iterates\n\nDefaultIterateInitializer computes starting points for all primal\nand dual variables based on user options and problem bounds.\n\nPrimal initialization (x, s):\n- Start from user-provided x0 or NLP default\n- Push away from bounds: x_new = max(x_L + \u03b5, min(x, x_U - \u03b5))\n- bound_push_, bound_frac_: Absolute/relative push parameters\n- least_square_init_primal_: Fit linearized constraints\n\nDual initialization:\n- Equality multipliers (y_c, y_d): Least-squares or zero\n- eq_mult_calculator_: Computes min ||y|| s.t. KKT gradient\n- constr_mult_init_max_: Reject large multiplier estimates\n- Bound multipliers (z_L, z_U, v_L, v_U):\n  - B_CONSTANT: bound_mult_init_val_\n  - B_MU_BASED: mu_init_ / slack\n\nWarm start:\n- warm_start_init_point_: Use warm_start_initializer_ instead\n- Delegates to WarmStartIterateInitializer\n\nStatic utilities:\n- push_variables(): Move point away from bounds\n- least_square_mults(): Compute y from gradient conditions"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for updating barrier parameter mu\n\nMuUpdate is the abstract base for strategies that determine the\nbarrier parameter mu and fraction-to-boundary parameter tau for\neach iteration of the interior point method."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpAdaptiveMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adaptive (non-monotone) barrier parameter update strategy\n\nAdaptiveMuUpdate implements the free-mode/fixed-mode approach for\nbarrier parameter updates. In free mode, mu is computed adaptively\neach iteration. In fixed mode, monotone decrease is enforced.\n\nTwo operating modes:\n- Free mode: MuOracle suggests mu (e.g., Mehrotra predictor-corrector\n  or quality function minimization). Allows temporary mu increases.\n- Fixed mode: Monotone decrease enforced. Triggered when free mode\n  fails to make sufficient progress.\n\nGlobalization strategies (adaptive_mu_globalization_):\n- KKT_ERROR: Track reduction in primal-dual KKT error\n- FILTER_OBJ_CONSTR: Use filter on (theta, phi)\n- NEVER_MONOTONE_MODE: Always stay in free mode\n\nFree mode oracles (via MuOracle):\n- QualityFunctionMuOracle: Minimize quality function\n- ProbingMuOracle: Try candidate mu values\n- LoqoMuOracle: LOQO-style adaptive rule\n\nFixed mode behavior:\n- Uses fix_mu_oracle_ or average complementarity\n- restore_accepted_iterate_: Can restore last good free-mode point\n\nReference value tracking:\n- refs_vals_: List of recent KKT error values\n- refs_red_fact_: Required reduction factor\n- num_refs_max_: Maximum stored references"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpIterationOutput.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for per-iteration output display\n\nIterationOutput is the abstract base for strategies that produce\nthe iteration summary line and optional detailed output.\n\nStandard output line (from OrigIterationOutput):\n  iter  objective   inf_pr   inf_du   lg(mu)  ||d||  lg(rg) alpha_du alpha_pr ls\n\nInfPrOutput enum controls whether inf_pr shows internal (with slacks)\nor original NLP constraint violation.\n\nImplementations:\n- OrigIterationOutput: Standard one-line summary for original problem\n- RestoIterationOutput: Output during restoration phase\n\nOutput controlled by print_level option (0-12)."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpIpoptData.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central storage for all iteration data in Ipopt\n\nIpoptData holds the algorithmic state across iterations:\n- curr_: Current iterate (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\n- trial_: Trial point from line search\n- delta_: Search direction from KKT solve\n- delta_aff_: Affine-scaling step (for Mehrotra predictor-corrector)\n- W_: Hessian or Hessian approximation"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpAlgStrategy.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for all pluggable algorithm components\n\nAlgorithmStrategyObject is the abstract base for Ipopt's Strategy pattern\nimplementation. All pluggable algorithm components inherit from this:\n- LineSearch, MuUpdate, ConvergenceCheck\n- SearchDirectionCalculator, HessianUpdater\n- PDSystemSolver, AugSystemSolver"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/LinAlg/IpVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for all vector types in Ipopt\n\nVector is the foundation of Ipopt's linear algebra abstraction.\nProvides BLAS-1 style operations (Copy, Scal, Axpy, Dot, Nrm2, etc.)\nplus IPM-specific operations (AddOneVector, FracToBound, etc.)."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/LinAlg/IpCompoundVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Composite vector stacking multiple sub-vectors\n\nCompoundVector implements the Composite pattern for vectors,\nrepresenting: x_compound = [x_0; x_1; ...; x_{n-1}]"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/contrib/CGPenalty/IpPiecewisePenalty.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Piecewise linear penalty function (PLPF) data structure"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSlackBasedTSymScalingMethod.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple scaling based on current slack values\n\nSlackBasedTSymScalingMethod computes scaling factors using only\nthe current slack values, without requiring external HSL routines.\nDesigned for use with inexact/iterative linear solvers.\n\nUnlike MC19 which performs full equilibration, this method uses\na simpler heuristic based on:\n- Current slack variable values s\n- Diagonal elements of the KKT system\n\nBenefits:\n- No external library dependencies\n- Lightweight computation\n- Suitable when full equilibration is unnecessary\n\nLimitations:\n- May not achieve as good conditioning as MC19\n- Best for problems where slacks dominate scaling needs"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
      }
    },
    {
      "from": "interior_point_method",
      "to": "Bcp/Bcp/src/include/BCP_warmstart_primaldual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal-dual warm start for BCP"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP warm start information for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Iterative rounding heuristic for nonconvex MINLP"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Gravity/include/gravity/IpoptProgram.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt solver interface implementing TNLP callbacks\n\nAdapts Gravity models to Ipopt's TNLP (Templated NLP) interface.\n\n**IpoptProgram<type> Class:**\n- Inherits from Ipopt::TNLP and Program<type>\n- _model: Pointer to Gravity Model\n\n**Required TNLP Callbacks:**\n- get_nlp_info(): Return problem dimensions (n, m, nnz_jac, nnz_hess)\n- get_bounds_info(): Variable and constraint bounds\n- get_starting_point(): Initial x, z_L, z_U, lambda\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint values\n- eval_jac_g(): Jacobian values and structure\n- eval_h(): Hessian of Lagrangian\n- finalize_solution(): Copy solution back to model\n\n**Sparsity Pattern:**\n- First call to eval_jac_g/eval_h: return structure (iRow, jCol)\n- Subsequent calls: return values only\n- Gravity tracks via _first_call_jac, _first_call_hess\n\n**Solution Recovery:**\n- finalize_solution() copies x values to model variables\n- Retrieves dual values (lambda) for constraints\n- Retrieves bound multipliers (z_L, z_U)"
      }
    },
    {
      "from": "interior_point_method",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "interior_point_method",
      "to": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
      }
    },
    {
      "from": "interior_point_method",
      "to": "HiGHS/highs/ipm/ipx/iterate.h",
      "type": "implemented_in",
      "meta": {
        "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
      }
    },
    {
      "from": "interior_point_method",
      "to": "HiGHS/highs/ipm/ipx/crossover.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
      }
    },
    {
      "from": "interior_point_method",
      "to": "HiGHS/highs/ipm/ipx/ipm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
      }
    },
    {
      "from": "interior_point_method",
      "to": "HiGHS/highs/ipm/ipx/kkt_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
      }
    },
    {
      "from": "interior_point_method",
      "to": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
      }
    },
    {
      "from": "interior_point_method",
      "to": "SHOT/src/Solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main solver interface for convex MINLP problems\n\nPrimary entry point for the SHOT optimizer."
      }
    },
    {
      "from": "interior_point_method",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
      }
    },
    {
      "from": "interior_point_method",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyNLP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Direct NLP solver for continuous problems\n\nBypasses ESH for purely continuous NLP problems.\n\n**SolutionStrategyNLP Class:**\n- initializeStrategy(): Configure for direct NLP solve\n- solveProblem(): Single NLP solver call (Ipopt)\n\n**Use Case:**\n- Problems with no integer variables\n- Convex NLP where outer approximation is unnecessary\n- Falls back to standard NLP solvers (Ipopt)\n\n**When Selected:**\n- Problem type is NLP (no discrete variables)\n- Simpler than ESH for continuous problems"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "CoinUtils/src/CoinWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interfaces for warm start information in optimization solvers"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Clp/src/ClpNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Clp/src/AbcWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended warm start with factorization caching for ABC"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Clp/src/ClpModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Osi/src/Osi/OsiAuxInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Auxiliary information for algorithm-specific solver customization"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Osi/src/Osi/OsiChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection strategies for branch-and-bound\n\nIn MIP solving, choosing which variable to branch on significantly\naffects tree size and solve time. This file provides:\n\n- OsiChooseVariable: Base class for branching variable selection\n- OsiChooseStrong: Strong branching (evaluates candidates by solving LPs)"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Osi/src/Osi/OsiCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcGeneralDepth.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Depth-limited partial evaluation branching"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for branching entities (variables, SOS, etc.)"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Persistent information for recreating search tree nodes"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for branching actions"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree node for branch-and-cut\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcBranchToFixLots.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch to fix many variables simultaneously\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchToFixLots: Heuristic branching that fixes multiple variables\nin one branch, cutting off the current solution in the other. Useful\nfor reducing problem size when reduced costs indicate fixable variables."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcHeuristicRENS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "RENS - Relaxation Enforced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRENS: Fixes variables based on LP relaxation solution.\nUnlike RINS (which needs an incumbent), RENS works from LP alone."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Heap-based storage for live search tree nodes\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Cbc/src/CbcCompareBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for node comparison/selection"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Applications/MaxCut/include/MC_tm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Max-cut tree manager for BCP"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Applications/Mkc/include/MKC_tm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC tree manager for BCP"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Applications/Csp/include/KS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Knapsack solver for CSP column generation"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_cut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut (constraint) representation for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_tm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_tm_functions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager internal function declarations"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_process.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BCP process base class and scheduler"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_obj_change.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Delta encoding for variable/cut bound changes"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_tm_user.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User customization interface for Tree Manager process"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_var.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable representation for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_tmstorage.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BCP tree storage process"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bcp/Bcp/src/include/BCP_tm_node.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree node representation in Tree Manager"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for NLP solvers used in branch-and-bound"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Orbital branching object using symmetry"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP heuristic for near-integer B&B nodes"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Dip/Dip/src/DecompApp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "User application interface - derive to define your decomposition\n\nDecompApp is the main user-facing class. Derive from it to define:\n- Model decomposition (core vs relaxed constraints)\n- Subproblem solvers\n- Problem-specific heuristics"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Dip/Dip/src/Decomp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SYMPHONY/include/sym_master.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SYMPHONY/include/sym_lp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SYMPHONY/include/symphony.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SYMPHONY/include/sym_tm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "branch_and_bound",
      "to": "HiGHS/highs/mip/HighsMipSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-cut MIP solver"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
      }
    },
    {
      "from": "branch_and_bound",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    },
    {
      "from": "warm_start",
      "to": "CoinUtils/src/CoinWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interfaces for warm start information in optimization solvers"
      }
    },
    {
      "from": "warm_start",
      "to": "CoinUtils/src/CoinWarmStartBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
      }
    },
    {
      "from": "warm_start",
      "to": "Clp/src/AbcWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended warm start with factorization caching for ABC"
      }
    },
    {
      "from": "warm_start",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
      }
    },
    {
      "from": "warm_start",
      "to": "Clp/src/Clp_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
      }
    },
    {
      "from": "warm_start",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "warm_start",
      "to": "Cbc/src/CbcNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Persistent information for recreating search tree nodes"
      }
    },
    {
      "from": "warm_start",
      "to": "Cbc/src/CbcFullNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Complete subproblem state storage (typically for root node)"
      }
    },
    {
      "from": "warm_start",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "warm_start",
      "to": "Ipopt/src/Interfaces/IpIpoptApplication.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main application class for calling Ipopt from C++\n\nIpoptApplication is the entry point for C++ applications using Ipopt.\nProvides methods for initialization, option handling, and solving."
      }
    },
    {
      "from": "warm_start",
      "to": "Ipopt/src/Algorithm/IpIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing initial iterates\n\nIterateInitializer is the abstract base for strategies that\ncompute the starting point (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\nfor the interior point algorithm."
      }
    },
    {
      "from": "warm_start",
      "to": "Ipopt/src/Algorithm/IpWarmStartIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Warm start initialization from previous solution\n\nWarmStartIterateInitializer initializes IPM iterates from a\npreviously computed solution, enabling faster convergence for\nrelated problems (e.g., MPC, parametric optimization).\n\nWarm start sources:\n- warm_start_entire_iterate_: Use GetWarmStartIterate() from NLP\n- Otherwise: Use initialization vectors from NLP\n\nProcessing steps:\n1. Push primals away from bounds (warm_start_bound_push/frac_)\n2. Push slacks (warm_start_slack_bound_push/frac_)\n3. Clip multipliers (warm_start_mult_init_max_)\n4. Ensure bound multipliers positive (warm_start_mult_bound_push_)\n\nTarget mu adjustment (warm_start_target_mu_):\n- Adjusts slack/multiplier pairs toward target complementarity\n- process_target_mu(): Scales to achieve s*z \u2248 target_mu\n- adapt_to_target_mu(): Fine-tunes pairing\n\nKey parameters:\n- warm_start_bound_push_: Absolute bound push\n- warm_start_bound_frac_: Relative bound push\n- warm_start_mult_init_max_: Maximum multiplier magnitude\n- warm_start_target_mu_: Target barrier parameter"
      }
    },
    {
      "from": "warm_start",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
      }
    },
    {
      "from": "warm_start",
      "to": "Bcp/Bcp/src/include/BCP_warmstart_basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BCP warm start basis implementation"
      }
    },
    {
      "from": "warm_start",
      "to": "Bcp/Bcp/src/include/BCP_node_change.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Complete node delta encoding for tree storage"
      }
    },
    {
      "from": "warm_start",
      "to": "Bcp/Bcp/src/include/BCP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "warm_start",
      "to": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP warm start information for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "warm_start",
      "to": "Bcp/Bcp/src/include/BCP_USER.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User initialization and packing interface for BCP"
      }
    },
    {
      "from": "warm_start",
      "to": "Bcp/Bcp/src/include/BCP_tm_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager parameters for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "warm_start",
      "to": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
      }
    },
    {
      "from": "warm_start",
      "to": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for NLP solvers used in branch-and-bound"
      }
    },
    {
      "from": "warm_start",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "warm_start",
      "to": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "warm_start",
      "to": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
      }
    },
    {
      "from": "warm_start",
      "to": "SYMPHONY/include/sym_master.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
      }
    },
    {
      "from": "warm_start",
      "to": "SYMPHONY/include/sym_lp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
      }
    },
    {
      "from": "warm_start",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "warm_start",
      "to": "SHOT/src/NLPSolver/NLPSolverIpoptBase.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt implementation of INLPSolver interface\n\nProvides NLP solving for SHOT's primal problem using Ipopt interior point.\n\n**IpoptProblem Class (Ipopt::TNLP):**\n- Implements Ipopt's TNLP interface\n- Provides callbacks for function/gradient/Hessian evaluation\n- Sparse Jacobian/Hessian via index placement maps\n\n**TNLP Callbacks:**\n- get_nlp_info(): Problem dimensions and sparsity\n- get_bounds_info(): Variable and constraint bounds\n- eval_f(): Objective function value\n- eval_grad_f(): Objective gradient\n- eval_g(): Constraint function values\n- eval_jac_g(): Constraint Jacobian (sparse)\n- eval_h(): Lagrangian Hessian (sparse)\n- finalize_solution(): Store optimal point\n\n**NLPSolverIpoptBase Class:**\n- Wraps IpoptApplication for solve control\n- Variable fixing for integer-fixed NLP subproblems\n- Starting point management\n\n**IpoptJournal:**\n- Routes Ipopt output through SHOT logging system\n\n@note Used for fixed-integer NLP subproblems in primal bound computation"
      }
    },
    {
      "from": "warm_start",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    },
    {
      "from": "basis",
      "to": "CoinUtils/src/CoinWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interfaces for warm start information in optimization solvers"
      }
    },
    {
      "from": "basis",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
      }
    },
    {
      "from": "basis",
      "to": "CoinUtils/src/CoinOslFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
      }
    },
    {
      "from": "basis",
      "to": "CoinUtils/src/CoinWarmStartBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex basis warm start with variable status (basic/nonbasic)\n\nStores status of each variable (structural and artificial) using\n2 bits per variable. Includes diff capability for branch-and-bound."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/AbcDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for ABC dual simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpGubMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/AbcSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/AbcSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized primal simplex algorithm"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpNetworkMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Specialized matrix for pure network LP problems\n\nImplements efficient storage for network flow problems where each column\n(arc) has exactly two nonzeros: +1 at the head node and -1 at the tail node.\nThis representation requires only O(n) storage for row indices vs O(2n) for\na general sparse matrix."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpPEPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced Dantzig pricing for primal simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpPEPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced steepest edge for primal simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/AbcWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended warm start with factorization caching for ABC"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpHelperFunctions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BLAS-1 style dense vector operations for Clp"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/AbcSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized dual simplex algorithm"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/AbcPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for ABC primal simplex pivot selection"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpSimplexOther.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Auxiliary simplex operations: ranging, parametrics, and utilities"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpSimplexNonlinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpNetworkBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Specialized factorization for pure network problems"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpPrimalColumnPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpDualRowPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/CoinAbcDenseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for ABC factorization and dense submatrix handling"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpPEDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced Dantzig pricing for dual simplex"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/ClpGubDynamicMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dynamic column generation with Generalized Upper Bound structure\n\nCombines GUB constraints with dynamic column generation. Columns are\npartitioned into GUB sets where at most one column per set can be basic."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
      }
    },
    {
      "from": "basis",
      "to": "Clp/src/Clp_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
      }
    },
    {
      "from": "basis",
      "to": "Osi/src/Osi/OsiSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class defining the Open Solver Interface (OSI)\n\nOSI provides a uniform API for accessing different LP/MIP solvers\n(Clp, CPLEX, Gurobi, GLPK, etc.) through a common interface. This\nallows solver-independent application code.\n\nKey capabilities:\n- LP relaxation solving (initialSolve, resolve)\n- Model query (getColLower, getRowUpper, getObjCoefficients)\n- Solution query (getColSolution, getRowPrice, getReducedCost)\n- Problem modification (setColBounds, addRow, addCol)\n- Warm starting (getWarmStart, setWarmStart)\n- Cut management (applyCuts, applyRowCuts)\n- MIP support (setInteger, branchAndBound)\n\nTypical workflow:\n1. Create solver-specific instance (e.g., OsiClpSolverInterface)\n2. Load problem via loadProblem() or readMps()\n3. Call initialSolve() for first LP solution\n4. Call resolve() after modifications\n5. Query solution via getColSolution(), getObjValue()"
      }
    },
    {
      "from": "basis",
      "to": "ADOL-C/ADOL-C/include/adolc/adtl.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tape-less (traceless) forward-mode automatic differentiation\n\nProvides the adtl::adouble class for direct forward-mode AD without\ntape recording. Each adouble carries both its value and directional\nderivatives, which are propagated immediately through operations."
      }
    },
    {
      "from": "basis",
      "to": "Cbc/src/CbcNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Persistent information for recreating search tree nodes"
      }
    },
    {
      "from": "basis",
      "to": "Cbc/src/CbcPartialNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Incremental subproblem storage as differences from parent"
      }
    },
    {
      "from": "basis",
      "to": "Cbc/src/CbcSubProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Compact subproblem state for diving heuristics"
      }
    },
    {
      "from": "basis",
      "to": "Cbc/src/CbcHeuristicPivotAndFix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Pivot and Fix heuristic using simplex pivots\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicPivotAndFix: Exploits LP basis structure.\nPerforms simplex pivots to explore nearby basic solutions,\nthen fixes integer variables at their current values."
      }
    },
    {
      "from": "basis",
      "to": "Cbc/src/CbcFullNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Complete subproblem state storage (typically for root node)"
      }
    },
    {
      "from": "basis",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "basis",
      "to": "Cgl/src/CglCommon/CglCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for all CGL cutting plane generators\n\nDefines the interface that all cut generators must implement. In MIP\nbranch-and-cut, cutting planes tighten the LP relaxation to cut off\nfractional solutions while keeping all integer-feasible points."
      }
    },
    {
      "from": "basis",
      "to": "Bcp/Bcp/src/include/BCP_warmstart_basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BCP warm start basis implementation"
      }
    },
    {
      "from": "basis",
      "to": "Bcp/Bcp/src/include/BCP_functions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Warmstart serialization utilities"
      }
    },
    {
      "from": "basis",
      "to": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP warm start information for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "basis",
      "to": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
      }
    },
    {
      "from": "basis",
      "to": "Dip/Dip/src/DecompVar.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Column generation variable (lambda) representation\n\nDecompVar represents a column in the Dantzig-Wolfe reformulation.\nEach lambda_s corresponds to an extreme point s of a subproblem\npolyhedron: conv{x : A'x >= b', x integer}."
      }
    },
    {
      "from": "basis",
      "to": "SYMPHONY/include/sym_tm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
      }
    },
    {
      "from": "basis",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/qpsolver/basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/simplex/HEkkDual.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/mip/HighsSearch.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/mip/HighsSeparation.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut generation orchestration for MIP solver"
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/mip/HighsSeparator.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cut separators"
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/ipm/ipx/crossover.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
      }
    },
    {
      "from": "basis",
      "to": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
      }
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinSimpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple LU factorization for LP basis matrices\n\nStraightforward LU factorization implementation. Less optimized than\nCoinFactorization but simpler and useful as reference implementation."
      }
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization of sparse basis matrix for simplex\n\nImplements LU factorization with hyper-sparse handling for efficient\nFTRAN/BTRAN operations. Supports rank-one updates during pivoting."
      }
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinOslFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization derived from IBM OSL (Optimization Subroutine Library)\n\nPort of OSL's factorization code. Provides alternative to CoinFactorization\nwith different numerical characteristics and update strategies."
      }
    },
    {
      "from": "LU_factorization",
      "to": "CoinUtils/src/CoinDenseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense matrix factorization and CoinOtherFactorization base class\n\nProvides CoinOtherFactorization abstract base class for alternative\nfactorization methods, plus CoinDenseFactorization for small dense\nproblems using LAPACK-style LU."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/SPQR/Include/SuiteSparseQR.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User C++ API for sparse multifrontal QR factorization\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nMain user interface for SPQR: SuiteSparseQR overloads for [Q,R,E]=qr(A),\nX=A\\B, qmult. Structures: spqr_symbolic (pattern analysis), spqr_numeric\n(R values, Householder H), spqr_gpu (GPU staging). Expert functions:\nSuiteSparseQR_factorize, _solve, _min2norm, _symbolic, _numeric for\nfactorization reuse. Supports real/complex, int32/int64."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/SPQR/Include/spqr.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal SPQR implementation functions and data structures\nCopyright (c) 2008-2023, Timothy A Davis. GPL-2.0+ license.\n\nNon-user-callable routines: spqr_analyze (symbolic), spqr_factorize (numeric),\nspqr_kernel (parallel front factorization), spqr_assemble/cpack/rhpack (front\nassembly). Support: spqr_tol, stranspose1/2, larftb (block reflectors),\nhapply, panel, 1colamd, 1fixed. Helper structs: spqr_work, spqr_blob.\nMacros: FLIP/UNFLIP for marking, INDEX for column-major."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/ParU/Source/paru_internal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal data structures and functions for ParU sparse LU\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis.\nGPL-3.0-or-later license.\n\nCore ParU structures: ParU_Symbolic_struct (row-form S, singletons, fronts,\ntask tree), ParU_Numeric_struct (LU factors, permutations, scaling),\nParU_Control_struct (tolerances, threading). paru_element (contribution\nblock), paru_work (workspace), paru_tuple (element lists). Internal\nfunctions: front assembly/factorization, heap management, BLAS threading.\nIncludes UMFPACK SymbolicType/SWType for singleton detection."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/CSparse/Include/cs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Concise Sparse matrix library - teaching implementation of sparse algorithms\n\nCSparse provides a minimal, readable implementation of core sparse matrix\noperations. It serves as both a standalone library and educational reference\nfor sparse linear algebra algorithms.\n\nKey features:\n- Sparse matrix in triplet or compressed-column (CSC) format\n- Sparse Cholesky (cs_chol), LU (cs_lu), and QR (cs_qr) factorization\n- Fill-reducing orderings via AMD\n- Direct solvers: cs_cholsol, cs_lusol, cs_qrsol\n- Dulmage-Mendelsohn decomposition (cs_dmperm)"
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/UMFPACK/Include/umfpack.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Multifrontal sparse LU factorization for unsymmetric matrices\n\nUMFPACK computes a sparse LU factorization of a general (unsymmetric)\nsquare matrix A:\n  P*R*A*Q = L*U\nwhere P and Q are permutation matrices, R is diagonal scaling, L is\nunit lower triangular, and U is upper triangular.\n\nKey features:\n- Multifrontal algorithm with BLAS-3 dense kernels\n- Automatic strategy selection (symmetric vs unsymmetric)\n- Fill-reducing orderings: AMD (symmetric), COLAMD (unsymmetric)\n- Real and complex matrices (double precision)\n- Row scaling for numerical stability\n\nTypical workflow:\n1. umfpack_di_symbolic: Symbolic analysis (ordering, memory estimates)\n2. umfpack_di_numeric: Numerical LU factorization\n3. umfpack_di_solve: Solve Ax = b, A'x = b, etc.\n4. umfpack_di_free_symbolic, umfpack_di_free_numeric: Free memory"
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/UMFPACK/Source/umf_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for UMFPACK sparse LU factorization\nCopyright (c) 2005-2023, Timothy A. Davis. GPL-2.0+ license.\n\nUMFPACK is an unsymmetric multifrontal sparse LU factorization package.\nComputes P\u00b7A\u00b7Q = L\u00b7U via supernodal factorization with partial pivoting.\nHandles real and complex matrices in single and double precision."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/KLU/Include/klu_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for KLU sparse LU factorization\nCopyright (c) 2004-2023, University of Florida. LGPL-2.1+ license.\n\nKLU is a sparse LU factorization package designed for circuit simulation\nmatrices, which are typically highly sparse with near-diagonal structure.\nUses BTF (Block Triangular Form) permutation to exploit structure."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/CHOLMOD/Include/cholmod_internal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal definitions for CHOLMOD sparse Cholesky factorization\nCopyright (C) 2005-2023, Timothy A. Davis. Apache-2.0 license.\n\nCHOLMOD is a comprehensive sparse Cholesky factorization package supporting\nsupernodal and simplicial methods, update/downdate, and multiple orderings.\nHandles symmetric positive definite systems A\u00b7x = b via L\u00b7L' = A."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/LDL/Include/ldl.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple sparse LDL' factorization for symmetric matrices\n\nLDL computes a sparse LDL' factorization of a symmetric matrix A:\n  A = L * D * L'\nwhere L is unit lower triangular and D is diagonal. This factorization\nworks for symmetric indefinite matrices (D may have negative entries).\n\nThe factorization is performed in two phases:\n1. ldl_symbolic: Compute elimination tree and allocate storage\n2. ldl_numeric: Compute numerical values of L and D\n\nTriangular solves (ldl_lsolve, ldl_dsolve, ldl_ltsolve) complete the\nsolution of Ax = b."
      }
    },
    {
      "from": "LU_factorization",
      "to": "SuiteSparse/ParU/Include/ParU.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Parallel unsymmetric multifrontal sparse LU factorization\nCopyright (c) 2022-2025, Mohsen Aznaveh and Timothy A. Davis. GPL-3.0-or-later.\n\nParU is a parallel sparse direct solver using OpenMP tasking for task-based\nparallelism combined with parallel BLAS (nested parallelism). Solves Ax = b\nfor sparse A via LU factorization with partial pivoting."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for ABC dual simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpGubMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpLsqr.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LSQR iterative solver for sparse least-squares problems\n\nImplements the LSQR algorithm of Paige and Saunders (1982) for solving:\n- Ax = b (exact solve)\n- min ||b - Ax||_2 (least squares)\n- min ||(b) - (A    )x||_2 (damped/regularized)\n      ||(0)   (damp*I)  ||"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyPardiso.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Intel MKL Pardiso sparse direct solver for Cholesky factorization\n\nWraps Intel's Pardiso solver from the Math Kernel Library (MKL) for\nCholesky factorization of normal equations in interior point methods."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyUfl.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "SuiteSparse CHOLMOD interface for Cholesky factorization\n\nWraps the CHOLMOD library from SuiteSparse (University of Florida) for\nCholesky factorization of normal equations in interior point methods."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized primal simplex algorithm"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcWarmStart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended warm start with factorization caching for ABC"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyDense.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense Cholesky factorization for interior point methods\n\nImplements Cholesky factorization when A*D*A' becomes effectively dense.\nUses blocked recursive algorithms for cache efficiency and supports\nparallel execution via ClpCholeskySpawn."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyTaucs.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "TAUCS sparse solver interface for Cholesky factorization\n\nWraps Sivan Toledo's TAUCS library for Cholesky factorization of normal\nequations in interior point methods."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyWssmpKKT.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "WSSMP solver for KKT system (augmented system) formulation\n\nVariant of ClpCholeskyWssmp that solves the KKT/augmented system directly\ninstead of forming and factoring the normal equations A*D*A'."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyMumps.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MUMPS sparse direct solver interface for Cholesky factorization\n\nWraps the MUMPS (MUltifrontal Massively Parallel sparse direct Solver)\nlibrary for Cholesky factorization of normal equations in interior point."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpHelperFunctions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BLAS-1 style dense vector operations for Clp"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized dual simplex algorithm"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex for ABC primal simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpSimplexNonlinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpNetworkBasis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Specialized factorization for pure network problems"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcSimplexFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LU factorization wrapper for ABC simplex"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cholesky factorization base class for interior point methods\n\nProvides Cholesky factorization of the normal equations matrix A*D*A'\nused in predictor-corrector interior point methods. The factorization\nuses AMD ordering to reduce fill-in.\n\nThe base class provides a simple sparse Cholesky implementation with\nsupernodal dense blocks. Derived classes can interface to more\nsophisticated factorizations (MUMPS, Pardiso, TAUCS, etc.).\n\nKey methods:\n- order(): Compute fill-reducing ordering (AMD by default)\n- symbolic(): Set up sparsity structure of factor\n- factorize(): Numeric factorization of A*D*A'\n- solve(): Solve system using computed factors"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/ClpCholeskyWssmp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "WSSMP sparse direct solver interface for Cholesky factorization\n\nWraps IBM's Watson Sparse Matrix Package (WSSMP) for Cholesky factorization\nof normal equations in interior point methods."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/CoinAbcFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "ABC optimized LU factorization variants"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/AbcPrimalColumnPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for primal pivot column selection in ABC"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/CoinAbcBaseFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core ABC SIMD-optimized LU factorization implementation"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/CoinAbcCommonFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Common infrastructure for ABC SIMD-optimized factorization"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
      }
    },
    {
      "from": "LU_factorization",
      "to": "qpOASES/include/qpOASES/SparseSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse linear solver interfaces for Schur-complement QP method"
      }
    },
    {
      "from": "LU_factorization",
      "to": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse QP solver using Schur complement for active-set updates"
      }
    },
    {
      "from": "LU_factorization",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "LU_factorization",
      "to": "qpOASES/include/qpOASES/SQProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
      }
    },
    {
      "from": "LU_factorization",
      "to": "qpOASES/include/qpOASES/Flipper.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "LU_factorization",
      "to": "qpOASES/include/qpOASES/LapackBlasReplacement.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LAPACK/BLAS interface declarations for qpOASES linear algebra"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Interfaces/IpIpoptApplication.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main application class for calling Ipopt from C++\n\nIpoptApplication is the entry point for C++ applications using Ipopt.\nProvides methods for initialization, option handling, and solving."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpGenAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Augmented system solver using GenKKTSolverInterface\n\nGenAugSystemSolver adapts the AugSystemSolver interface to use\nGenKKTSolverInterface, which provides a more generic linear solver\ninterface supporting iterative methods.\n\nThis class:\n- Extracts raw Number* arrays from Vector objects\n- Passes Matrix objects directly from the NLP\n- Manages caching to avoid redundant matrix updates\n\nMultiSolve() implementation:\n1. Check if augmented system matrices have changed (via tags)\n2. If changed, update solver_interface_ with new matrices\n3. Extract RHS vectors to raw arrays\n4. Call solver_interface_->Solve()\n5. Copy solutions back to Vector objects\n\nTag-based caching tracks:\n- W matrix and W_factor\n- Diagonal matrices D_x, D_s, D_c, D_d\n- Jacobians J_c, J_d\n- Regularization deltas\n\nInertia and quality:\n- NumberOfNegEVals(): Query solver for eigenvalue count\n- ProvidesInertia(): Check if solver supports this\n- IncreaseQuality(): Request better pivoting/tolerance"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpLowRankSSAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Low-rank Hessian handling via single backsolve (iterative solver friendly)\n\nLowRankSSAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS) by augmenting the system rather than using\nSherman-Morrison. This requires only ONE factorization/backsolve."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpAugRestoSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Augmented system solver exploiting restoration phase structure\n\nAugRestoSystemSolver is a decorator that exploits the known structure\nof the restoration phase problem to reduce the augmented system to\nthe original problem size."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the 4x4 augmented KKT system\n\nAugSystemSolver defines the interface for solving the reduced\naugmented system obtained by eliminating bound multiplier equations:\n\n  [W + Dx + \u03b4x*I      0        Jc^T      Jd^T  ] [sol_x]   [rhs_x]\n  [    0         Ds + \u03b4s*I     0         -I   ] [sol_s] = [rhs_s]\n  [   Jc             0      Dc - \u03b4c*I    0    ] [sol_c]   [rhs_c]\n  [   Jd            -I         0      Dd - \u03b4d*I] [sol_d]   [rhs_d]"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpTimingStatistics.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Collection of timing statistics for algorithm profiling\n\nTimingStatistics aggregates TimedTask objects for all major\nalgorithm components, enabling performance profiling and\nbottleneck identification.\n\nTiming categories:\n- Algorithm phases: InitializeIterates, UpdateHessian, OutputIteration,\n  UpdateBarrierParameter, ComputeSearchDirection, etc.\n- Linear system: PDSystemSolverTotal, LinearSystemFactorization,\n  LinearSystemBackSolve, LinearSystemScaling\n- NLP evaluations: f_eval_time, grad_f_eval_time, c_eval_time,\n  jac_c_eval_time, d_eval_time, jac_d_eval_time, h_eval_time\n- Auxiliary: Task1-Task6 for ad-hoc profiling\n\nKey methods:\n- ResetTimes(): Clear all accumulated times\n- EnableTimes()/DisableTimes(): Control timing overhead\n- PrintAllTimingStatistics(): Output formatted timing report\n- TotalFunctionEvaluationCpuTime(): Sum of NLP evaluation times\n\nEach TimedTask tracks CPU time, system time, and wall-clock time."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/LinAlg/IpDenseGenMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense general (non-symmetric) matrix with linear algebra operations\n\nDenseGenMatrix stores elements in column-major (Fortran) format\nand provides direct factorization capabilities:\n- Cholesky factorization (for positive definite matrices)\n- LU factorization with pivoting (for general matrices)\n- Forward/back substitution solves"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/LinAlg/IpLapack.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "C++ wrappers for LAPACK (Linear Algebra PACKage) routines\n\nProvides platform-independent access to LAPACK for dense matrices."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/contrib/CGPenalty/IpCGPerturbationHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Perturbation handler for Chen-Goldfarb penalty method"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder for inexact step computation algorithm variant\n\nInexactAlgorithmBuilder constructs the complete IpoptAlgorithm\nconfigured for inexact Newton methods using iterative linear solvers."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoMKLSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to Intel MKL PARDISO sparse solver\n\nPardisoMKLSolverInterface wraps Intel's MKL implementation of PARDISO.\nWhile sharing the same API as pardiso-project.org's version, Intel MKL\nPARDISO has some differences in features and behavior."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTSymLinearSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Driver connecting SymMatrix to sparse linear solver interfaces\n\nTSymLinearSolver is the main driver that connects Ipopt's SymMatrix\nobjects to concrete sparse linear solvers. It handles:\n- Matrix format conversion (SymMatrix to triplet/CSR)\n- Optional matrix scaling\n- Delegation to SparseSymLinearSolverInterface implementations"
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMc19TSymScalingMethod.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix scaling using HSL MC19 equilibration\n\nMc19TSymScalingMethod uses the HSL subroutine MC19 to compute\nequilibration scaling factors for symmetric matrices."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpWsmpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to IBM WSMP sparse symmetric direct solver\n\nWsmpSolverInterface wraps the Watson Sparse Matrix Package (WSMP),\na high-performance parallel direct solver developed at IBM for\nsparse symmetric indefinite linear systems."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMumpsSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to MUMPS parallel sparse direct solver\n\nMumpsSolverInterface wraps MUMPS (MUltifrontal Massively Parallel\nsparse direct Solver), a freely available solver supporting MPI\nparallelism for distributed memory systems."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSpralSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to SPRAL SSIDS sparse symmetric solver\n\nSpralSolverInterface wraps SPRAL (Sparse Parallel Robust Algorithms\nLibrary), an open-source alternative to HSL solvers developed by\nSTFC RAL. SSIDS is SPRAL's symmetric indefinite direct solver."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa28TDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dependency detector using HSL MA28 unsymmetric solver\n\nMa28TDependencyDetector uses the unsymmetric sparse solver MA28\nto detect linearly dependent rows in the constraint Jacobian.\nUnlike the symmetric solvers, MA28 handles general rectangular\nmatrices, making it suitable for analyzing the constraint Jacobian\ndirectly.\n\nThe detection works by attempting LU factorization with threshold\npivoting. When a pivot falls below tolerance (ma28_pivtol_), the\ncorresponding row is flagged as linearly dependent.\n\nInput format: Triplet (row, col, val) for general matrices\n\nUsed by Ipopt's constraint degeneracy detection mechanism."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTSymDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dependency detection using symmetric linear solver\n\nTSymDependencyDetector detects linearly dependent constraint rows\nby using a TSymLinearSolver that provides degeneracy detection.\n\nMethod:\nSome symmetric linear solvers (e.g., MA57 via ProvidesDegeneracyDetection)\ncan identify dependent rows during factorization. This class\nleverages that capability.\n\nAlgorithm:\n1. Form symmetric matrix J*J^T (or equivalent structure)\n2. Attempt factorization with the TSymLinearSolver\n3. If solver detects singularity, query dependent row indices\n4. Return list of dependent rows in c_deps\n\nRequirements:\n- The underlying linear solver must implement\n  ProvidesDegeneracyDetection() returning true\n- Must implement DetermineDependentRows() for the sparse format\n\nThis is preferred over MA28-based detection when using a solver\nthat already provides this capability."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa57TSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA57 sparse symmetric indefinite solver\n\nMa57TSolverInterface wraps the Harwell MA57 subroutine, an improved\nmultifrontal solver over MA27 with better memory management and\nnumerical stability."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpIterativeWsmpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to IBM WSMP iterative (WISMP) solver\n\nIterativeWsmpSolverInterface wraps the iterative variant of WSMP\n(called WISMP), which uses incomplete LU factorization as a\npreconditioner for iterative refinement."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpPardisoSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to PARDISO sparse solver from pardiso-project.org\n\nPardisoSolverInterface wraps the PARDISO solver distributed by\npardiso-project.org (not to be confused with Intel MKL's PARDISO).\nPARDISO is a high-performance parallel direct solver for sparse\nsymmetric indefinite systems."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa77SolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA77 out-of-core sparse symmetric solver\n\nMa77SolverInterface wraps the HSL MA77 solver, designed for\nlarge-scale problems that may not fit entirely in memory."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpMa27TSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to HSL MA27 sparse symmetric indefinite solver\n\nMa27TSolverInterface wraps the Harwell MA27 subroutine for solving\nsparse symmetric indefinite linear systems using multifrontal\nfactorization with threshold pivoting."
      }
    },
    {
      "from": "LU_factorization",
      "to": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for strong branching NLP solves"
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/qpsolver/factor.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/qpsolver/basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/simplex/HEkk.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Edinburgh simplex kernel - high-performance LP solver core\n\nHEkk (Edinburgh Kernel) is the main simplex implementation in HiGHS,\nsupporting both dual and primal simplex methods.\n\n**HEkk Class:**\nCentral simplex solver managing LP data, basis, and solve state:\n- solve(): Run simplex algorithm (auto-selects dual/primal)\n- setBasis(): Initialize from HighsBasis\n- getSolution(): Extract primal/dual solution\n\n**Key Components:**\n- lp_: The LP being solved (may be scaled/dualized copy)\n- basis_: SimplexBasis with basic variable indices and status\n- simplex_nla_: Numeric linear algebra (factorization)\n- dual_edge_weight_: Steepest edge or Devex weights\n\n**Simplex Operations:**\n- btran/ftran: Backward/forward transformation with basis\n- pivotColumnFtran: Compute pivot column for ratio test\n- unitBtran: Compute row of B^{-1}\n\n**Transformations:**\n- dualize/undualize: Convert LP to/from dual form\n- permute/unpermute: Reorder LP for efficiency\n\n**Parallelism:**\n- chooseSimplexStrategyThreads(): Configure parallel strategy"
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/simplex/HEkkDual.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex solver for HiGHS\n\nImplements dual simplex algorithm with CHUZR (row selection), PRICE\n(pivot row computation), CHUZC (column selection), and basis update.\n\n**Parallelization Strategies:**\n- Plain: Serial dual simplex (kSimplexStrategyDualPlain)\n- SIP: Suboptimization with Independent Parallelism (Tasks)\n- PAMI: Parallel Minor Iterations (Multi)\n\n**Key Phases:**\n- Phase 1: Minimize sum of infeasibilities to find feasible basis\n- Phase 2: Optimize objective maintaining dual feasibility\n\n**Edge Weight Modes:**\n- Dantzig: Simple pricing\n- Devex: Approximate steepest edge\n- Steepest Edge: Exact steepest edge with DSE vector updates\n\n**PAMI Data Structures:**\n- MChoice: Multiple row candidates from CHUZR\n- MFinish: Minor iteration data for parallel updates\n- slice_*: Partitioned matrix for parallel PRICE"
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/ipm/ipx/forrest_tomlin.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Forrest-Tomlin LU Update for Basis Maintenance\n\nImplements the Forrest-Tomlin update to maintain LU factorization when\na single column of the basis matrix changes (basis exchange/pivot)."
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/ipm/ipx/crossover.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/ipm/ipx/kkt_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
      }
    },
    {
      "from": "LU_factorization",
      "to": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
      }
    },
    {
      "from": "hessian",
      "to": "CoinUtils/src/CoinMpsIO.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MPS file format reader/writer for LP and MIP problems\n\nReads/writes standard MPS format including extensions for quadratic,\nconic, and SOS constraints. Supports free format and compression."
      }
    },
    {
      "from": "hessian",
      "to": "CppAD/include/cppad/core/sparse_hes.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse Hessian computation using automatic differentiation"
      }
    },
    {
      "from": "hessian",
      "to": "CppAD/include/cppad/core/forward/forward.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core AD functionality: forward mode differentiation"
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES/SQProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES/Flipper.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES/Matrices.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix classes for QP data with working-set-aware operations"
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES/extras/SolutionAnalysis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Post-optimality analysis: KKT verification and sensitivity"
      }
    },
    {
      "from": "hessian",
      "to": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Online QP Benchmark Collection interface"
      }
    },
    {
      "from": "hessian",
      "to": "ADOL-C/ADOL-C/include/adolc/sparse/sparsedrivers.h",
      "type": "implemented_in",
      "meta": {
        "brief": "High-level drivers for sparse Jacobian and Hessian computation\n\nProvides efficient computation of sparse derivatives by exploiting\nsparsity structure using graph coloring and compressed computation."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Interfaces/IpTNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User interface for defining NLP problems in standard form\n\nTNLP (Templated NLP) is the primary user-facing class for defining\noptimization problems. Users inherit from TNLP and implement:"
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Interfaces/IpNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal NLP representation using Vector/Matrix abstractions\n\nNLP is Ipopt's internal problem representation with equality constraints\nseparated from inequalities:\n  min  f(x)\n  s.t. c(x) = 0           (equality constraints)\n       d_L <= d(x) <= d_U (inequality constraints)\n       x_L <= x <= x_U    (variable bounds)\n\nUnlike TNLP (user interface with arrays), NLP uses Vector and Matrix\nobjects for all operations. TNLPAdapter converts TNLP to this form."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpRestoIpoptNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "IpoptNLP adapter for restoration phase feasibility problem\n\nRestoIpoptNLP transforms the original NLP into a feasibility problem\nfor the restoration phase. It introduces slack variables to allow\nconstraint violations and penalizes them in the objective."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpIpoptNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal NLP interface with caching and scaling\n\nIpoptNLP abstracts the optimization problem for internal use:\n  min f(x)  s.t.  c(x) = 0, d_L <= d(x) <= d_U, x_L <= x <= x_U"
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpLowRankSSAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Low-rank Hessian handling via single backsolve (iterative solver friendly)\n\nLowRankSSAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS) by augmenting the system rather than using\nSherman-Morrison. This requires only ONE factorization/backsolve."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpHessianUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for Hessian computation/approximation\n\nHessianUpdater is the abstract base for strategies that provide\nthe Hessian of the Lagrangian (or an approximation) to the algorithm.\nThe result is stored in IpData.W()."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpNLPScaling.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP scaling framework for problem conditioning\n\nNLPScalingObject is the abstract base for applying diagonal scaling\nto the NLP to improve numerical conditioning. Transforms:\n  min s_f*f(S_x^{-1}*x\u0303)  s.t.  s_c*c(S_x^{-1}*x\u0303)=0, ..."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpNLPBoundsRemover.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP adapter that converts variable bounds to inequality constraints\n\nNLPBoundsRemover is an NLP adapter primarily used for inexact/iterative\nlinear solvers that require the KKT system to have a specific structure\nwithout bound constraints."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpAugRestoSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Augmented system solver exploiting restoration phase structure\n\nAugRestoSystemSolver is a decorator that exploits the known structure\nof the restoration phase problem to reduce the augmented system to\nthe original problem size."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpTimingStatistics.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Collection of timing statistics for algorithm profiling\n\nTimingStatistics aggregates TimedTask objects for all major\nalgorithm components, enabling performance profiling and\nbottleneck identification.\n\nTiming categories:\n- Algorithm phases: InitializeIterates, UpdateHessian, OutputIteration,\n  UpdateBarrierParameter, ComputeSearchDirection, etc.\n- Linear system: PDSystemSolverTotal, LinearSystemFactorization,\n  LinearSystemBackSolve, LinearSystemScaling\n- NLP evaluations: f_eval_time, grad_f_eval_time, c_eval_time,\n  jac_c_eval_time, d_eval_time, jac_d_eval_time, h_eval_time\n- Auxiliary: Task1-Task6 for ad-hoc profiling\n\nKey methods:\n- ResetTimes(): Clear all accumulated times\n- EnableTimes()/DisableTimes(): Control timing overhead\n- PrintAllTimingStatistics(): Output formatted timing report\n- TotalFunctionEvaluationCpuTime(): Sum of NLP evaluation times\n\nEach TimedTask tracks CPU time, system time, and wall-clock time."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpLowRankAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Low-rank Hessian handling via Sherman-Morrison (multiple backsolves)\n\nLowRankAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS quasi-Newton) using the Sherman-Morrison formula.\n\nL-BFGS Hessian: W = sigma*I + V*M*V^T (compact representation)\n- V: n x 2k matrix of gradient/step differences\n- M: 2k x 2k small dense matrix\n- k: number of stored corrections (limited memory)\n\nSherman-Morrison approach:\n(A + UV^T)^{-1} = A^{-1} - A^{-1}U(I + V^TA^{-1}U)^{-1}V^TA^{-1}\n\nImplementation:\n1. Solve diagonal system: Vtilde = A^{-1}*V (2k backsolves)\n2. Form small dense matrix: J = I + V^T*Vtilde\n3. Solve J*y = V^T*A^{-1}*rhs (small dense solve)\n4. Correct: x = A^{-1}*rhs - Vtilde*y\n\nStorage:\n- J1_, J2_: Dense matrices for correction\n- Vtilde1_, Utilde2_: MultiVectorMatrix backsolve results\n- Wdiag_: Diagonal part passed to base solver"
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpOrigIpoptNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard IpoptNLP implementation wrapping user's NLP\n\nOrigIpoptNLP is the concrete implementation of IpoptNLP for standard\noptimization problems. It wraps the user's NLP (via TNLP/TNLPAdapter)\nand applies scaling transformations:\n\n  min s_f\u00b7f(S_x^{-1}\u00b7x\u0303)  s.t.  s_c\u00b7c(S_x^{-1}\u00b7x\u0303)=0, ..."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/IpAlgStrategy.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for all pluggable algorithm components\n\nAlgorithmStrategyObject is the abstract base for Ipopt's Strategy pattern\nimplementation. All pluggable algorithm components inherit from this:\n- LineSearch, MuUpdate, ConvergenceCheck\n- SearchDirectionCalculator, HessianUpdater\n- PDSystemSolver, AugSystemSolver"
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpLowRankUpdateSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix as low-rank update: M = D + V*V^T - U*U^T\n\nLowRankUpdateSymMatrix represents matrices in factored form:\n  M = P_LR * (D + V*V^T - U*U^T) * P_LR^T  (if reduced_diag)\n  M = D + P_LR * (V*V^T - U*U^T) * P_LR^T  (otherwise)"
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpZeroSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix with all zero entries\n\nZeroSymMatrix represents a symmetric zero matrix (n x n).\nNo storage required. Inherits from SymMatrix for type safety."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpExpandedMultiVectorMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Short-fat matrix V^T*P^T with expansion for KKT construction\n\nExpandedMultiVectorMatrix represents a k x n matrix (k << n) as\nV^T * P^T where V is a MultiVectorMatrix-like collection of row\nvectors and P is an optional ExpansionMatrix."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/LinAlg/IpSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for symmetric matrices\n\nSymMatrix extends Matrix for symmetric matrices (A = A^T).\nTransMultVector automatically delegates to MultVector since\ntranspose is a no-op for symmetric matrices."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/Inexact/IpIterativePardisoSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Pardiso iterative solver interface for inexact Newton method\n\nIterativePardisoSolverInterface wraps the Pardiso sparse solver in\niterative (preconditioned Krylov) mode for use with inexact Newton."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactCq.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cached quantities for inexact Newton / Chen-Goldfarb penalty method\n\nInexactCq provides precomputed and cached quantities specific to the\ninexact Newton algorithm, extending IpoptCalculatedQuantities."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
      }
    },
    {
      "from": "hessian",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
      }
    },
    {
      "from": "hessian",
      "to": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
      }
    },
    {
      "from": "hessian",
      "to": "Bonmin/src/Interfaces/BonCurvatureEstimator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Curvature estimation for branching decisions (NOT SUPPORTED)"
      }
    },
    {
      "from": "hessian",
      "to": "Bonmin/src/Interfaces/BonTMINLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
      }
    },
    {
      "from": "hessian",
      "to": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
      }
    },
    {
      "from": "hessian",
      "to": "Gravity/include/gravity/func.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Expression functions with automatic differentiation and convexity tracking\n\nThe func class represents mathematical expressions with symbolic analysis."
      }
    },
    {
      "from": "hessian",
      "to": "Gravity/include/gravity/model.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
      }
    },
    {
      "from": "hessian",
      "to": "HiGHS/highs/qpsolver/factor.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
      }
    },
    {
      "from": "hessian",
      "to": "HiGHS/highs/qpsolver/basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
      }
    },
    {
      "from": "cutting_planes",
      "to": "CoinUtils/src/CoinConflictGraph.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Conflict graph for binary variable incompatibilities in MIP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "CoinUtils/src/CoinCliqueExtender.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clique extender"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Osi/src/Osi/OsiRowCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Osi/src/Osi/OsiCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Container for collections of row cuts and column cuts"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Osi/src/Osi/OsiCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cbc/src/CbcNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Persistent information for recreating search tree nodes"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cbc/src/CbcFullNodeInfo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Complete subproblem state storage (typically for root node)"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cbc/src/CbcThread.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Multi-threaded parallel B&C support"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cbc/src/CbcStrategy.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy pattern for configuring CbcModel components"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglAllDifferent/CglAllDifferent.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "All-different constraint propagation for CSP-style constraints\n\nPropagates all-different constraints: variables in a set must all\ntake different integer values. Common in constraint satisfaction\nproblems (CSP) mapped to MIP."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglLandP/CglLandP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Lift-and-Project cuts via simplex pivoting"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex algorithm for Lift-and-Project cut generation"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglCommon/CglCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for all CGL cutting plane generators\n\nDefines the interface that all cut generators must implement. In MIP\nbranch-and-cut, cutting planes tighten the LP relaxation to cut off\nfractional solutions while keeping all integer-feasible points."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglZeroHalf/CglZeroHalf.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Zero-half ({0,1/2}) cutting planes\n\nGenerates {0,1/2}-cuts by taking mod-2 combinations of constraint rows.\nBased on Andreello, Caprara, Fischetti (INFORMS J. Computing, 2007).\n\nTheory: If we combine constraints with {0, 1/2} multipliers such that\nall LHS coefficients become even, we get a valid cut by dividing by 2\nand rounding down the RHS.\n\nAlgorithm outline:\n1. Convert constraint matrix to integers (scaling)\n2. Reduce coefficients mod 2 (0-1 matrix)\n3. Find combinations where LHS sums to 0 mod 2 per column\n4. These yield valid {0,1/2}-cuts when RHS is odd\n\nInternal representation:\n- mr_, mc_, mnz_: Matrix dimensions and nonzeros\n- mtbeg_, mtcnt_, mtind_, mtval_: Sparse row storage\n- vlb_, vub_: Variable bounds (integer scaled)\n- Cgl012Cut cutInfo_: Separation algorithm state\n\nUses Dijkstra shortest path (cglShortestPath) for separation."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Applications/Mkc/include/MKC_knapsack.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC knapsack subproblem for column generation"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Applications/Mkc/include/MKC_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC LP relaxation for BCP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Applications/Mkc/include/MKC_tm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC tree manager for BCP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Bcp/src/include/BCP_enum_process_t.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Process type enumeration for BCP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Bcp/src/include/BCP_cut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut (constraint) representation for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Bcp/src/include/BCP_cg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut Generator process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Bcp/src/include/BCP_cg_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut Generator parameters for BCP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Bcp/src/include/BCP_cg_user.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User customization interface for Cut Generator process"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Bcp/src/include/BCP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bcp/Bcp/src/include/BCP_main_fun.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Process entry point functions for BCP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "cutting_planes",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Dip/Dip/src/DecompAlgoC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cutting Plane Method algorithm (no column generation)\n\nDecompAlgoC implements classic cutting plane method:\n- Solve LP relaxation\n- Find violated cuts\n- Add cuts and resolve\n- Repeat until integer or no cuts found"
      }
    },
    {
      "from": "cutting_planes",
      "to": "SYMPHONY/include/sym_lp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
      }
    },
    {
      "from": "cutting_planes",
      "to": "SYMPHONY/include/symphony.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
      }
    },
    {
      "from": "cutting_planes",
      "to": "Gravity/include/gravity/constraint.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
      }
    },
    {
      "from": "cutting_planes",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "cutting_planes",
      "to": "HiGHS/highs/mip/HighsMipSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-cut MIP solver"
      }
    },
    {
      "from": "cutting_planes",
      "to": "HiGHS/highs/mip/HighsCutGeneration.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Class that generates cuts from single row relaxations"
      }
    },
    {
      "from": "cutting_planes",
      "to": "HiGHS/highs/mip/HighsSeparation.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut generation orchestration for MIP solver"
      }
    },
    {
      "from": "cutting_planes",
      "to": "HiGHS/highs/mip/HighsSeparator.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cut separators"
      }
    },
    {
      "from": "cutting_planes",
      "to": "SHOT/src/Solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main solver interface for convex MINLP problems\n\nPrimary entry point for the SHOT optimizer."
      }
    },
    {
      "from": "cutting_planes",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
      }
    },
    {
      "from": "cutting_planes",
      "to": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
      }
    },
    {
      "from": "cutting_planes",
      "to": "SHOT/src/Tasks/TaskSelectHyperplanePointsECP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended Cutting Plane point selection\n\nClassic outer approximation: linearize at infeasible points.\n\n**TaskSelectHyperplanePointsECP Class:**\n- run(): Process current MIP solutions\n- run(solPoints): Process specific solution points\n\n**ECP Algorithm:**\n- Generate gradient cut at infeasible solution\n- Simpler than ESH but may converge slower\n- Used as fallback when ESH rootsearch fails"
      }
    },
    {
      "from": "LP_duality",
      "to": "CoinUtils/src/CoinPresolveDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fix variables using dual bounds and reduced cost analysis"
      }
    },
    {
      "from": "LP_duality",
      "to": "CoinUtils/src/CoinPresolveTighten.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tighten variable bounds using constraint propagation"
      }
    },
    {
      "from": "LP_duality",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "LP_duality",
      "to": "CoinUtils/src/CoinCliqueExtender.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clique extender"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for ABC dual simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpGubMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX/SIMD-optimized simplex solver (\"A Better Clp\")"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for dual simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized primal simplex algorithm"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPEPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced Dantzig pricing for primal simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge and Devex pivot selection for primal simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPEPrimalColumnSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced steepest edge for primal simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/Idiot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Heuristic crash procedure for finding initial LP solutions\n\nThe \"Idiot\" algorithm is a simple heuristic that finds approximate primal\nsolutions quickly. Despite its self-deprecating name (which is copylefted!),\nit serves as an effective \"crash\" procedure to warm-start the simplex method."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpCholeskyDense.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense Cholesky factorization for interior point methods\n\nImplements Cholesky factorization when A*D*A' becomes effectively dense.\nUses blocked recursive algorithms for cache efficiency and supports\nparallel execution via ClpCholeskySpawn."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpMatrixBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for constraint matrices in Clp\n\nDefines the interface that all matrix types must implement for use with\nClp algorithms. The abstraction allows specialized matrix formats that\nexploit structure (network, GUB, \u00b11 matrices) while providing a uniform\ninterface to the simplex solver."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPdcoBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for PDCO problem customization\n\nStrategy pattern interface for defining custom convex objectives in PDCO."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpHelperFunctions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BLAS-1 style dense vector operations for Clp"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPredictorCorrector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's predictor-corrector interior point algorithm"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized dual simplex algorithm"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for ABC primal simplex pivot selection"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpSimplexNonlinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Nonlinear LP solver using reduced gradient and SLP methods"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/AbcDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for ABC dual simplex pivot selection"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for LP/QP models - stores problem data without algorithm logic\n\nClpModel holds the complete representation of a linear or quadratic program:\nconstraint matrix, variable bounds, objective coefficients, and solution vectors.\nThis is the base class inherited by ClpSimplex and ClpInterior - it knows about\nproblem data but nothing about solution algorithms."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPrimalQuadraticDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig-style pricing for quadratic programming\n\nExtends ClpPrimalColumnPivot for QP problems where the reduced cost\ndepends on the current solution (due to the quadratic objective)."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPrimalColumnPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpDualRowPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPEDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced Dantzig pricing for dual simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPEDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge enhanced steepest edge for dual simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpPESimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Positive Edge anti-degeneracy framework for simplex"
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/ClpDynamicMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dynamic column generation matrix with GUB structure\n\nSupports column generation by maintaining a pool of potential columns\nand dynamically adding promising ones to the active working matrix.\nBuilt on GUB structure where each \"set\" can generate multiple columns."
      }
    },
    {
      "from": "LP_duality",
      "to": "Clp/src/Clp_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "C language interface to Clp solver\n\nPure C API for embedding Clp in C programs or creating language bindings.\nDesign follows OSL V3 conventions for familiarity.\n\nOpaque handles:\n- Clp_Simplex: Pointer to internal ClpSimplex object\n- Clp_Solve: Pointer to ClpSolve options object\n\nNaming convention: C++ method foo() becomes Clp_foo(model, ...)\nwhere model is the first parameter.\n\nKey function groups:\n- Construction: Clp_newModel(), Clp_deleteModel()\n- Problem setup: Clp_loadProblem(), Clp_readMps()\n- Solving: Clp_dual(), Clp_primal(), Clp_initialSolve()\n- Solution access: Clp_getColSolution(), Clp_getRowActivity()\n- Parameters: Clp_setLogLevel(), Clp_setMaximumIterations()\n\nCallback support: clp_callback typedef for user message handling.\n\nThread safety: Each Clp_Simplex is independent; do not share across threads."
      }
    },
    {
      "from": "LP_duality",
      "to": "CppAD/include/cppad/core/sparse_hes.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse Hessian computation using automatic differentiation"
      }
    },
    {
      "from": "LP_duality",
      "to": "qpOASES/include/qpOASES/QProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
      }
    },
    {
      "from": "LP_duality",
      "to": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Online QP Benchmark Collection interface"
      }
    },
    {
      "from": "LP_duality",
      "to": "Cbc/src/CbcHeuristicGreedy.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Greedy construction heuristics for set covering/partitioning\nCopyright (C) 2005, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nContains greedy heuristics suited for set covering/partitioning models:"
      }
    },
    {
      "from": "LP_duality",
      "to": "Cbc/src/CbcHeuristicDivePseudoCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic using pseudocost estimates\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDivePseudoCost: Most informed diving strategy.\nUses pseudocosts to estimate objective change from fixing."
      }
    },
    {
      "from": "LP_duality",
      "to": "Cbc/src/CbcBranchToFixLots.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch to fix many variables simultaneously\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchToFixLots: Heuristic branching that fixes multiple variables\nin one branch, cutting off the current solution in the other. Useful\nfor reducing problem size when reduced costs indicate fixable variables."
      }
    },
    {
      "from": "LP_duality",
      "to": "Cbc/src/CbcHeuristicDive.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
      }
    },
    {
      "from": "LP_duality",
      "to": "Cbc/src/CbcHeuristicRENS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "RENS - Relaxation Enforced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRENS: Fixes variables based on LP relaxation solution.\nUnlike RINS (which needs an incumbent), RENS works from LP alone."
      }
    },
    {
      "from": "LP_duality",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "LP_duality",
      "to": "Cgl/src/CglResidualCapacity/CglResidualCapacity.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Residual capacity cuts for network design"
      }
    },
    {
      "from": "LP_duality",
      "to": "Cgl/src/CglPreProcess/CglPreProcess.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP preprocessing with cut generator integration\n\nComprehensive MIP preprocessing that combines OsiPresolve with\ncut generators to strengthen the formulation before branch-and-cut.\nUnlike simple presolve, can add cuts that replace/strengthen constraints."
      }
    },
    {
      "from": "LP_duality",
      "to": "Cgl/src/CglRedSplit2/CglRedSplit2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Enhanced Reduce-and-Split cuts with multiple strategies"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpLeastSquareMults.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Least-squares estimation of equality constraint multipliers\n\nLeastSquareMultipliers computes initial estimates for the equality\nconstraint multipliers y_c and y_d by solving a least-squares problem.\n\nFormulation: Find y minimizing ||\u2207_x L(x,y)||^2 where\n  \u2207_x L = \u2207f(x) + J_c^T y_c + J_d^T y_d - z_L + z_U\n\nThis is equivalent to solving the normal equations:\n  [J_c J_c^T    0    ] [y_c]   [-J_c (\u2207f - z_L + z_U)]\n  [   0     J_d J_d^T] [y_d] = [-J_d (\u2207f - z_L + z_U)]\n\nActually solved via augmented system:\n  [0  J_c^T  J_d^T] [r  ]   [\u2207f - z_L + z_U]\n  [J_c  0     0   ] [y_c] = [     0        ]\n  [J_d  0     0   ] [y_d]   [     0        ]\n\nUses AugSystemSolver to solve the linear system with W=0.\n\nUsage:\n- DefaultIterateInitializer: Initial multiplier estimates\n- MinC_1NrmRestorationPhase: Post-restoration multiplier reset"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpUserScaling.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP scaling using user-provided scaling factors\n\nUserScaling obtains scaling factors directly from the NLP interface\nvia the get_scaling_parameters callback (TNLP) or GetScalingParameters\nmethod (NLP)."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpOrigIterationOutput.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard iteration output for original NLP problem\n\nOrigIterationOutput displays the per-iteration summary line\nfor the original (non-restoration) NLP problem."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpRestoRestoPhase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Recursive restoration for separable n,p variable initialization\n\nRestoRestorationPhase provides a specialized \"restoration within\nrestoration\" procedure for the MinC_1NrmRestorationPhase. It computes\noptimal values for the slack variables (n_c, p_c, n_d, p_d) by\ntreating them as separable from x and s."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing initial iterates\n\nIterateInitializer is the abstract base for strategies that\ncompute the starting point (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\nfor the interior point algorithm."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpEqMultCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing equality constraint multipliers\n\nEqMultiplierCalculator is the abstract base for computing estimates\nof the equality constraint multipliers y_c and y_d. These estimates\nare used for:"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpDefaultIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard initialization procedure for IPM iterates\n\nDefaultIterateInitializer computes starting points for all primal\nand dual variables based on user options and problem bounds.\n\nPrimal initialization (x, s):\n- Start from user-provided x0 or NLP default\n- Push away from bounds: x_new = max(x_L + \u03b5, min(x, x_U - \u03b5))\n- bound_push_, bound_frac_: Absolute/relative push parameters\n- least_square_init_primal_: Fit linearized constraints\n\nDual initialization:\n- Equality multipliers (y_c, y_d): Least-squares or zero\n- eq_mult_calculator_: Computes min ||y|| s.t. KKT gradient\n- constr_mult_init_max_: Reject large multiplier estimates\n- Bound multipliers (z_L, z_U, v_L, v_U):\n  - B_CONSTANT: bound_mult_init_val_\n  - B_MU_BASED: mu_init_ / slack\n\nWarm start:\n- warm_start_init_point_: Use warm_start_initializer_ instead\n- Delegates to WarmStartIterateInitializer\n\nStatic utilities:\n- push_variables(): Move point away from bounds\n- least_square_mults(): Compute y from gradient conditions"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpRestoIterationOutput.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Iteration output during restoration phase\n\nRestoIterationOutput provides per-iteration summary output while\nthe algorithm is in restoration phase. It displays metrics for the\nORIGINAL NLP (not the restoration feasibility problem).\n\nOutput format:\n- Iteration number marked with 'r' prefix to indicate restoration\n- Objective value from original NLP\n- Constraint violation (theta) for original constraints\n- Dual infeasibility for original problem\n\nDual output mode:\nIf resto_orig_iteration_output is provided, produces two lines:\n1. Restoration phase problem metrics\n2. Original NLP metrics (using original scaling)\n\nConfiguration:\n- print_info_string_: Whether to print info at end of line\n- inf_pr_output_: What to show in inf_pr column\n- print_frequency_iter_: Iteration print frequency\n- print_frequency_time_: Time-based print frequency"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpAdaptiveMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adaptive (non-monotone) barrier parameter update strategy\n\nAdaptiveMuUpdate implements the free-mode/fixed-mode approach for\nbarrier parameter updates. In free mode, mu is computed adaptively\neach iteration. In fixed mode, monotone decrease is enforced.\n\nTwo operating modes:\n- Free mode: MuOracle suggests mu (e.g., Mehrotra predictor-corrector\n  or quality function minimization). Allows temporary mu increases.\n- Fixed mode: Monotone decrease enforced. Triggered when free mode\n  fails to make sufficient progress.\n\nGlobalization strategies (adaptive_mu_globalization_):\n- KKT_ERROR: Track reduction in primal-dual KKT error\n- FILTER_OBJ_CONSTR: Use filter on (theta, phi)\n- NEVER_MONOTONE_MODE: Always stay in free mode\n\nFree mode oracles (via MuOracle):\n- QualityFunctionMuOracle: Minimize quality function\n- ProbingMuOracle: Try candidate mu values\n- LoqoMuOracle: LOQO-style adaptive rule\n\nFixed mode behavior:\n- Uses fix_mu_oracle_ or average complementarity\n- restore_accepted_iterate_: Can restore last good free-mode point\n\nReference value tracking:\n- refs_vals_: List of recent KKT error values\n- refs_red_fact_: Required reduction factor\n- num_refs_max_: Maximum stored references"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the 4x4 augmented KKT system\n\nAugSystemSolver defines the interface for solving the reduced\naugmented system obtained by eliminating bound multiplier equations:\n\n  [W + Dx + \u03b4x*I      0        Jc^T      Jd^T  ] [sol_x]   [rhs_x]\n  [    0         Ds + \u03b4s*I     0         -I   ] [sol_s] = [rhs_s]\n  [   Jc             0      Dc - \u03b4c*I    0    ] [sol_c]   [rhs_c]\n  [   Jd            -I         0      Dd - \u03b4d*I] [sol_d]   [rhs_d]"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpRestoIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Iterate initialization for restoration phase\n\nRestoIterateInitializer computes starting values for all variables\nin the restoration phase feasibility problem. This includes the\noriginal variables (x, s) and the slack variables (n_c, p_c, n_d, p_d)."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpPDFullSpaceSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Full-space primal-dual system solver with inertia correction\n\nPDFullSpaceSolver is the main implementation of PDSystemSolver.\nIt reduces the 8x8 primal-dual system to the 4x4 augmented system\nby eliminating bound multiplier equations:\n  d_z = S^{-1}(rhs_z - Z*P^T*d_x)\n\nKey features:\n- Iterative refinement with quality monitoring (residual_ratio)\n- Inertia correction via PDPerturbationHandler (adds delta_x, delta_c)\n- Automatic retries with increased pivot tolerance\n- Handles singular systems by adding regularization\n\nParameters:\n- min/max_refinement_steps: Iterative refinement bounds\n- residual_ratio_max: Acceptable solution quality threshold\n- neg_curv_test_tol: Tolerance for inertia heuristics"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpIterationOutput.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for per-iteration output display\n\nIterationOutput is the abstract base for strategies that produce\nthe iteration summary line and optional detailed output.\n\nStandard output line (from OrigIterationOutput):\n  iter  objective   inf_pr   inf_du   lg(mu)  ||d||  lg(rg) alpha_du alpha_pr ls\n\nInfPrOutput enum controls whether inf_pr shows internal (with slacks)\nor original NLP constraint violation.\n\nImplementations:\n- OrigIterationOutput: Standard one-line summary for original problem\n- RestoIterationOutput: Output during restoration phase\n\nOutput controlled by print_level option (0-12)."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpIpoptData.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central storage for all iteration data in Ipopt\n\nIpoptData holds the algorithmic state across iterations:\n- curr_: Current iterate (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\n- trial_: Trial point from line search\n- delta_: Search direction from KKT solve\n- delta_aff_: Affine-scaling step (for Mehrotra predictor-corrector)\n- W_: Hessian or Hessian approximation"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpAlgStrategy.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for all pluggable algorithm components\n\nAlgorithmStrategyObject is the abstract base for Ipopt's Strategy pattern\nimplementation. All pluggable algorithm components inherit from this:\n- LineSearch, MuUpdate, ConvergenceCheck\n- SearchDirectionCalculator, HessianUpdater\n- PDSystemSolver, AugSystemSolver"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/LinAlg/IpCompoundVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Composite vector stacking multiple sub-vectors\n\nCompoundVector implements the Composite pattern for vectors,\nrepresenting: x_compound = [x_0; x_1; ...; x_{n-1}]"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactNewtonNormal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Newton normal step from slack-scaled augmented system\n\nInexactNewtonNormalStep computes the normal step component by\nsolving a reduced system derived from the slack-scaled KKT system."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactSearchDirCalc.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search direction via normal-tangential decomposition\n\nInexactSearchDirCalculator computes the search direction using\niterative linear solvers by decomposing into normal and tangential\ncomponents, enabling inexact Newton methods."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactPDSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal-dual system solver for inexact Newton methods\n\nInexactPDSolver solves the primal-dual system using iterative linear\nsolvers, allowing for inexact solutions that don't fully satisfy\nthe linearized KKT conditions."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactCq.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cached quantities for inexact Newton / Chen-Goldfarb penalty method\n\nInexactCq provides precomputed and cached quantities specific to the\ninexact Newton algorithm, extending IpoptCalculatedQuantities."
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSlackBasedTSymScalingMethod.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple scaling based on current slack values\n\nSlackBasedTSymScalingMethod computes scaling factors using only\nthe current slack values, without requiring external HSL routines.\nDesigned for use with inexact/iterative linear solvers.\n\nUnlike MC19 which performs full equilibration, this method uses\na simpler heuristic based on:\n- Current slack variable values s\n- Diagonal elements of the KKT system\n\nBenefits:\n- No external library dependencies\n- Lightweight computation\n- Suitable when full equilibration is unnecessary\n\nLimitations:\n- May not achieve as good conditioning as MC19\n- Best for problems where slacks dominate scaling needs"
      }
    },
    {
      "from": "LP_duality",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Applications/Mkc/include/MKC_knapsack.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC knapsack subproblem for column generation"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Applications/Mkc/include/MKC_vargen.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC variable generation (pricing)"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Applications/Csp/include/CSP_colgen.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "CSP column generation"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_lp_user.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User customization interface for LP process"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_lp_functions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process internal function declarations"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_lp_pool.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut and variable pools for LP process"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_vg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable Generator process for BCP Branch-Cut-Price (pricing)"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_warmstart_primaldual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal-dual warm start for BCP"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_enum.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core enumerations for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_vg_user.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User customization interface for Variable Generator process"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_solution.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Solution representation for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_functions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Warmstart serialization utilities"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_warmstart.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP warm start information for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_set_intersects.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Set intersection test utility"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_warmstart_dual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual-only warm start for BCP"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_message_tag.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Message tag enumeration for BCP inter-process communication"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bcp/Bcp/src/include/BCP_lp_result.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP solve results for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "LP_duality",
      "to": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
      }
    },
    {
      "from": "LP_duality",
      "to": "Couenne/src/branch/CouenneObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
      }
    },
    {
      "from": "LP_duality",
      "to": "Couenne/src/branch/CouenneSOSObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Special Ordered Set (SOS) branching for Couenne"
      }
    },
    {
      "from": "LP_duality",
      "to": "Couenne/src/problem/CouenneProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
      }
    },
    {
      "from": "LP_duality",
      "to": "Dip/Dip/src/DecompVar.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Column generation variable (lambda) representation\n\nDecompVar represents a column in the Dantzig-Wolfe reformulation.\nEach lambda_s corresponds to an extreme point s of a subproblem\npolyhedron: conv{x : A'x >= b', x integer}."
      }
    },
    {
      "from": "LP_duality",
      "to": "Dip/Dip/src/DecompAlgo.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
      }
    },
    {
      "from": "LP_duality",
      "to": "Dip/Dip/src/DecompAlgoRC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Relax-and-Cut algorithm (Lagrangian relaxation with cuts)\n\nDecompAlgoRC implements Lagrangian relaxation:\n- Dualize complicating constraints with multipliers u\n- Solve Lagrangian subproblem: min (c - u'A'')x s.t. A'x >= b'\n- Update multipliers via subgradient optimization\n- Add cuts to improve bounds"
      }
    },
    {
      "from": "LP_duality",
      "to": "Dip/Dip/src/Decomp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
      }
    },
    {
      "from": "LP_duality",
      "to": "Dip/Dip/src/DecompAlgoPC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Price-and-Cut algorithm (Dantzig-Wolfe decomposition with cuts)\n\nDecompAlgoPC implements the most powerful DIP algorithm combining:\n- Column generation (pricing subproblems)\n- Cut generation (violated inequalities)\n- Branch-and-bound integration via ALPS"
      }
    },
    {
      "from": "LP_duality",
      "to": "SYMPHONY/include/sym_master.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Master process for SYMPHONY's parallel branch-and-cut\n\nThe master process coordinates the overall solve, managing problem\ndata, solution bounds, and communication with worker processes."
      }
    },
    {
      "from": "LP_duality",
      "to": "SYMPHONY/include/symphony.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
      }
    },
    {
      "from": "LP_duality",
      "to": "Gravity/include/gravity/constraint.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
      }
    },
    {
      "from": "LP_duality",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/simplex/HEkkPrimal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Phase 2 primal simplex solver for HiGHS"
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/mip/HighsMipSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-cut MIP solver"
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/presolve/HPresolve.h",
      "type": "implemented_in",
      "meta": {
        "brief": "LP/MIP presolve engine\n\n**HPresolve Class:**\nReduces problem size and tightens bounds before solving.\n\n**Matrix Storage:**\nTriplet format with linked list (column) and splay tree (row) for fast access:\n- Avalue[], Arow[], Acol[]: Non-zero storage\n- colhead[], Anext[], Aprev[]: Column-wise linked list\n- rowroot[], ARleft[], ARright[]: Row-wise splay tree\n- rowsize[], colsize[]: Current row/column lengths\n\n**Bound Tracking:**\n- implColLower[]/implColUpper[]: Implied variable bounds\n- rowDualLower[]/rowDualUpper[]: Dual bounds\n- impliedRowBounds, impliedDualRowBounds: Row activity bounds\n\n**Presolve Techniques (Result enum):**\n- singletonRow()/singletonCol(): Remove singleton rows/columns\n- emptyCol(): Remove columns with no constraints\n- doubletonEq(): Eliminate doubleton equalities\n- dominatedColumns(): Remove dominated variables\n- aggregator(): Aggregate rows/columns\n- runProbing(): Probing for integer variables\n- sparsify(): Reduce matrix density\n- detectParallelRowsAndCols(): Remove parallel constraints/variables"
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/ipm/ipx/iterate.h",
      "type": "implemented_in",
      "meta": {
        "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/ipm/ipx/crossover.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/ipm/ipx/ipm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/ipm/ipx/kkt_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
      }
    },
    {
      "from": "LP_duality",
      "to": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
      }
    },
    {
      "from": "LP_duality",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
      }
    },
    {
      "from": "node_selection",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "node_selection",
      "to": "Cbc/src/CbcCompareDefault.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Default adaptive node comparison strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "node_selection",
      "to": "Cbc/src/CbcCompareDepth.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Depth-first node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareDepth: Implements depth-first search (DFS).\nDefault strategy before first solution is found.\n\ntest(x,y) returns true if y is deeper than x in the tree.\nDeepest nodes explored first -> LIFO stack behavior."
      }
    },
    {
      "from": "node_selection",
      "to": "Cbc/src/CbcCompareEstimate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
      }
    },
    {
      "from": "node_selection",
      "to": "Cbc/src/CbcTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Heap-based storage for live search tree nodes\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "node_selection",
      "to": "Cbc/src/CbcCompareBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for node comparison/selection"
      }
    },
    {
      "from": "node_selection",
      "to": "Cbc/src/CbcCompareObjective.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Best-bound (objective-based) node selection\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareObjective: Implements best-first search.\nAlways explores node with best (lowest for min) LP bound.\n\ntest(x,y) returns true if y has smaller objective than x.\nPrioritizes most promising nodes for optimality proof."
      }
    },
    {
      "from": "node_selection",
      "to": "Bcp/Bcp/src/include/BCP_tm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "node_selection",
      "to": "Bcp/Bcp/src/include/BCP_tm_user.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User customization interface for Tree Manager process"
      }
    },
    {
      "from": "node_selection",
      "to": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
      }
    },
    {
      "from": "node_selection",
      "to": "SYMPHONY/include/symphony.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
      }
    },
    {
      "from": "node_selection",
      "to": "SYMPHONY/include/sym_tm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "CoinUtils/src/CoinSearchTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree data structures for branch-and-bound\n\nProvides tree node management with various comparison strategies\n(best-first, depth-first, breadth-first)."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_ImproveQP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic programming partition improvement via continuous relaxation\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQP improvement relaxes discrete partition to continuous [0,1] variables,\noptimizes via gradient projection with balance constraints, then rounds\nto discrete partition. Complements FM by exploring continuous solution\nspace; combined in waterdance for best results."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Internal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal type definitions and enumerations for Mongoose\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nDefines Int type (int64_t), matching strategies (Random, HEM, HEMSR,\nHEMSRdeg), initial cut types (QP, Random, NaturalOrder), and match\ntypes (Orphan, Standard, Brotherly, Community) used throughout Mongoose."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_GuessCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Initial partition generation at coarsest level\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nGuessCut creates initial partition for coarsest graph before refinement\nbegins. Strategies include QP relaxation, random assignment, or natural\nvertex order. Quality of initial guess affects final partition quality\ndespite refinement. Selected via initial_cut_type option."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Waterdance.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Alternating FM/QP refinement passes for partition improvement\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nWaterdance alternates between FM (discrete swaps) and QP (continuous\noptimization) refinement passes. The interplay (\"dance\") between methods\nescapes local minima that either method alone would get stuck in.\nNumber of dances controlled by num_dances option."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Clp/src/Idiot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Heuristic crash procedure for finding initial LP solutions\n\nThe \"Idiot\" algorithm is a simple heuristic that finds approximate primal\nsolutions quickly. Despite its self-deprecating name (which is copylefted!),\nit serves as an effective \"crash\" procedure to warm-start the simplex method."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Osi/src/Osi/OsiChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection strategies for branch-and-bound\n\nIn MIP solving, choosing which variable to branch on significantly\naffects tree size and solve time. This file provides:\n\n- OsiChooseVariable: Base class for branching variable selection\n- OsiChooseStrong: Strong branching (evaluates candidates by solving LPs)"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Osi/src/Osi/OsiCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcLinked.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended solver for nonlinear and bilinear problems"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree node for branch-and-cut\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcHeuristicFPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic (Fischetti, Glover & Lodi)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcHeuristicRINS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "RINS - Relaxation Induced Neighborhood Search (Danna et al.)\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRINS: Implements RINS (Danna, Rothberg & Le Pape, 2005).\nUses LP relaxation to define a neighborhood around the incumbent solution."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcCompareEstimate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcHeuristicDive.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cbc/src/CbcHeuristicRENS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "RENS - Relaxation Enforced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRENS: Fixes variables based on LP relaxation solution.\nUnlike RINS (which needs an incumbent), RENS works from LP alone."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Cgl/src/CglLandP/CglLandPSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simplex algorithm for Lift-and-Project cut generation"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Applications/MaxCut/include/MC_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Max-cut LP relaxation for BCP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Applications/Mkc/include/MKC_vargen.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC variable generation (pricing)"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Applications/Mkc/include/MKC_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC LP relaxation for BCP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Applications/Csp/include/CSP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "CSP LP relaxation for BCP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Bcp/src/include/BCP_matrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix and vector representations for BCP LP relaxation"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Bcp/src/include/BCP_lp_pool.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut and variable pools for LP process"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Bcp/src/include/BCP_lp_main_loop.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process main loop entry point"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Bcp/src/include/BCP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Bcp/src/include/BCP_main_fun.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Process entry point functions for BCP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bcp/Bcp/src/include/BCP_lp_result.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP solve results for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for NLP solvers used in branch-and-bound"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic for MINLP\n\nImplements the Feasibility Pump algorithm adapted for nonlinear problems.\nAlternates between:\n1. Rounding to nearest integer solution\n2. Projecting back to feasible continuous space via NLP\n\n**Classes:**\n- HeuristicFPump: Main feasibility pump heuristic (CbcHeuristic)\n- RoundingFPump: Helper for intelligent rounding considering constraints"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for heuristics using local NLP/MINLP solves"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicDive.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for diving heuristics in MINLP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/Branching/BonChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strong branching and pseudo-cost based variable selection for MINLP\n\nImplements branching variable selection for nonlinear branch-and-bound.\nCombines strong branching (solving LP/NLP relaxations) with pseudo-costs\n(estimates from historical branching information).\n\n**Key classes:**\n- BonChooseVariable: Main branching decision maker (extends OsiChooseVariable)\n- HotInfo: Stores strong branching results for a candidate\n\n**Branching decision process:**\n1. setupList(): Identify fractional variables, rank by pseudo-costs\n2. doStrongBranching(): Evaluate top candidates via LP/NLP solves\n3. chooseVariable(): Select best candidate based on objective change\n\n**Pseudo-cost computation:**\n- Estimates objective change per unit change in variable value\n- Updated after each branching decision using actual results\n- Used to avoid expensive strong branching after trust is established"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Bonmin/experimental/Separable/BonOuterDescription.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bonmin outer approximation description for convex MINLP\n\nOuter approximation (OA) cut management for MINLP.\nLinearization-based approach for convex MINLP."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/branch/CouenneChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection for branching in global optimization"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/branch/CouenneBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/branch/CouenneObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/bound_tightening/CouenneAggrProbing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Aggressive probing for bound tightening\n\nImplements Optimality-Based Bound Tightening (OBBT) through aggressive\nprobing. Temporarily fixes a variable bound and solves the resulting\nsubproblem to determine if a tighter bound is achievable."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/problem/CouenneProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/heuristics/CouenneFeasPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Iterative rounding heuristic for nonconvex MINLP"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/expression/operators/CouenneExprMul.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Trilinear product expression w = x*y*z"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/cut/crossconv/CouenneCrossConv.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cuts from redundant relationships between auxiliary variables"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Couenne/src/cut/sdpcuts/CouenneSdpCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "SDP-based cutting planes using matrix positive semidefiniteness\n\nGenerates cuts exploiting that product matrices X = (x_ij) where x_ij = x_i*x_j\nmust be positive semidefinite. These cuts strengthen the LP relaxation beyond\nwhat McCormick envelopes provide."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Dip/Dip/src/DecompAlgoRC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Relax-and-Cut algorithm (Lagrangian relaxation with cuts)\n\nDecompAlgoRC implements Lagrangian relaxation:\n- Dualize complicating constraints with multipliers u\n- Solve Lagrangian subproblem: min (c - u'A'')x s.t. A'x >= b'\n- Update multipliers via subgradient optimization\n- Add cuts to improve bounds"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Dip/Dip/src/Decomp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "Dip/Dip/src/DecompAlgoC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cutting Plane Method algorithm (no column generation)\n\nDecompAlgoC implements classic cutting plane method:\n- Solve LP relaxation\n- Find violated cuts\n- Add cuts and resolve\n- Repeat until integer or no cuts found"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "SYMPHONY/include/sym_lp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "SYMPHONY/include/sym_primal_heuristics.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal heuristics for finding feasible solutions\n\nCollection of heuristics to find feasible MIP solutions quickly.\nCalled during B&C to improve incumbent and provide bounds."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "SYMPHONY/include/symphony.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "HiGHS/highs/mip/HighsSearch.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
      }
    },
    {
      "from": "LP_relaxation",
      "to": "HiGHS/highs/mip/HighsMipSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-cut MIP solver"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "HiGHS/highs/mip/HighsCutGeneration.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Class that generates cuts from single row relaxations"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "HiGHS/highs/mip/HighsSeparation.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut generation orchestration for MIP solver"
      }
    },
    {
      "from": "LP_relaxation",
      "to": "HiGHS/highs/mip/HighsSeparator.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cut separators"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Refinement.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Partition projection during uncoarsening phase\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nRefinement projects partition from coarse to fine graph during\nuncoarsening. Maps coarse partition to fine vertices via inverse\nmatchmap, then applies FM/QP improvement (waterdance) at each level\nfor high-quality final partition."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPGradProj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Projected gradient descent for QP partition optimization\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPGradProj implements gradient projection for bound-constrained QP:\nminimizes quadratic cut objective subject to box constraints [0,1]\nand balance constraint (lo <= a'x <= hi). Projects gradient onto\nfeasible region, iterates until convergence or iteration limit."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPMaxHeap.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Max-heap for QP napsack breakpoint processing\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPMaxHeap provides max-heap operations (build, delete, add, heapify)\nfor efficient breakpoint processing in napsack solver. Extracts\nbreakpoints in descending order, complementing min-heap for\nbidirectional lambda search."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_ImproveQP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic programming partition improvement via continuous relaxation\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQP improvement relaxes discrete partition to continuous [0,1] variables,\noptimizes via gradient projection with balance constraints, then rounds\nto discrete partition. Complements FM by exploring continuous solution\nspace; combined in waterdance for best results."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Internal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal type definitions and enumerations for Mongoose\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nDefines Int type (int64_t), matching strategies (Random, HEM, HEMSR,\nHEMSRdeg), initial cut types (QP, Random, NaturalOrder), and match\ntypes (Orphan, Standard, Brotherly, Community) used throughout Mongoose."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPMinHeap.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Min-heap for QP napsack breakpoint processing\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPMinHeap provides min-heap operations (build, delete, add, heapify)\nfor efficient breakpoint processing in napsack solver. Extracts\nbreakpoints in ascending order to find optimal lambda for balance\nconstraint satisfaction."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPLinks.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP free set rounding and partition conversion\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPLinks converts continuous QP solution to discrete partition by\nrounding fractional variables and updating free set. Handles the\ninterface between continuous relaxation and discrete partition\nrepresentation in the waterdance refinement cycle."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_EdgeCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Edge cut result structure and partitioning entry points\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nEdgeCut struct holds partitioning results: boolean partition array,\ncut_cost (edge weight sum), cut_size (edge count), partition weights\n(w0, w1), and imbalance metric. edge_cut() functions are main entry\npoints for computing graph partitions."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPBoundary.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP boundary initialization from graph partition\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPBoundary initializes QP state from discrete partition, setting\nx values based on partition assignment and identifying boundary\nvertices (those with neighbors in opposite partition) as the\nactive set for optimization."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for Mongoose graph partitioning library\nCopyright (C) 2017-2018, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nMongoose: High-quality graph partitioning via multilevel coarsening\nwith Fiduccia-Mattheyses and quadratic programming refinement.\nPublic interface includes Graph, EdgeCut, EdgeCut_Options classes\nand read_graph/edge_cut functions for partitioning workflows."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPDelta.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver state: solution, gradient, free set, and workspace\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPDelta stores iterative QP solver state: current solution x, gradient,\nfree set (variables not at bounds), balance constraint bounds (lo/hi),\nLagrange multiplier lambda, and workspace arrays. FreeSet_status tracks\nwhether each x_i is at 0, 1, or strictly between (free)."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_GuessCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Initial partition generation at coarsest level\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nGuessCut creates initial partition for coarsest graph before refinement\nbegins. Strategies include QP relaxation, random assignment, or natural\nvertex order. Quality of initial guess affects final partition quality\ndespite refinement. Selected via initial_cut_type option."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_EdgeCutOptions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Configuration options for edge cut partitioning algorithms\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nEdgeCut_Options controls all algorithm parameters: coarsening (limit,\nmatching strategy, community detection), initial cut type (QP/random),\nFiduccia-Mattheyses (search depth, refinement count), QP gradient\nprojection (tolerance, iteration limit), and partition targets\n(split ratio, balance tolerance)."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPNapDown.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Downward lambda search in napsack solver\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPNapDown searches for lambda in decreasing direction when current\nsolution violates lower balance bound (b < lo). Processes breakpoints\nvia heaps until constraint is satisfied, returning optimal lambda."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_Waterdance.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Alternating FM/QP refinement passes for partition improvement\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nWaterdance alternates between FM (discrete swaps) and QP (continuous\noptimization) refinement passes. The interplay (\"dance\") between methods\nescapes local minima that either method alone would get stuck in.\nNumber of dances controlled by num_dances option."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Clp/src/ClpConstraint.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for nonlinear constraints\n\nDefines the interface for general (potentially nonlinear) constraints\nused in nonlinear programming extensions. The standard LP constraints\n(Ax \u2264 b) are handled directly by ClpModel; this class is for more\ngeneral constraint forms g(x) \u2264 0."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Clp/src/ClpQuadraticObjective.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic objective function for convex QP (x'Qx/2 + c'x)\n\nImplements convex quadratic objectives for quadratic programming.\nThe quadratic term is stored as a CoinPackedMatrix Q, supporting\nboth full symmetric and half (lower triangular) storage."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Clp/src/ClpPrimalQuadraticDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig-style pricing for quadratic programming\n\nExtends ClpPrimalColumnPivot for QP problems where the reduced cost\ndepends on the current solution (due to the quadratic objective)."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/ConstraintProduct.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User-defined constraint evaluation interface for structured matrices"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/SparseSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse linear solver interfaces for Schur-complement QP method"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse QP solver using Schur complement for active-set updates"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/Bounds.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/Constraints.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Working set management for general constraints in active-set QP"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/SQProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/Indexlist.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sorted index lists for efficient working set operations"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/QProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/Flipper.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/Matrices.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix classes for QP data with working-set-aware operations"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/SubjectTo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for working set management in active-set QP"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/extras/SolutionAnalysis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Post-optimality analysis: KKT verification and sensitivity"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Online QP Benchmark Collection interface"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for strong branching NLP solves"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for NLP solvers used in branch-and-bound"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "Gravity/include/gravity/model.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "HiGHS/highs/qpsolver/devexpricing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS Devex pricing for QP active set method\n\nDevex pricing strategy: approximate steepest edge using\nreference framework with periodic weight updates."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "HiGHS/highs/qpsolver/factor.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "HiGHS/highs/qpsolver/basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
      }
    },
    {
      "from": "quadratic_programming",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyMIQCQP.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Direct MIQCQP solver for convex quadratic problems\n\nBypasses ESH for problems solvable by CPLEX/Gurobi MIQCQP.\n\n**SolutionStrategyMIQCQP Class:**\n- initializeStrategy(): Configure for direct MIQCQP solve\n- solveProblem(): Single solver call, no outer approximation\n\n**Use Case:**\n- Convex MIQCQP (quadratic constraints, convex)\n- CPLEX and Gurobi support convex QCQP natively\n- Faster than iterative linearization for small problems\n\n**Problem Classification:**\n- All constraints must be convex quadratic\n- Solver must support QCQP (supportsQuadraticConstraints)"
      }
    },
    {
      "from": "active_set_method",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPGradProj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Projected gradient descent for QP partition optimization\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPGradProj implements gradient projection for bound-constrained QP:\nminimizes quadratic cut objective subject to box constraints [0,1]\nand balance constraint (lo <= a'x <= hi). Projects gradient onto\nfeasible region, iterates until convergence or iteration limit."
      }
    },
    {
      "from": "active_set_method",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPDelta.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver state: solution, gradient, free set, and workspace\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPDelta stores iterative QP solver state: current solution x, gradient,\nfree set (variables not at bounds), balance constraint bounds (lo/hi),\nLagrange multiplier lambda, and workspace arrays. FreeSet_status tracks\nwhether each x_i is at 0, 1, or strictly between (free)."
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main include file for qpOASES quadratic programming solver\n\nqpOASES solves convex quadratic programs (QPs) of the form:"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse QP solver using Schur complement for active-set updates"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/Bounds.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/Constraints.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Working set management for general constraints in active-set QP"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/SQProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/Indexlist.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sorted index lists for efficient working set operations"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/QProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver with general linear constraints\n\nSolves convex QPs with bounds and linear constraints:"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/Flipper.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": ""
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/Matrices.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Matrix classes for QP data with working-set-aware operations"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/SubjectTo.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for working set management in active-set QP"
      }
    },
    {
      "from": "active_set_method",
      "to": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Online QP Benchmark Collection interface"
      }
    },
    {
      "from": "active_set_method",
      "to": "HiGHS/highs/qpsolver/devexpricing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS Devex pricing for QP active set method\n\nDevex pricing strategy: approximate steepest edge using\nreference framework with periodic weight updates."
      }
    },
    {
      "from": "active_set_method",
      "to": "HiGHS/highs/qpsolver/factor.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
      }
    },
    {
      "from": "active_set_method",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "active_set_method",
      "to": "HiGHS/highs/qpsolver/steepestedgepricing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS steepest edge pricing for QP active set method\n\nSteepest edge pricing for QP active set. Exact edge weights\nfor optimal variable selection (more expensive than Devex)."
      }
    },
    {
      "from": "active_set_method",
      "to": "HiGHS/highs/qpsolver/basis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP basis management for active set method\n\nWorking set (active set) management for QP solver.\nTracks which constraints are currently active."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPLinks.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP free set rounding and partition conversion\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPLinks converts continuous QP solution to discrete partition by\nrounding fractional variables and updating free set. Handles the\ninterface between continuous relaxation and discrete partition\nrepresentation in the waterdance refinement cycle."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Osi/src/Osi/OsiRowCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for MIP primal heuristics\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcCompareDefault.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Default adaptive node comparison strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicDINS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "DINS - Distance-Induced Neighborhood Search\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDINS: Uses multiple solutions to define neighborhoods.\nMaintains a pool of solutions and fixes variables based on\nagreement across the solution pool (Ghosh 2007)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicDiveCoefficient.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic based on objective coefficients\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveCoefficient: Selects variables based on objective impact.\nPrioritizes fractional variables with large objective coefficients."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicDiveGuided.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic guided by incumbent solution\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveGuided: Uses existing incumbent to guide diving.\nRequires a feasible solution (canHeuristicRun checks this)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcSubProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Compact subproblem state for diving heuristics"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicRandRound.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Randomized rounding heuristic\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRandRound: Probabilistic rounding of LP solution.\nRounds fractional variables randomly with probabilities based on\ntheir fractional values (e.g., x=0.7 rounds up with prob 0.7)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcTreeLocal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Local branching search tree (Fischetti-Lodi 2002)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicDivePseudoCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic using pseudocost estimates\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDivePseudoCost: Most informed diving strategy.\nUses pseudocosts to estimate objective change from fixing."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicFPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic (Fischetti, Glover & Lodi)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicRINS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "RINS - Relaxation Induced Neighborhood Search (Danna et al.)\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicRINS: Implements RINS (Danna, Rothberg & Le Pape, 2005).\nUses LP relaxation to define a neighborhood around the incumbent solution."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcCompareEstimate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicDive.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cbc/src/CbcHeuristicDiveLineSearch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic along line to LP optimum\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveLineSearch: Geometric diving approach.\nSelects variables along the line from current point to LP optimum."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cgl/src/CglTwomir/CglTwomir.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Two-step MIR (TMIR) cut generator\n\nGenerates tMIR and 2-step MIR cuts by applying the MIR inequality\nrecursively with different scaling factors. More general than\nsimple Gomory or MIR cuts."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cgl/src/CglZeroHalf/Cgl012cut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Low-level C-style implementation for {0,1/2}-cut separation\nCopyright (C) 2010, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Cgl/src/CglSimpleRounding/CglSimpleRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple rounding cuts via GCD (greatest common divisor)\n\nGenerates simple rounding cuts using the GCD method from\nNemhauser and Wolsey (1988, p.211)."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bcp/Bcp/src/include/BCP_tm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bcp/Bcp/src/include/BCP_enum_branch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching-related enumerations for BCP"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bcp/Bcp/src/include/BCP_message_tag.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Message tag enumeration for BCP inter-process communication"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bcp/Bcp/src/include/BCP_lp_node.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process node representation"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bcp/Bcp/src/include/BCP_tm_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager parameters for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/BonDiver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Diving-based tree traversal strategies for MINLP branch-and-bound\n\nImplements tree traversal strategies that \"dive\" down branches before\nbacktracking, often finding feasible solutions faster than pure best-bound."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic for MINLP\n\nImplements the Feasibility Pump algorithm adapted for nonlinear problems.\nAlternates between:\n1. Rounding to nearest integer solution\n2. Projecting back to feasible continuous space via NLP\n\n**Classes:**\n- HeuristicFPump: Main feasibility pump heuristic (CbcHeuristic)\n- RoundingFPump: Helper for intelligent rounding considering constraints"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for heuristics using local NLP/MINLP solves"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonFixAndSolveHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fix-and-Solve heuristic for MINLP"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicLocalBranching.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Local Branching heuristic for MINLP improvement"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicDive.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for diving heuristics in MINLP"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonMilpRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MILP-based rounding heuristic for MINLP"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Couenne/src/heuristics/CouenneFeasPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Iterative rounding heuristic for nonconvex MINLP"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "SYMPHONY/include/sym_primal_heuristics.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal heuristics for finding feasible solutions\n\nCollection of heuristics to find feasible MIP solutions quickly.\nCalled during B&C to improve incumbent and provide bounds."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "SYMPHONY/include/sym_tm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "HiGHS/highs/mip/HighsPrimalHeuristics.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal heuristics for finding MIP feasible solutions\n\nCollection of primal heuristics to discover incumbent solutions."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "HiGHS/highs/mip/HighsSearch.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
      }
    },
    {
      "from": "feasibility_pump",
      "to": "HiGHS/highs/mip/HighsMipSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-cut MIP solver"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "HiGHS/highs/mip/HighsCutGeneration.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Class that generates cuts from single row relaxations"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "HiGHS/highs/mip/HighsSeparation.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut generation orchestration for MIP solver"
      }
    },
    {
      "from": "feasibility_pump",
      "to": "SHOT/src/PrimalSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP-based primal bound computation and solution repair\n\nFinds feasible solutions and improves the primal bound."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPDelta.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP solver state: solution, gradient, free set, and workspace\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPDelta stores iterative QP solver state: current solution x, gradient,\nfree set (variables not at bounds), balance constraint bounds (lo/hi),\nLagrange multiplier lambda, and workspace arrays. FreeSet_status tracks\nwhether each x_i is at 0, 1, or strictly between (free)."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Clp/src/ClpCholeskyWssmpKKT.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "WSSMP solver for KKT system (augmented system) formulation\n\nVariant of ClpCholeskyWssmp that solves the KKT/augmented system directly\ninstead of forming and factoring the normal equations A*D*A'."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Clp/src/ClpPdcoBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for PDCO problem customization\n\nStrategy pattern interface for defining custom convex objectives in PDCO."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Clp/src/ClpPredictorCorrector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's predictor-corrector interior point algorithm"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "qpOASES/include/qpOASES/SparseSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse linear solver interfaces for Schur-complement QP method"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "qpOASES/include/qpOASES/SQProblemSchur.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse QP solver using Schur complement for active-set updates"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "qpOASES/include/qpOASES/QProblemB.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Box-constrained QP solver (bounds only, no linear constraints)\n\nSolves QPs with only variable bounds (no constraint matrix A):"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "qpOASES/include/qpOASES/SQProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "qpOASES/include/qpOASES/extras/SolutionAnalysis.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Post-optimality analysis: KKT verification and sensitivity"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Online QP Benchmark Collection interface"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpGenAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Augmented system solver using GenKKTSolverInterface\n\nGenAugSystemSolver adapts the AugSystemSolver interface to use\nGenKKTSolverInterface, which provides a more generic linear solver\ninterface supporting iterative methods.\n\nThis class:\n- Extracts raw Number* arrays from Vector objects\n- Passes Matrix objects directly from the NLP\n- Manages caching to avoid redundant matrix updates\n\nMultiSolve() implementation:\n1. Check if augmented system matrices have changed (via tags)\n2. If changed, update solver_interface_ with new matrices\n3. Extract RHS vectors to raw arrays\n4. Call solver_interface_->Solve()\n5. Copy solutions back to Vector objects\n\nTag-based caching tracks:\n- W matrix and W_factor\n- Diagonal matrices D_x, D_s, D_c, D_d\n- Jacobians J_c, J_d\n- Regularization deltas\n\nInertia and quality:\n- NumberOfNegEVals(): Query solver for eigenvalue count\n- ProvidesInertia(): Check if solver supports this\n- IncreaseQuality(): Request better pivoting/tolerance"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpMonotoneMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard monotone barrier parameter update strategy\n\nMonotoneMuUpdate implements the classical IPM approach where the\nbarrier parameter mu is reduced monotonically as the subproblem\nconverges.\n\nUpdate rule:\n1. Solve barrier subproblem to tolerance barrier_tol_factor_ * mu\n2. Reduce mu: new_mu = max(mu_target_, min(kappa_mu * mu, mu^theta_mu))\n   where kappa_mu = mu_linear_decrease_factor_\n   and theta_mu = mu_superlinear_decrease_power_\n3. Update tau (fraction-to-boundary): tau = max(tau_min_, 1 - mu)\n\nKey parameters:\n- mu_init_: Initial barrier parameter\n- mu_linear_decrease_factor_: Linear decrease factor kappa_mu\n- mu_superlinear_decrease_power_: Superlinear power theta_mu\n- tau_min_: Minimum fraction-to-boundary parameter\n- mu_target_: Target mu for termination\n\nFast decrease heuristic:\n- mu_allow_fast_monotone_decrease_: Allow faster decrease when\n  complementarity is already small\n\nInteractions:\n- Calls linesearch_->Reset() when mu changes\n- Filter is cleared on barrier parameter update"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpEqMultCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing equality constraint multipliers\n\nEqMultiplierCalculator is the abstract base for computing estimates\nof the equality constraint multipliers y_c and y_d. These estimates\nare used for:"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpLowRankSSAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Low-rank Hessian handling via single backsolve (iterative solver friendly)\n\nLowRankSSAugSystemSolver handles LowRankUpdateSymMatrix Hessians\n(from L-BFGS) by augmenting the system rather than using\nSherman-Morrison. This requires only ONE factorization/backsolve."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpEquilibrationScaling.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP scaling using MC19 matrix equilibration\n\nEquilibrationScaling computes scaling factors using the HSL MC19\nsymmetric indefinite matrix equilibration routine. This produces\nwell-conditioned scaling by analyzing the Jacobian structure."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpRestoConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for restoration phase convergence checking\n\nRestoConvergenceCheck extends OptimalityErrorConvergenceCheck for\nthe restoration phase, adding termination criteria based on\nacceptability to the original problem's globalization mechanism."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpNLPBoundsRemover.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP adapter that converts variable bounds to inequality constraints\n\nNLPBoundsRemover is an NLP adapter primarily used for inexact/iterative\nlinear solvers that require the KKT system to have a specific structure\nwithout bound constraints."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpAdaptiveMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adaptive (non-monotone) barrier parameter update strategy\n\nAdaptiveMuUpdate implements the free-mode/fixed-mode approach for\nbarrier parameter updates. In free mode, mu is computed adaptively\neach iteration. In fixed mode, monotone decrease is enforced.\n\nTwo operating modes:\n- Free mode: MuOracle suggests mu (e.g., Mehrotra predictor-corrector\n  or quality function minimization). Allows temporary mu increases.\n- Fixed mode: Monotone decrease enforced. Triggered when free mode\n  fails to make sufficient progress.\n\nGlobalization strategies (adaptive_mu_globalization_):\n- KKT_ERROR: Track reduction in primal-dual KKT error\n- FILTER_OBJ_CONSTR: Use filter on (theta, phi)\n- NEVER_MONOTONE_MODE: Always stay in free mode\n\nFree mode oracles (via MuOracle):\n- QualityFunctionMuOracle: Minimize quality function\n- ProbingMuOracle: Try candidate mu values\n- LoqoMuOracle: LOQO-style adaptive rule\n\nFixed mode behavior:\n- Uses fix_mu_oracle_ or average complementarity\n- restore_accepted_iterate_: Can restore last good free-mode point\n\nReference value tracking:\n- refs_vals_: List of recent KKT error values\n- refs_red_fact_: Required reduction factor\n- num_refs_max_: Maximum stored references"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpPDPerturbationHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Inertia correction via primal-dual perturbation (regularization)\n\nPDPerturbationHandler manages the regularization parameters\n(delta_x, delta_s, delta_c, delta_d) added to the KKT system to\nensure correct inertia (n positive, m+p negative eigenvalues).\n\nThe perturbed augmented system is:\n  [W + D_x + \u03b4_x I   ...  ]\n  [  ...   D_s + \u03b4_s I  ...]\n  [  ...   ... D_c - \u03b4_c I]\n  [  ...   ...   D_d - \u03b4_d I]\n\nPerturbation strategies:\n- ConsiderNewSystem(): Called for each new matrix, may add \u03b4_c, \u03b4_d\n  if structurally singular Jacobian is detected\n- PerturbForSingularity(): Handle numerically singular system\n- PerturbForWrongInertia(): Correct incorrect eigenvalue count\n\nHeuristics:\n- Track structural degeneracy (hess_degenerate_, jac_degenerate_)\n- Increase perturbation exponentially until acceptable\n- Decrease perturbation when not needed"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpStdAugSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard augmented system solver forming explicit matrix\n\nStdAugSystemSolver is the main implementation of AugSystemSolver\nfor sparse triple-format matrices (SymTMatrix). It explicitly\nassembles the 4x4 augmented system as a CompoundSymMatrix:\n\n  [W + D_x + \u03b4_x I      0         J_c^T      J_d^T  ]\n  [     0          D_s + \u03b4_s I    0          -I    ]\n  [    J_c             0       D_c - \u03b4_c I    0     ]\n  [    J_d            -I          0       D_d - \u03b4_d I]\n\nImplementation details:\n- Uses CompoundSymMatrixSpace with SumSymMatrix for (1,1) block\n- DiagMatrix for D_x, D_s, D_c, D_d contributions\n- IdentityMatrix for scalar delta regularization\n- Tracks matrix tags to avoid unnecessary reassembly\n- Delegates factorization/solve to SymLinearSolver"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpPDFullSpaceSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Full-space primal-dual system solver with inertia correction\n\nPDFullSpaceSolver is the main implementation of PDSystemSolver.\nIt reduces the 8x8 primal-dual system to the 4x4 augmented system\nby eliminating bound multiplier equations:\n  d_z = S^{-1}(rhs_z - Z*P^T*d_x)\n\nKey features:\n- Iterative refinement with quality monitoring (residual_ratio)\n- Inertia correction via PDPerturbationHandler (adds delta_x, delta_c)\n- Automatic retries with increased pivot tolerance\n- Handles singular systems by adding regularization\n\nParameters:\n- min/max_refinement_steps: Iterative refinement bounds\n- residual_ratio_max: Acceptable solution quality threshold\n- neg_curv_test_tol: Tolerance for inertia heuristics"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/LinAlg/IpCompoundMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured matrix composed of sub-matrices\n\nCompoundMatrix implements the Composite pattern for matrices,\nrepresenting a block matrix: M = [M_00, M_01, ...; M_10, ...]"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/LinAlg/IpExpandedMultiVectorMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Short-fat matrix V^T*P^T with expansion for KKT construction\n\nExpandedMultiVectorMatrix represents a k x n matrix (k << n) as\nV^T * P^T where V is a MultiVectorMatrix-like collection of row\nvectors and P is an optional ExpansionMatrix."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/LinAlg/IpCompoundVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Composite vector stacking multiple sub-vectors\n\nCompoundVector implements the Composite pattern for vectors,\nrepresenting: x_compound = [x_0; x_1; ...; x_{n-1}]"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/LinAlg/IpDiagMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Diagonal matrix stored as a vector\n\nDiagMatrix efficiently represents diagonal matrices by storing only\nthe diagonal elements as a Vector. Matrix-vector multiply is O(n)."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/LinAlg/IpSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for symmetric matrices\n\nSymMatrix extends Matrix for symmetric matrices (A = A^T).\nTransMultVector automatically delegates to MultVector since\ntranspose is a no-op for symmetric matrices."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/contrib/CGPenalty/IpCGPerturbationHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Perturbation handler for Chen-Goldfarb penalty method"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSlackBasedTSymScalingMethod.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Simple scaling based on current slack values\n\nSlackBasedTSymScalingMethod computes scaling factors using only\nthe current slack values, without requiring external HSL routines.\nDesigned for use with inexact/iterative linear solvers.\n\nUnlike MC19 which performs full equilibration, this method uses\na simpler heuristic based on:\n- Current slack variable values s\n- Diagonal elements of the KKT system\n\nBenefits:\n- No external library dependencies\n- Lightweight computation\n- Suitable when full equilibration is unnecessary\n\nLimitations:\n- May not achieve as good conditioning as MC19\n- Best for problems where slacks dominate scaling needs"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpGenKKTSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generic interface for iterative/matrix-free KKT solvers\n\nGenKKTSolverInterface provides an alternative to\nSparseSymLinearSolverInterface for solvers that work with the\nfull KKT structure rather than requiring explicit sparse matrices.\n\nThe 4x4 block KKT system:\n  [W + D_x + delta_x*I,  0,         J_c^T,  J_d^T ] [sol_x]   [rhs_x]\n  [0,          D_s + delta_s*I,   0,     -I     ] [sol_s] = [rhs_s]\n  [J_c,        0,         D_c - delta_c*I,  0  ] [sol_c]   [rhs_c]\n  [J_d,       -I,         0,    D_d - delta_d*I] [sol_d]   [rhs_d]\n\nInterface differences from SparseSymLinearSolverInterface:\n- Receives Matrix/SymMatrix objects directly (not sparse arrays)\n- Diagonal arrays (D_x, D_s, D_c, D_d) as Number* pointers\n- Better suited for iterative solvers (Krylov, GMRES)\n- Can use matrix-vector products without explicit assembly\n\nUsed by GenAugSystemSolver to adapt this interface to AugSystemSolver."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpTDependencyDetector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for detecting linearly dependent constraint rows\n\nTDependencyDetector is the abstract base class for algorithms that\ndetect linearly dependent rows in the constraint Jacobian. This is\nneeded to handle degenerate problems where some constraints are\nredundant.\n\nPurpose:\nIf rank(J_c) < m_c, the KKT system is singular. Detecting and\nremoving dependent rows allows the solver to proceed.\n\nInterface:\n- DetermineDependentRows(): Takes Jacobian in triplet format,\n  returns list of dependent row indices in c_deps\n\nInput format (MA28 style triplet):\n- n_rows, n_cols: Jacobian dimensions\n- n_jac_nz: Number of nonzeros\n- jac_c_vals, jac_c_iRow, jac_c_jCol: Values and indices\n\nThe input arrays may be modified internally (working space)."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSymLinearSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for symmetric indefinite linear solvers\n\nSymLinearSolver is the abstract base class for all symmetric linear\nsolvers used in Ipopt's augmented system. The solver must handle\nsymmetric indefinite matrices and optionally provide inertia."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Ipopt/src/Algorithm/LinearSolvers/IpSparseSymLinearSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface for sparse symmetric indefinite linear solvers\n\nSparseSymLinearSolverInterface defines the interface that concrete\nlinear solvers (MA27, MA57, MUMPS, Pardiso, etc.) must implement."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Couenne/src/branch/CouenneComplObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for complementarity constraints"
      }
    },
    {
      "from": "KKT_conditions",
      "to": "Gravity/include/gravity/constraint.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "HiGHS/highs/ipm/ipx/crossover.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "HiGHS/highs/ipm/ipx/ipm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "HiGHS/highs/ipm/ipx/kkt_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
      }
    },
    {
      "from": "KKT_conditions",
      "to": "HiGHS/highs/ipm/ipx/conjugate_residuals.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Conjugate Residuals Method for Symmetric Positive Definite Systems\n\nImplements preconditioned Conjugate Residuals (CR) for iteratively solving\nthe KKT system in interior point methods."
      }
    },
    {
      "from": "Lagrangian",
      "to": "SuiteSparse/Mongoose/Include/Mongoose_QPNapsack.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Napsack subproblem solver for QP balance constraint\nCopyright (C) 2017-2023, Scott P. Kolodziej, Nuri S. Yeralan,\nTimothy A. Davis, William W. Hager. GPL-3.0-only license.\n\nQPNapsack solves the napsack subproblem: find lambda such that the\nprojected solution satisfies balance constraint lo <= a'x <= hi.\nUses breakpoint method with heaps to efficiently find optimal lambda.\nCore subroutine in QP gradient projection."
      }
    },
    {
      "from": "Lagrangian",
      "to": "qpOASES/include/qpOASES/SQProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sequential QP solver with varying Hessian and constraint matrices\n\nSQProblem extends QProblem to handle QPs where the Hessian H and\nconstraint matrix A change between solves. This is common in:\n- Nonlinear MPC (linearization changes each step)\n- Sequential Quadratic Programming (SQP) for NLP\n- Moving horizon estimation"
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Interfaces/IpTNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User interface for defining NLP problems in standard form\n\nTNLP (Templated NLP) is the primary user-facing class for defining\noptimization problems. Users inherit from TNLP and implement:"
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Interfaces/IpNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal NLP representation using Vector/Matrix abstractions\n\nNLP is Ipopt's internal problem representation with equality constraints\nseparated from inequalities:\n  min  f(x)\n  s.t. c(x) = 0           (equality constraints)\n       d_L <= d(x) <= d_U (inequality constraints)\n       x_L <= x <= x_U    (variable bounds)\n\nUnlike TNLP (user interface with arrays), NLP uses Vector and Matrix\nobjects for all operations. TNLPAdapter converts TNLP to this form."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Algorithm/IpExactHessianUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Hessian updater using exact second derivatives from NLP\n\nExactHessianUpdater is a trivial HessianUpdater implementation that\nsimply retrieves the exact Hessian of the Lagrangian from the NLP\nat each iteration."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Algorithm/IpHessianUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for Hessian computation/approximation\n\nHessianUpdater is the abstract base for strategies that provide\nthe Hessian of the Lagrangian (or an approximation) to the algorithm.\nThe result is stored in IpData.W()."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/Algorithm/IpAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder pattern for constructing configured IpoptAlgorithm\n\nAlgorithmBuilder assembles a complete IpoptAlgorithm from components\nbased on user options. This implements the Builder design pattern,\ncentralizing the complex construction logic.\n\nBuild order (with dependency chain):\n1. SymLinearSolver (MA27/57/77/86/97, MUMPS, Pardiso, WSMP, etc.)\n2. AugSystemSolver (wraps SymLinearSolver for augmented system)\n3. PDSystemSolver (solves full primal-dual system)\n4. SearchDirectionCalculator, EqMultiplierCalculator\n5. IterateInitializer, LineSearch, MuUpdate, ConvergenceCheck\n\nCustomization: Subclass and override virtual Build* methods,\nor provide custom_solver in constructor."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/LinAlg/IpSumSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix as weighted sum: M = sum(alpha_i * M_i)\n\nSumSymMatrix represents a symmetric matrix as a sum of symmetric terms,\neach with its own scalar factor. Preserves symmetry of components."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/LinAlg/IpZeroSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix with all zero entries\n\nZeroSymMatrix represents a symmetric zero matrix (n x n).\nNo storage required. Inherits from SymMatrix for type safety."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Ipopt/src/LinAlg/IpCompoundSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Block-structured symmetric matrix (lower triangle storage)\n\nCompoundSymMatrix implements a symmetric block matrix where only\nthe lower triangular blocks are stored: M[i][j] with j <= i.\nDiagonal blocks must themselves be SymMatrix types."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Bonmin/src/Interfaces/BonTMINLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
      }
    },
    {
      "from": "Lagrangian",
      "to": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Dip/Dip/src/DecompAlgo.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for all DIP decomposition algorithms\n\nDecompAlgo is the algorithmic engine that orchestrates:\n- Master problem management (LP relaxation)\n- Subproblem solving (pricing/column generation)\n- Cut generation and management\n- Phase transitions and convergence\n\n**Key Data Members:**\n- m_masterSI: Master LP solver interface\n- m_app: Pointer to user's DecompApp\n- m_modelCore/m_modelRelax: Problem decomposition\n- m_vars/m_cuts: Generated columns and cuts\n- m_xhat: Current LP solution in original x-space\n\n**Algorithm Phases:**\n- PHASE_PRICE1: Feasibility with artificial variables\n- PHASE_PRICE2: Optimizing with generated columns\n- PHASE_CUT: Adding violated inequalities\n\n**Virtual Methods for Subclasses:**\n- createMasterProblem(): Build initial restricted master\n- processNode(): Main node processing loop\n- generateVars(): Column generation (pricing)\n- generateCuts(): Cut separation\n- getMasterDualSolution(): Dual values for pricing\n\n**Derived Classes:**\n- DecompAlgoPC: Price-and-Cut (Dantzig-Wolfe)\n- DecompAlgoC: Cutting plane only\n- DecompAlgoRC: Relax-and-Cut (Lagrangian)"
      }
    },
    {
      "from": "Lagrangian",
      "to": "Dip/Dip/src/DecompAlgoRC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Relax-and-Cut algorithm (Lagrangian relaxation with cuts)\n\nDecompAlgoRC implements Lagrangian relaxation:\n- Dualize complicating constraints with multipliers u\n- Solve Lagrangian subproblem: min (c - u'A'')x s.t. A'x >= b'\n- Update multipliers via subgradient optimization\n- Add cuts to improve bounds"
      }
    },
    {
      "from": "Lagrangian",
      "to": "Dip/Dip/src/Decomp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Central header with enums, constants, and solver interfaces for DIP\n\nThis is the foundational include for DIP (Decomposition for Integer\nProgramming). It provides all enums, constants, and conditional solver\ninterface includes."
      }
    },
    {
      "from": "Lagrangian",
      "to": "Gravity/include/gravity/constraint.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Constraint classes with type, duals, and lazy evaluation\n\nConstraints are functions with a constraint type (<=, >=, ==) and bounds."
      }
    },
    {
      "from": "Lagrangian",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "Lagrangian",
      "to": "HiGHS/highs/pdlp/cupdlp/cupdlp_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "PDHG (Primal-Dual Hybrid Gradient) Solver for Linear Programming\n\nImplements the PDLP (Primal-Dual Linear Programming) algorithm using\nfirst-order optimization methods instead of traditional simplex or IPM."
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/AbcDualRowSteepest.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Steepest edge pivot selection for ABC dual simplex"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/ClpSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual simplex algorithm implementation"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/AbcMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cache-optimized matrix for ABC simplex with multiple copies"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/ClpDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/AbcSimplexDual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized dual simplex algorithm"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Clp/src/ClpDualRowPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
      }
    },
    {
      "from": "dual_simplex",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "branching",
      "to": "Clp/src/ClpGubMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Generalized Upper Bound (GUB) matrix for special LP structure\n\nImplements GUB constraints - sets of variables where exactly one (or at\nmost one) must be in the basis. This structure appears in problems like\nassignment, crew scheduling, and set partitioning."
      }
    },
    {
      "from": "branching",
      "to": "Clp/src/ClpNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Node representation for branch-and-bound fathoming\n\nSupport classes for Clp's fathom capability - solving subproblems\nin a branch-and-bound tree. Used when Clp is embedded in CBC."
      }
    },
    {
      "from": "branching",
      "to": "Clp/src/ClpDualRowDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for dual simplex pivot selection\n\nImplements the simplest pivot row selection: choose the basic variable\nwith the largest primal infeasibility. Simple and fast per iteration,\nbut may require many more iterations than steepest edge on degenerate\nor difficult problems.\n\nThis is Dantzig's original 1947 rule applied to dual simplex.\nUse ClpDualRowSteepest for better performance on most problems."
      }
    },
    {
      "from": "branching",
      "to": "Clp/src/ClpDualRowPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for dual simplex pivot row selection\n\nIn dual simplex, the pivot row (leaving variable) is chosen based on\nprimal infeasibility. This class defines the interface for different\nselection strategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotRow(): Select which row (basic variable) leaves the basis\n- updateWeights(): Maintain pricing information after pivots\n- updatePrimalSolution(): Update solution after basis change"
      }
    },
    {
      "from": "branching",
      "to": "Clp/src/ClpPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
      }
    },
    {
      "from": "branching",
      "to": "Clp/src/OsiClp/OsiClpSolverInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Osi interface for CLP simplex solver\nCopyright (C) 2000, International Business Machines Corporation.\nEPL-1.0 license.\n\nOsiClpSolverInterface wraps ClpSimplex via the Osi abstraction, enabling\nClp use within CBC and with Cgl cut generators. Key features: hot-starting\nfor strong branching (markHotStart/solveFromHotStart), simplex tableau\naccess (getBInvARow/getBInvACol), disaster recovery for numerical issues."
      }
    },
    {
      "from": "branching",
      "to": "Osi/src/Osi/OsiBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-bound objects and branching decisions\n\nThis file defines the object-oriented framework for branching in MIP:\n\n- **OsiObject**: Abstract base for anything that can be branched on\n  (integer variables, SOS constraints, etc.)\n- **OsiBranchingObject**: Describes how to perform a specific branch\n- **OsiBranchingInformation**: Solver state passed to branching decisions"
      }
    },
    {
      "from": "branching",
      "to": "Osi/src/Osi/OsiChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection strategies for branch-and-bound\n\nIn MIP solving, choosing which variable to branch on significantly\naffects tree size and solve time. This file provides:\n\n- OsiChooseVariable: Base class for branching variable selection\n- OsiChooseStrong: Strong branching (evaluates candidates by solving LPs)"
      }
    },
    {
      "from": "branching",
      "to": "Osi/src/Osi/OsiCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcConsequence.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for bound implications from branching"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcSOS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Special Ordered Sets (SOS) Type 1 and Type 2 branching\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSOS: Branching for Special Ordered Sets (Beale & Tomlin, 1970):\n\nSOS Type 1: At most ONE variable can be nonzero\n- Common for selection between alternatives (choose one option)\n- SUM x_i <= 1 (or = 1 for exactly one)\n- Binary SOS1 is a special case of clique\n\nSOS Type 2: At most TWO CONSECUTIVE variables can be nonzero\n- Used for piecewise linear approximation (interpolation)\n- Variables ordered by weights; sum to 1\n- Represents point between two breakpoints"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchDecision.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for branching variable selection\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcFathom.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fathoming methods to complete subproblems"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcGeneralDepth.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Depth-limited partial evaluation branching"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for branching entities (variables, SOS, etc.)"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcHeuristicDiveFractional.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic selecting most fractional variable\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveFractional: Simplest diving strategy.\nSelects the variable with value closest to 0.5 (most fractional)."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcSymmetry.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetry detection and orbital branching using nauty\nAuthors: Pietro Belotti (Lehigh), Andreas Waechter (IBM)\nAdapted from Couenne (Carnegie-Mellon University, 2006-11)\nThis file is licensed under the Eclipse Public License (EPL)\n\nCbcSymmetry: Detects problem symmetry and exploits it for faster solving.\nUses the nauty library for automorphism group computation."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchActual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Aggregator for concrete branching classes"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcHeuristicDiveCoefficient.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic based on objective coefficients\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveCoefficient: Selects variables based on objective impact.\nPrioritizes fractional variables with large objective coefficients."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base includes for CBC branching model"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcGeneral.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for general multi-way branching"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcHeuristicDiveGuided.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic guided by incumbent solution\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveGuided: Uses existing incumbent to guide diving.\nRequires a feasible solution (canHeuristicRun checks this)."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcLinked.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended solver for nonlinear and bilinear problems"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcSimpleIntegerDynamicPseudoCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Integer variable with dynamic (learning) pseudocosts\nCopyright (C) 2005, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSimpleIntegerDynamicPseudoCost: Implements reliability branching\nbased on Achterberg, Koch & Martin's work. Pseudocosts are learned\nfrom actual branching history rather than being static estimates.\n\nKey statistics tracked per variable:\n- sumUpCost_/sumDownCost_: Cumulative objective changes\n- numberTimesUp_/Down_: Branch count for averaging\n- numberBeforeTrust_: Initialization threshold before trusting estimates"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcSimpleIntegerPseudoCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Integer variable with static pseudocosts\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSimpleIntegerPseudoCost: Extends CbcSimpleInteger with static\npseudocost estimates for branch direction preference:\n- upPseudoCost_: Estimated objective increase per unit ceiling\n- downPseudoCost_: Estimated objective increase per unit floor"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcDummyBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "No-op branching object for special cases"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcHeuristicDiveVectorLength.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic based on constraint participation\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDiveVectorLength: Selects variables by column density.\nVariables appearing in many constraints are fixed first."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for branching actions"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcNWay.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "N-way branching (exactly one variable at upper bound)\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcNWay: Multi-way (N-ary) branching for selection constraints.\nExactly one variable at upper bound, all others at lower bound.\nCreates N children, each fixing one variable to its UB."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcTreeLocal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Local branching search tree (Fischetti-Lodi 2002)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchLotsize.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Lot-sizing variable with discrete valid values\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcLotsize: Variable restricted to specific discrete values (lot sizes).\nUnlike integers (any value in range), lot-sizing variables can only\ntake values from a predefined set: {v1, v2, ..., vn}."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcHeuristicDivePseudoCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dive heuristic using pseudocost estimates\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDivePseudoCost: Most informed diving strategy.\nUses pseudocosts to estimate objective change from fixing."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcFollowOn.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Follow-on branching for crew scheduling problems\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcFollowOn: Specialized branching for air-crew scheduling and\nsimilar set-partitioning problems. When crew can fly in on flight A\nand out on flight B (or other flights), branch on the connection."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcObjectUpdateData.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Data carrier for updating branching objects after branching"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchDynamic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dynamic pseudocost-based branching decision\nCopyright (C) 2005, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchDynamicDecision: Selects branches using dynamic pseudocosts.\n- Before first solution: Uses infeasibility counts\n- After first solution: Uses objective change estimates\n\nPseudocosts are updated during search based on observed\nobjective changes from actual branching decisions."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcNode.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search tree node for branch-and-cut\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchAllDifferent.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "All-different constraint for integer variables\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchAllDifferent: Enforces that a set of integer variables\nmust all have different values. When two variables i,j have the\nsame value, creates branching disjunction:\n  x_i <= x_j - 1  OR  x_i >= x_j + 1"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcCompareEstimate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Estimate-based node selection strategy\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcCompareEstimate: Node selection using solution estimates.\nUsed during rounding phases where estimated objective matters."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcFixVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fix variable bounds as branching consequence"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcHeuristicDive.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base for diving heuristics\nCopyright (C) 2008, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDive: Abstract base for diving heuristics that explore\nthe tree greedily by fixing variables and re-solving LPs."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcClique.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Clique branching for binary variable sets\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcClique: Branching for cliques (sets of binary variables with\nat most one at its \"strong\" value). Generalizes binary SOS1.\n\nStandard form: x1 + x2 + ... + xn <= 1 (all strong at 1)\nGeneral form allows negated variables (y_j = 1 - x_j).\n\nMember types (type_[i]):\n- 1: SOS-style, coefficient +1, strong value is 1\n- 0: Non-SOS, coefficient -1, strong value is 0"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcTree.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Heap-based storage for live search tree nodes\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL)."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcSimpleInteger.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Integer variable branching object"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcStrategy.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy pattern for configuring CbcModel components"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching by adding cuts (split disjunctions)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchCut and CbcCutBranchingObject: Branch by adding cuts\nrather than tightening variable bounds. Implements split disjunctions\nwhere each branch arm adds a different cut to the LP."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcBranchDefaultDecision.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Default branching variable selection\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchDefaultDecision: Simple selection algorithm without pseudocosts."
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcFeasibilityBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User-defined feasibility checking"
      }
    },
    {
      "from": "branching",
      "to": "Cbc/src/CbcStatistics.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Statistics gathering for node processing"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Applications/Mkc/include/MKC_var.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC variable/column definitions"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Applications/Mkc/include/MKC_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MKC LP relaxation for BCP"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Applications/Csp/include/CSP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "CSP LP relaxation for BCP"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Applications/Csp/include/CSP_colgen.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "CSP column generation"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Applications/Csp/include/CSP_lp_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "CSP LP parameters"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_lp_user.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "User customization interface for LP process"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_lp_functions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process internal function declarations"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_lp_param.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process parameters for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_branch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal branching object for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_cut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut (constraint) representation for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_process.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BCP process base class and scheduler"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_enum_branch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching-related enumerations for BCP"
      }
    },
    {
      "from": "branching",
      "to": "Bcp/Bcp/src/include/BCP_lp_branch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-side branching objects for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Interfaces/BonCutStrengthener.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strengthening OA cuts via NLP optimization\n\nImproves outer approximation cuts by solving auxiliary NLPs to find\ntighter bounds on linearizations. Also supports disjunctive cuts."
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for strong branching NLP solves"
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Interfaces/BonCurvatureEstimator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Curvature estimation for branching decisions (NOT SUPPORTED)"
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for heuristics using local NLP/MINLP solves"
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicLocalBranching.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Local Branching heuristic for MINLP improvement"
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Algorithms/Branching/BonPseudoCosts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Pseudo-cost storage and update for MINLP branching\n\nExtends OsiPseudoCosts to track branching history for integer variables.\nPseudo-costs estimate the objective change per unit change in a variable,\nenabling efficient branching decisions without expensive strong branching."
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
      }
    },
    {
      "from": "branching",
      "to": "Bonmin/src/Algorithms/Branching/BonChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strong branching and pseudo-cost based variable selection for MINLP\n\nImplements branching variable selection for nonlinear branch-and-bound.\nCombines strong branching (solving LP/NLP relaxations) with pseudo-costs\n(estimates from historical branching information).\n\n**Key classes:**\n- BonChooseVariable: Main branching decision maker (extends OsiChooseVariable)\n- HotInfo: Stores strong branching results for a candidate\n\n**Branching decision process:**\n1. setupList(): Identify fractional variables, rank by pseudo-costs\n2. doStrongBranching(): Evaluate top candidates via LP/NLP solves\n3. chooseVariable(): Select best candidate based on objective change\n\n**Pseudo-cost computation:**\n- Estimates objective change per unit change in variable value\n- Updated after each branching decision using actual results\n- Used to avoid expensive strong branching after trust is established"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/expression/CouenneExprAux.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Auxiliary variable class for reformulated nonlinear expressions\n\nAuxiliary variables replace nonlinear terms during standardization,\nenabling generation of convex relaxations. If w = f(x), then cuts\nare generated for the relation between w and f(x)."
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection for branching in global optimization"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Three-way spatial branching for continuous variables"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneVarObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable-based branching object for MINLP"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneComplBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for complementarity constraints"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneOrbitObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Orbital branching using symmetry detection (DISABLED)"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneVTObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Violation transfer branching for MINLP variables"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneComplObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for complementarity constraints"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneNauty.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to nauty library for symmetry detection\n\nWraps the nauty graph automorphism library to detect symmetries\nin MINLP problems. Symmetry information enables orbital branching\nand isomorphism pruning to reduce the search space."
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Orbital branching object using symmetry"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneSOSObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Special Ordered Set (SOS) branching for Couenne"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/branch/CouenneChooseStrong.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strong branching for global MINLP optimization\n\nExtends Bonmin's strong branching to handle nonconvex constraints\nby evaluating actual LP bound improvement from branching."
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "branching",
      "to": "Couenne/src/heuristics/CouenneIterativeRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Iterative rounding heuristic for nonconvex MINLP"
      }
    },
    {
      "from": "branching",
      "to": "Dip/Dip/src/DecompApp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "User application interface - derive to define your decomposition\n\nDecompApp is the main user-facing class. Derive from it to define:\n- Model decomposition (core vs relaxed constraints)\n- Subproblem solvers\n- Problem-specific heuristics"
      }
    },
    {
      "from": "branching",
      "to": "Dip/Dip/src/DecompAlgoPC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Price-and-Cut algorithm (Dantzig-Wolfe decomposition with cuts)\n\nDecompAlgoPC implements the most powerful DIP algorithm combining:\n- Column generation (pricing subproblems)\n- Cut generation (violated inequalities)\n- Branch-and-bound integration via ALPS"
      }
    },
    {
      "from": "branching",
      "to": "SYMPHONY/include/sym_lp.h",
      "type": "implemented_in",
      "meta": {
        "brief": "LP solver process for SYMPHONY's branch-and-cut\n\nThe LP process solves LP relaxations at each B&C node, manages\ncuts, and performs branching decisions."
      }
    },
    {
      "from": "branching",
      "to": "SYMPHONY/include/sym_primal_heuristics.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal heuristics for finding feasible solutions\n\nCollection of heuristics to find feasible MIP solutions quickly.\nCalled during B&C to improve incumbent and provide bounds."
      }
    },
    {
      "from": "branching",
      "to": "SYMPHONY/include/symphony.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
      }
    },
    {
      "from": "branching",
      "to": "SYMPHONY/include/sym_tm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tree Manager for SYMPHONY's parallel B&C\n\nThe Tree Manager (TM) maintains the branch-and-cut search tree,\ndispatches nodes to LP workers, and coordinates cut generation."
      }
    },
    {
      "from": "branching",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "branching",
      "to": "HiGHS/highs/mip/HighsSearch.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-bound tree search for MIP solver\n\nImplements depth-first search with backtracking and node evaluation."
      }
    },
    {
      "from": "branching",
      "to": "HiGHS/highs/mip/HighsNodeQueue.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Priority queue for branch-and-bound nodes"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpNonLinearCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Piecewise linear cost handling and bound infeasibility tracking\n\nManages piecewise linear objective functions and tracks bound violations\nduring primal simplex. When variables move outside their bounds, this class\ncomputes the appropriate infeasibility penalty costs."
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/AbcSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "AVX-optimized primal simplex algorithm"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpFactorization.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Wrapper around CoinFactorization for use within Clp simplex"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpSimplexPrimal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal simplex algorithm implementation"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpPrimalColumnPivot.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for primal simplex pivot column selection\n\nIn primal simplex, the pivot column (entering variable) is chosen based on\nreduced cost. This class defines the interface for different selection\nstrategies. Derived classes implement specific rules.\n\nKey methods:\n- pivotColumn(): Select which column (variable) enters the basis\n- updateWeights(): Maintain pricing information after pivots\n- saveWeights(): Preserve weights across refactorizations"
      }
    },
    {
      "from": "primal_simplex",
      "to": "Clp/src/ClpPrimalColumnDantzig.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig's rule for primal simplex pivot selection\n\nImplements the simplest pivot column selection: choose the nonbasic variable\nwith the most negative reduced cost (for minimization). This is Dantzig's\noriginal 1947 rule.\n\nSimple and fast per iteration, but typically requires more iterations than\nsteepest edge methods on degenerate or difficult problems. Use\nClpPrimalColumnSteepest for better performance on most problems."
      }
    },
    {
      "from": "primal_simplex",
      "to": "Cbc/src/Cbc_C_Interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Creates an empty problem"
      }
    },
    {
      "from": "primal_simplex",
      "to": "HiGHS/highs/simplex/HEkkPrimal.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Phase 2 primal simplex solver for HiGHS"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Clp/src/ClpConstraintLinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Linear constraint implementation for nonlinear extensions\n\nImplements ClpConstraint for a linear constraint: sum(a_j * x_j) = b.\nUsed with ClpSimplexNonlinear when linear constraints appear alongside\nnonlinear objective or other nonlinear constraints."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Clp/src/ClpConstraint.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for nonlinear constraints\n\nDefines the interface for general (potentially nonlinear) constraints\nused in nonlinear programming extensions. The standard LP constraints\n(Ax \u2264 b) are handled directly by ClpModel; this class is for more\ngeneral constraint forms g(x) \u2264 0."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Clp/src/ClpConstraintQuadratic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic constraint implementation: x'Qx + c'x \u2264 b\n\nImplements ClpConstraint for quadratic constraints. The constraint\nfunction is: 0.5 * sum_{ij}(Q_ij * x_i * x_j) + sum_j(c_j * x_j) \u2264 b"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Cbc/src/CbcLinked.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended solver for nonlinear and bilinear problems"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Ipopt/src/Algorithm/IpBacktrackingLineSearch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "General backtracking line search with filter/restoration support\n\nBacktrackingLineSearch is the main LineSearch implementation,\nproviding a flexible framework for globalization strategies:\n\nCore algorithm:\n1. Start with full step alpha = alpha_max (fraction-to-boundary)\n2. Test acceptability via BacktrackingLSAcceptor\n3. If rejected, reduce alpha *= alpha_red_factor and retry\n4. If alpha becomes too small, trigger restoration phase\n\nAdvanced features:\n- Watchdog mechanism: Accept poor steps temporarily to escape local minima\n- Second-order correction (SOC): Improve constraint satisfaction\n- Soft restoration phase: Accept steps that reduce primal-dual error\n- Magic steps: Improve slack/bound multiplier pairing\n- Corrector steps: Improve local convergence rate\n\nKey parameters:\n- alpha_for_y: How to step in equality multipliers\n- watchdog_trial_iter_max: Watchdog iteration limit\n- max_soc: Maximum second-order corrections"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactPDSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Primal-dual system solver for inexact Newton methods\n\nInexactPDSolver solves the primal-dual system using iterative linear\nsolvers, allowing for inexact solutions that don't fully satisfy\nthe linearized KKT conditions."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Interfaces/BonCutStrengthener.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strengthening OA cuts via NLP optimization\n\nImproves outer approximation cuts by solving auxiliary NLPs to find\ntighter bounds on linearizations. Also supports disjunctive cuts."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/BonSubMipSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified interface for solving MILP subproblems in OA decomposition\n\nProvides a common interface for solving MILP subproblems using either\nCbc (via OsiClpSolverInterface) or CPLEX (via OsiCpxSolverInterface).\nUsed by OA decomposition algorithms to solve the linearized master problem."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for heuristics using local NLP/MINLP solves"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonFixAndSolveHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fix-and-Solve heuristic for MINLP"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaDecBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for Outer Approximation (OA) decomposition algorithms\n\nImplements the foundation for OA-based MINLP algorithms. OA iterates between\nsolving MILP subproblems and NLP subproblems, generating linear outer\napproximations of the nonlinear constraints.\n\n**OA algorithm outline:**\n1. Solve MILP relaxation \u2192 get integer solution x*\n2. Fix integers to x*, solve NLP \u2192 get nonlinear solution y*\n3. Generate linearization cuts at y* (gradient-based)\n4. Add cuts to MILP, repeat until convergence\n\n**Key components:**\n- solverManip: RAII helper to save/restore solver state\n- performOa(): Virtual method implementing specific OA variant\n- post_nlp_solve(): Handle NLP solution and update bounds\n\n**Parameters:**\n- global_: Add cuts globally (valid at all nodes)\n- addOnlyViolated_: Only add cuts violated by current solution\n- maxLocalSearch_: Limit on local search iterations"
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Bonmin/experimental/Separable/BonOuterDescription.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bonmin outer approximation description for convex MINLP\n\nOuter approximation (OA) cut management for MINLP.\nLinearization-based approach for convex MINLP."
      }
    },
    {
      "from": "outer_approximation",
      "to": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic expression with alpha-convexification"
      }
    },
    {
      "from": "outer_approximation",
      "to": "HiGHS/highs/ipm/ipx/kkt_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/PrimalSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP-based primal bound computation and solution repair\n\nFinds feasible solutions and improves the primal bound."
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/SolutionStrategy/SolutionStrategyMultiTree.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Iterative outer approximation strategy (multi-tree)\n\nClassic outer approximation loop for convex MINLP.\n\n**Algorithm Pattern:**\n1. Solve MIP relaxation to get candidate point\n2. Generate supporting hyperplanes at violated points\n3. Add cuts to MIP and resolve\n4. Repeat until convergence or termination\n\n**Task Flow (initializeStrategy):**\n- CreateDualProblem \u2192 SolveIteration \u2192 SelectHyperplanes\n- AddHyperplanes \u2192 CheckTermination \u2192 loop\n\n**Advantages:**\n- No callback complexity\n- Can use any MIP solver\n- Easier debugging/logging\n\n**Disadvantages:**\n- Multiple MIP solves\n- May regenerate same B&B tree work"
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/MIPSolver/MIPSolverCbc.h",
      "type": "implemented_in",
      "meta": {
        "brief": "COIN-OR Cbc implementation of IMIPSolver interface\n\nProvides open-source MIP solving using Cbc branch-and-cut solver.\n\n**MIPSolverCbc Class:**\n- Implements IMIPSolver interface\n- Uses OsiClpSolverInterface for LP subproblems\n- CbcModel for branch-and-cut\n- CoinModel for problem construction\n\n**Key Data Structures:**\n- osiInterface: OSI LP solver (Clp)\n- cbcModel: MIP solver model\n- coinModel: Problem builder\n- objectiveLinearExpression: CoinPackedVector\n\n**CbcMessageHandler:**\n- Custom message handler for SHOT logging\n- Routes Cbc output through SHOT's Output system\n\n**Limitations:**\n- supportsQuadraticObjective(): No\n- supportsQuadraticConstraints(): No\n- LP/MIP only (no MIQP/QCQP)\n\n@note Default open-source MIP solver, no license required"
      }
    },
    {
      "from": "outer_approximation",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    },
    {
      "from": "linear_programming",
      "to": "Clp/src/ClpConstraintLinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Linear constraint implementation for nonlinear extensions\n\nImplements ClpConstraint for a linear constraint: sum(a_j * x_j) = b.\nUsed with ClpSimplexNonlinear when linear constraints appear alongside\nnonlinear objective or other nonlinear constraints."
      }
    },
    {
      "from": "linear_programming",
      "to": "Clp/src/ClpSimplex.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main simplex solver class - orchestrates primal and dual simplex algorithms"
      }
    },
    {
      "from": "linear_programming",
      "to": "Clp/src/ClpConstraintQuadratic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic constraint implementation: x'Qx + c'x \u2264 b\n\nImplements ClpConstraint for quadratic constraints. The constraint\nfunction is: 0.5 * sum_{ij}(Q_ij * x_i * x_j) + sum_j(c_j * x_j) \u2264 b"
      }
    },
    {
      "from": "linear_programming",
      "to": "Cbc/src/CbcLinked.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended solver for nonlinear and bilinear problems"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bcp/Bcp/src/include/BCP_enum_process_t.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Process type enumeration for BCP"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bcp/Bcp/src/include/BCP_branch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Internal branching object for BCP Branch-Cut-Price"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bcp/Bcp/src/include/BCP_lp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP process for BCP Branch-Cut-Price framework"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bcp/Bcp/src/include/BCP_math.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mathematical constants for BCP"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bcp/Bcp/src/include/BCP_warmstart_dual.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dual-only warm start for BCP"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for NLP solvers used in branch-and-bound"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "linear_programming",
      "to": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
      }
    },
    {
      "from": "linear_programming",
      "to": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP heuristic for near-integer B&B nodes"
      }
    },
    {
      "from": "linear_programming",
      "to": "SHOT/src/Model/Problem.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Clp/src/ClpHelperFunctions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BLAS-1 style dense vector operations for Clp"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Clp/src/ClpPredictorCorrector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's predictor-corrector interior point algorithm"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "qpOASES/include/qpOASES/extras/OQPinterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Online QP Benchmark Collection interface"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Interfaces/IpIpoptApplication.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main application class for calling Ipopt from C++\n\nIpoptApplication is the entry point for C++ applications using Ipopt.\nProvides methods for initialization, option handling, and solving."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpProbingMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's probing heuristic for barrier parameter selection\n\nProbingMuOracle implements Mehrotra's predictor-corrector approach\nto compute the barrier parameter mu. This is the strategy used in\nmany interior point codes like LOQO and PCx.\n\nAlgorithm:\n1. Compute affine scaling direction (predictor step) with sigma=0\n2. Find maximum step to boundary (alpha_aff)\n3. Compute complementarity after affine step: mu_aff\n4. Compute centering parameter: sigma = (mu_aff/mu)^3\n5. Use sigma in corrector step\n\nThe centering parameter sigma controls the balance between:\n- sigma=0: Pure affine scaling (aggressive, may overshoot)\n- sigma=1: Pure centering (conservative, slow progress)\n\nKey parameter:\n- sigma_max_: Upper bound on sigma to prevent excessive centering"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpRestoRestoPhase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Recursive restoration for separable n,p variable initialization\n\nRestoRestorationPhase provides a specialized \"restoration within\nrestoration\" procedure for the MinC_1NrmRestorationPhase. It computes\noptimal values for the slack variables (n_c, p_c, n_d, p_d) by\ntreating them as separable from x and s."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing initial iterates\n\nIterateInitializer is the abstract base for strategies that\ncompute the starting point (x, s, y_c, y_d, z_L, z_U, v_L, v_U)\nfor the interior point algorithm."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for suggesting barrier parameter values\n\nMuOracle is the abstract interface for components that compute\nsuggested values for the barrier parameter mu in adaptive (non-monotone)\nbarrier updates."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for checking algorithm termination\n\nConvergenceCheck is the abstract base for convergence testing\nstrategies. Called each iteration to determine if optimization\nshould continue, has converged, or has failed."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpLoqoMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LOQO formula for barrier parameter selection\n\nLoqoMuOracle computes the barrier parameter using the heuristic\nfrom the LOQO solver (Vanderbei). This provides a simple formula\nbased on current complementarity.\n\nThe LOQO formula typically uses:\n  sigma = min(0.1, 100*mu)\n  mu_new = sigma * (current_complementarity / n)\n\nThis is a simple, stateless oracle that doesn't require solving\nan additional linear system (unlike probing or quality function).\n\nCompared to other strategies:\n- ProbingMuOracle: Requires affine step computation\n- QualityFunctionMuOracle: Requires 1D optimization\n- LoqoMuOracle: Direct formula, no extra computation"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpIpoptCalculatedQuantities.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cached computation of all derived quantities from iterates\n\nIpoptCalculatedQuantities is the central caching layer for computed\nvalues derived from the current/trial iterates in IpoptData:\n\nCached quantities include:\n- Slacks: slack_x_L, slack_x_U, slack_s_L, slack_s_U\n- Objective: f, grad_f, barrier_obj, grad_barrier_obj\n- Constraints: c, d, d-s, jac_c, jac_d, J^T*y products\n- Primal-dual: grad_lag_x/s, complementarity, relaxed_compl\n- Errors: primal/dual infeasibility, complementarity, nlp_error\n- Line search: frac_to_bound, sigma matrices"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpRestoMinC_1Nrm.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Restoration phase minimizing 1-norm of constraint violation\n\nMinC_1NrmRestorationPhase is the main restoration phase implementation.\nWhen the line search cannot make progress, it minimizes constraint\nviolation to find a feasible point from which optimization can continue.\n\nRestoration NLP formulation:\n  min  \u03c1 * ||[p_c; n_c; p_d; n_d]||_1 + (\u03b7/2) * ||D_r(x - x_ref)||_2^2\n  s.t. c(x) - p_c + n_c = 0\n       d_L <= d(x) - p_d + n_d <= d_U\n       x_L <= x <= x_U\n       p_c, n_c, p_d, n_d >= 0\n\nWhere:\n- \u03c1: Penalty on infeasibility (resto_penalty_parameter)\n- \u03b7: Proximity weight (resto_proximity_weight * sqrt(mu))\n- D_r: Diagonal scaling based on reference point\n- x_ref: Starting point for restoration\n\nKey behaviors:\n- Uses nested IpoptAlgorithm to solve restoration NLP\n- eq_mult_calculator_ reinitializes multipliers after restoration\n- bound_mult_reset_threshold_: Limits post-restoration bound multipliers\n- count_restorations_: Tracks restoration phase calls"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpDefaultIterateInitializer.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard initialization procedure for IPM iterates\n\nDefaultIterateInitializer computes starting points for all primal\nand dual variables based on user options and problem bounds.\n\nPrimal initialization (x, s):\n- Start from user-provided x0 or NLP default\n- Push away from bounds: x_new = max(x_L + \u03b5, min(x, x_U - \u03b5))\n- bound_push_, bound_frac_: Absolute/relative push parameters\n- least_square_init_primal_: Fit linearized constraints\n\nDual initialization:\n- Equality multipliers (y_c, y_d): Least-squares or zero\n- eq_mult_calculator_: Computes min ||y|| s.t. KKT gradient\n- constr_mult_init_max_: Reject large multiplier estimates\n- Bound multipliers (z_L, z_U, v_L, v_U):\n  - B_CONSTANT: bound_mult_init_val_\n  - B_MU_BASED: mu_init_ / slack\n\nWarm start:\n- warm_start_init_point_: Use warm_start_initializer_ instead\n- Delegates to WarmStartIterateInitializer\n\nStatic utilities:\n- push_variables(): Move point away from bounds\n- least_square_mults(): Compute y from gradient conditions"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpMuUpdate.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for updating barrier parameter mu\n\nMuUpdate is the abstract base for strategies that determine the\nbarrier parameter mu and fraction-to-boundary parameter tau for\neach iteration of the interior point method."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpIteratesVector.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Combined primal-dual iterate vector for IPM algorithm\n\nIteratesVector is a specialized CompoundVector with fixed 8 components\nrepresenting the complete primal-dual iterate of the interior point method:"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpPDFullSpaceSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Full-space primal-dual system solver with inertia correction\n\nPDFullSpaceSolver is the main implementation of PDSystemSolver.\nIt reduces the 8x8 primal-dual system to the 4x4 augmented system\nby eliminating bound multiplier equations:\n  d_z = S^{-1}(rhs_z - Z*P^T*d_x)\n\nKey features:\n- Iterative refinement with quality monitoring (residual_ratio)\n- Inertia correction via PDPerturbationHandler (adds delta_x, delta_c)\n- Automatic retries with increased pivot tolerance\n- Handles singular systems by adding regularization\n\nParameters:\n- min/max_refinement_steps: Iterative refinement bounds\n- residual_ratio_max: Acceptable solution quality threshold\n- neg_curv_test_tol: Tolerance for inertia heuristics"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Ipopt/src/Algorithm/IpOptErrorConvCheck.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Standard convergence check based on optimality error tolerances\n\nOptimalityErrorConvergenceCheck implements the standard termination\ncriteria for Ipopt based on KKT optimality conditions.\n\nOptimal convergence (tol):\n- Dual infeasibility <= dual_inf_tol_\n- Constraint violation <= constr_viol_tol_\n- Complementarity <= compl_inf_tol_\n- Overall scaled error <= tol\n\nAcceptable convergence (acceptable_tol):\n- Less stringent tolerances applied for acceptable_iter_ iterations\n- Terminates early if stuck near acceptable solution\n- acceptable_obj_change_tol_: Detects stagnation in objective\n\nFailure conditions:\n- max_iterations_: Iteration limit exceeded\n- max_wall_time_, max_cpu_time_: Time limits\n- diverging_iterates_tol_: Primal variables diverging\n- mu_target_: Target barrier parameter reached\n\nCurrentIsAcceptable():\n- Returns true if acceptable-level tolerances are met\n- Used by line search to decide on restoration phase"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Couenne/src/branch/CouenneComplBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for complementarity constraints"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "Couenne/src/branch/CouenneComplObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for complementarity constraints"
      }
    },
    {
      "from": "complementary_slackness",
      "to": "HiGHS/highs/ipm/ipx/iterate.h",
      "type": "implemented_in",
      "meta": {
        "brief": "IPM Iterate Management with Variable States\n\nManages the primal-dual iterate for interior point methods, including\nvariable states (fixed/free/barrier) and convergence monitoring."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "HiGHS/highs/ipm/ipx/crossover.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Crossover from Interior Point to Basic Solution\n\nConverts an interior point solution (all variables strictly between bounds)\nto a vertex (basic) solution required for simplex methods and post-processing."
      }
    },
    {
      "from": "complementary_slackness",
      "to": "HiGHS/highs/ipm/ipx/ipm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
      }
    },
    {
      "from": "newton_method",
      "to": "Clp/src/ClpInterior.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interior point (barrier) method for LP"
      }
    },
    {
      "from": "newton_method",
      "to": "Clp/src/ClpHelperFunctions.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "BLAS-1 style dense vector operations for Clp"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpLineSearch.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for globalization via line search\n\nLineSearch is the abstract base for all line search strategies\nin Ipopt's globalization framework. Given a search direction\n(from IpData.delta()), finds an acceptable trial point."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpLimMemQuasiNewtonUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Limited-memory quasi-Newton Hessian approximation (L-BFGS/SR1)\n\nLimMemQuasiNewtonUpdater maintains a low-rank approximation of the\nLagrangian Hessian using limited-memory BFGS or SR1 updates.\n\nCompact representation: W = \u03c3I + V*M^(-1)*V^T where\n- \u03c3: Scalar initialization factor (B0_ if diagonal)\n- V, U: Low-rank update matrices derived from S, Y history\n- S_: Matrix of step vectors s_k = x_{k+1} - x_k\n- Y_: Matrix of gradient differences y_k = \u2207L_{k+1} - \u2207L_k\n\nUpdate types (limited_memory_update_type_):\n- BFGS: Positive definite secant update, may skip if s'y <= 0\n- SR1: Symmetric rank-1, can capture negative curvature\n\nInitialization (limited_memory_initialization_):\n- SCALAR1-4: Various heuristics for \u03c3 based on y'y/s'y\n- CONSTANT: Fixed \u03c3 = limited_memory_init_val_\n\nKey parameters:\n- limited_memory_max_history_: Maximum stored (s,y) pairs\n- limited_memory_max_skipping_: Reset after N consecutive skips\n- sigma_safe_min/max_: Safeguards for initialization factor\n\nRestoration phase (update_for_resto_):\n- Structured update accounting for \u03b7*D_r*x quadratic term\n- Ypart_ stores constraint-only gradient differences"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpProbingMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's probing heuristic for barrier parameter selection\n\nProbingMuOracle implements Mehrotra's predictor-corrector approach\nto compute the barrier parameter mu. This is the strategy used in\nmany interior point codes like LOQO and PCx.\n\nAlgorithm:\n1. Compute affine scaling direction (predictor step) with sigma=0\n2. Find maximum step to boundary (alpha_aff)\n3. Compute complementarity after affine step: mu_aff\n4. Compute centering parameter: sigma = (mu_aff/mu)^3\n5. Use sigma in corrector step\n\nThe centering parameter sigma controls the balance between:\n- sigma=0: Pure affine scaling (aggressive, may overshoot)\n- sigma=1: Pure centering (conservative, slow progress)\n\nKey parameter:\n- sigma_max_: Upper bound on sigma to prevent excessive centering"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpPDSearchDirCalc.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Newton search direction computation via primal-dual system\n\nPDSearchDirCalculator is the standard SearchDirectionCalculator\nimplementation that computes the Newton step by solving the\nprimal-dual KKT system."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpGradientScaling.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP scaling based on gradient magnitudes at initial point\n\nGradientScaling computes scaling factors for the NLP based on the\nmaximum gradient norms at the user-provided starting point. This\nimproves problem conditioning by normalizing objective and constraint\nmagnitudes."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpHessianUpdater.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for Hessian computation/approximation\n\nHessianUpdater is the abstract base for strategies that provide\nthe Hessian of the Lagrangian (or an approximation) to the algorithm.\nThe result is stored in IpData.W()."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpPDSystemSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for solving the full primal-dual KKT system\n\nPDSystemSolver defines the interface for solving the 8x8 block\nprimal-dual linear system that arises at each Newton iteration:\n\n  [W    0   Jc^T  Jd^T  -Px_L  Px_U   0     0   ] [dx  ]   [rx  ]\n  [0    0    0    -I     0     0    -Pd_L  Pd_U ] [ds  ]   [rs  ]\n  [Jc   0    0     0     0     0     0     0   ] [dyc ] = [rc  ]\n  [Jd  -I    0     0     0     0     0     0   ] [dyd ]   [rd  ]\n  [Zl  Px_L^T ...                              ] [dzL ]   [rzL ]\n  [...]                                          [dzU ]   [rzU ]\n  [...]                                          [dvL ]   [rvL ]\n  [...]                                          [dvU ]   [rvU ]\n\nImplementations typically reduce this to the 4x4 augmented system\nby eliminating the bound multiplier equations, then solve via\nAugSystemSolver. The key implementation is PDFullSpaceSolver."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpNLPBoundsRemover.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP adapter that converts variable bounds to inequality constraints\n\nNLPBoundsRemover is an NLP adapter primarily used for inexact/iterative\nlinear solvers that require the KKT system to have a specific structure\nwithout bound constraints."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpQualityFunctionMuOracle.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Barrier parameter selection via quality function minimization\n\nQualityFunctionMuOracle computes the barrier parameter by minimizing\na quality function that measures how close the predictor-corrector\nstep brings the iterate to optimality.\n\nAlgorithm:\n1. Compute affine scaling direction (mu = 0)\n2. Compute centering direction (pure mu term)\n3. For combined step (sigma * centering + affine), find optimal sigma\n4. Convert optimal sigma to mu = sigma * average_complementarity\n\nQuality function Q(sigma) measures (configurable):\n- Primal-dual error norm after step\n- Centrality deviation from mu-centered path\n- Balancing term for primal/dual progress\n\nConfiguration options:\n- quality_function_norm_: NM_NORM_1, NM_NORM_2, NM_NORM_MAX\n- quality_function_centrality_: CEN_NONE, CEN_LOG, CEN_RECIPROCAL\n- quality_function_balancing_term_: BT_NONE, BT_CUBIC\n\nGolden section search:\n- Finds optimal sigma in [sigma_min_, sigma_max_]\n- Tolerances: quality_function_section_sigma_tol_, _qf_tol_\n- Maximum iterations: quality_function_max_section_steps_"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpIpoptAlg.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Ipopt algorithm orchestrating the interior point method\n\nIpoptAlgorithm is the central class implementing the primal-dual\ninterior point method. Each iteration:\n1. UpdateHessian() - Evaluate or update Hessian approximation\n2. UpdateBarrierParameter() - Adjust mu using chosen strategy\n3. ComputeSearchDirection() - Solve KKT system for Newton step\n4. ComputeAcceptableTrialPoint() - Line search with filter/merit\n5. AcceptTrialPoint() - Update current iterate\n\nUses Strategy pattern: line search, mu update, convergence check\nare all pluggable components configured via AlgorithmBuilder."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/IpSearchDirCalculator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strategy interface for computing the Newton search direction\n\nSearchDirectionCalculator is the strategy interface for computing\nthe search direction at each IPM iteration. The computed direction\nis stored in IpData().delta() (an IteratesVector)."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/LinAlg/IpMultiVectorMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Tall-skinny matrix stored as collection of column Vectors\n\nMultiVectorMatrix represents an m x k matrix (k << m) where each\ncolumn is stored as a separate Vector. Efficient for:\n- Limited-memory quasi-Newton: store recent gradient differences\n- Low-rank updates: V*V^T matvec via two sequential operations"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/LinAlg/IpLowRankUpdateSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Symmetric matrix as low-rank update: M = D + V*V^T - U*U^T\n\nLowRankUpdateSymMatrix represents matrices in factored form:\n  M = P_LR * (D + V*V^T - U*U^T) * P_LR^T  (if reduced_diag)\n  M = D + P_LR * (V*V^T - U*U^T) * P_LR^T  (otherwise)"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/LinAlg/IpDenseSymMatrix.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dense symmetric matrix in BLAS lower-triangular storage\n\nDenseSymMatrix stores only the lower triangle in column-major format,\nfollowing BLAS/LAPACK conventions for symmetric matrices."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/contrib/CGPenalty/IpCGPerturbationHandler.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Perturbation handler for Chen-Goldfarb penalty method"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/contrib/CGPenalty/IpCGSearchDirCalc.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Search direction calculator for Chen-Goldfarb penalty method"
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactNewtonNormal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Newton normal step from slack-scaled augmented system\n\nInexactNewtonNormalStep computes the normal step component by\nsolving a reduced system derived from the slack-scaled KKT system."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactAlgBuilder.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Builder for inexact step computation algorithm variant\n\nInexactAlgorithmBuilder constructs the complete IpoptAlgorithm\nconfigured for inexact Newton methods using iterative linear solvers."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactCq.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cached quantities for inexact Newton / Chen-Goldfarb penalty method\n\nInexactCq provides precomputed and cached quantities specific to the\ninexact Newton algorithm, extending IpoptCalculatedQuantities."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactDoglegNormal.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dogleg trust region method for normal step computation\n\nInexactDoglegNormalStep computes the normal step using a dogleg\napproach that combines steepest descent and Newton directions\nwithin a trust region."
      }
    },
    {
      "from": "newton_method",
      "to": "Ipopt/src/Algorithm/Inexact/IpInexactNormalStepCalc.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for normal step computation\n\nInexactNormalStepCalculator defines the interface for computing\nthe normal step component in the inexact Newton decomposition."
      }
    },
    {
      "from": "newton_method",
      "to": "Couenne/src/expression/operators/CouenneExprPow.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Power expression w = x^k with convexification"
      }
    },
    {
      "from": "newton_method",
      "to": "HiGHS/highs/ipm/ipx/ipm.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Mehrotra's Predictor-Corrector Interior Point Method\n\nImplements an interior point method (IPM) for linear programming using\nMehrotra's predictor-corrector technique with two KKT solves per iteration."
      }
    },
    {
      "from": "newton_method",
      "to": "HiGHS/highs/ipm/ipx/kkt_solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "KKT System Solver Interface for Interior Point Methods\n\nDefines the interface for solving the augmented system (KKT system) that\narises in each iteration of primal-dual interior point methods."
      }
    },
    {
      "from": "convexity",
      "to": "Clp/src/ClpQuadraticObjective.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic objective function for convex QP (x'Qx/2 + c'x)\n\nImplements convex quadratic objectives for quadratic programming.\nThe quadratic term is stored as a CoinPackedMatrix Q, supporting\nboth full symmetric and half (lower triangular) storage."
      }
    },
    {
      "from": "convexity",
      "to": "Clp/src/ClpConstraintQuadratic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic constraint implementation: x'Qx + c'x \u2264 b\n\nImplements ClpConstraint for quadratic constraints. The constraint\nfunction is: 0.5 * sum_{ij}(Q_ij * x_i * x_j) + sum_j(c_j * x_j) \u2264 b"
      }
    },
    {
      "from": "convexity",
      "to": "ADOL-C/ADOL-C/include/adolc/drivers/psdrivers.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Drivers for piecewise smooth (PS) functions with abs-normal form\n\nProvides differentiation tools for functions containing absolute values\nand other piecewise linear operations. These functions are not classically\ndifferentiable at kink points, but have well-defined generalized derivatives."
      }
    },
    {
      "from": "convexity",
      "to": "Cbc/src/CbcHeuristicDW.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Dantzig-Wolfe decomposition based heuristic\nCopyright (C) 2006, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcHeuristicDW: Advanced heuristic exploiting block structure.\nVery compute-intensive - detects and exploits Dantzig-Wolfe\ndecomposable structure in the constraint matrix."
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaNlpOptim.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP-based outer approximation cut generator\n\nGenerates OA cuts by solving NLP relaxations at B&B nodes, rather than\nat integer feasible points (as in classical OA). More expensive per cut,\nbut can improve bounds at fractional nodes."
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaDecBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for Outer Approximation (OA) decomposition algorithms\n\nImplements the foundation for OA-based MINLP algorithms. OA iterates between\nsolving MILP subproblems and NLP subproblems, generating linear outer\napproximations of the nonlinear constraints.\n\n**OA algorithm outline:**\n1. Solve MILP relaxation \u2192 get integer solution x*\n2. Fix integers to x*, solve NLP \u2192 get nonlinear solution y*\n3. Generate linearization cuts at y* (gradient-based)\n4. Add cuts to MILP, repeat until convergence\n\n**Key components:**\n- solverManip: RAII helper to save/restore solver state\n- performOa(): Virtual method implementing specific OA variant\n- post_nlp_solve(): Handle NLP solution and update bounds\n\n**Parameters:**\n- global_: Add cuts globally (valid at all nodes)\n- addOnlyViolated_: Only add cuts violated by current solution\n- maxLocalSearch_: Limit on local search iterations"
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/experimental/Separable/BonHeuristicInnerApproximation.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bonmin inner approximation heuristic for MINLP\n\nPrimal heuristic using inner approximation of feasible region.\nGenerates feasible MINLP solutions from LP relaxations."
      }
    },
    {
      "from": "convexity",
      "to": "Bonmin/experimental/Separable/BonOuterDescription.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bonmin outer approximation description for convex MINLP\n\nOuter approximation (OA) cut management for MINLP.\nLinearization-based approach for convex MINLP."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/branch/CouenneChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection for branching in global optimization"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Three-way spatial branching for continuous variables"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/branch/CouenneBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/branch/CouenneObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Orbital branching object using symmetry"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/branch/CouenneSOSObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Special Ordered Set (SOS) branching for Couenne"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/branch/CouenneChooseStrong.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strong branching for global MINLP optimization\n\nExtends Bonmin's strong branching to handle nonconvex constraints\nby evaluating actual LP bound improvement from branching."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/bound_tightening/CouenneAggrProbing.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Aggressive probing for bound tightening\n\nImplements Optimality-Based Bound Tightening (OBBT) through aggressive\nprobing. Temporarily fixes a variable bound and solves the resulting\nsubproblem to determine if a tighter bound is achievable."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/problem/CouenneProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/heuristics/CouenneFeasPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/expression/operators/CouenneExprPow.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Power expression w = x^k with convexification"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/expression/operators/CouenneExprMul.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic expression with alpha-convexification"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Trilinear product expression w = x*y*z"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bound tightening from pairs of linear constraints"
      }
    },
    {
      "from": "convexity",
      "to": "Couenne/src/cut/crossconv/CouenneCrossConv.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cuts from redundant relationships between auxiliary variables"
      }
    },
    {
      "from": "convexity",
      "to": "Dip/Dip/src/DecompVar.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Column generation variable (lambda) representation\n\nDecompVar represents a column in the Dantzig-Wolfe reformulation.\nEach lambda_s corresponds to an extreme point s of a subproblem\npolyhedron: conv{x : A'x >= b', x integer}."
      }
    },
    {
      "from": "convexity",
      "to": "Dip/Dip/src/DecompAlgoPC.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Price-and-Cut algorithm (Dantzig-Wolfe decomposition with cuts)\n\nDecompAlgoPC implements the most powerful DIP algorithm combining:\n- Column generation (pricing subproblems)\n- Cut generation (violated inequalities)\n- Branch-and-bound integration via ALPS"
      }
    },
    {
      "from": "convexity",
      "to": "Gravity/include/gravity/expr.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Expression tree nodes for unary and binary operations\n\nExpressions are the building blocks for functions and constraints."
      }
    },
    {
      "from": "convexity",
      "to": "Gravity/include/gravity/func.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Expression functions with automatic differentiation and convexity tracking\n\nThe func class represents mathematical expressions with symbolic analysis."
      }
    },
    {
      "from": "convexity",
      "to": "HiGHS/highs/qpsolver/factor.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QP reduced Hessian Cholesky factorization\n\nBasis factorization for QP solver. Cholesky decomposition\nof reduced Hessian Z'QZ for efficient direction computation."
      }
    },
    {
      "from": "convexity",
      "to": "HiGHS/highs/qpsolver/a_quass.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "HiGHS QUASS QP algorithm\n\nQUASS (QUadratic Active Set Solver) main algorithm.\nPrimal active set method for convex QP."
      }
    },
    {
      "from": "convexity",
      "to": "SHOT/src/NLPSolver/NLPSolverCuttingPlaneMinimax.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cutting-plane solver for minimax LP problems\n\nBuilt-in LP-based solver for simple minimax problems.\n\n**NLPSolverCuttingPlaneMinimax Class:**\n- Uses MIP solver (CPLEX/Gurobi/Cbc) as LP engine\n- Iteratively adds cutting planes\n- No external NLP solver dependency\n\n**Minimax Problem Form:**\n- min t\n- s.t. f_i(x) <= t for all i\n\n**Use Case:**\n- Finding interior points when Ipopt unavailable\n- Solving auxiliary minimax subproblems"
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/include/cppad/cppad.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Contains all variables and functions defined by CppAD package"
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/include/cppad/core/sparse_jac.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Sparse Jacobian computation using graph coloring"
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/include/cppad/core/reverse.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Reverse mode automatic differentiation"
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/include/cppad/core/ad.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core AD<Base> automatic differentiation scalar type\n\nAD<Base> is the fundamental type for automatic differentiation.\nOperations on AD<Base> values are recorded on a \"tape\" which can\nlater be used to compute derivatives."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "CppAD/include/cppad/core/forward/forward.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Core AD functionality: forward mode differentiation"
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/checkpointing.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Checkpointing support for memory-efficient reverse mode AD\n\nImplements checkpointing (also known as \"time-stepping\" or \"revolve\")\nfor computing adjoints of long time-stepping computations with bounded\nmemory. Instead of storing all intermediate states, only selected\n\"checkpoints\" are stored, and segments are recomputed as needed."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/adolc.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Master include file for ADOL-C automatic differentiation library\n\nADOL-C (Automatic Differentiation by Overloading in C++) computes derivatives\nof mathematical functions via operator overloading and tape-based recording.\nRecords computation as a \"tape\" then replays in forward/reverse mode."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/revolve.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Optimal binomial checkpointing for memory-efficient reverse mode\n\nImplements the revolve algorithm (Griewank & Walther) for optimal\ncheckpoint placement in reverse mode automatic differentiation."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/adtl.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tape-less (traceless) forward-mode automatic differentiation\n\nProvides the adtl::adouble class for direct forward-mode AD without\ntape recording. Each adouble carries both its value and directional\nderivatives, which are propagated immediately through operations."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/tape_interface.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Tape management interface for ADOL-C automatic differentiation\n\nProvides functions for managing the \"tape\" - a recorded sequence of\noperations that can be replayed in forward or reverse mode to compute\nderivatives."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/adtb_types.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Core AD types: adouble, pdouble, and tape_location\n\nDefines the fundamental types for tape-based automatic differentiation:\n\n- **adouble**: Active double that records operations on the tape.\n  Use for variables whose derivatives you want to compute.\n\n- **pdouble**: Parameter double for non-differentiable constants that\n  can be changed without re-taping. Use for parameters you want to\n  vary across multiple derivative evaluations.\n\n- **tape_location<T>**: RAII wrapper managing tape location allocation\n  and deallocation for adouble/pdouble."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/interfaces.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Low-level forward and reverse mode interfaces for tape evaluation\n\nProvides the core differentiation routines that evaluate recorded tapes\nin forward mode (computing directional derivatives) and reverse mode\n(computing adjoints/gradients). These are the building blocks used by\nhigher-level drivers like gradient() and hessian()."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/sparse/sparsedrivers.h",
      "type": "implemented_in",
      "meta": {
        "brief": "High-level drivers for sparse Jacobian and Hessian computation\n\nProvides efficient computation of sparse derivatives by exploiting\nsparsity structure using graph coloring and compressed computation."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/drivers/taylor.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Higher-order derivative tensors and implicit function differentiation\n\nProvides drivers for computing higher-order derivative tensors and\ndifferentiating through implicit/inverse functions."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/drivers/odedrivers.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Taylor-based ODE integration drivers\n\nProvides drivers for solving and differentiating ODEs of the form\nx' = f(x) using Taylor series expansion. The tape records f(x),\nthen these drivers compute higher-order Taylor coefficients."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "ADOL-C/ADOL-C/include/adolc/drivers/drivers.h",
      "type": "implemented_in",
      "meta": {
        "brief": "High-level driver functions for derivative computation\n\nProvides convenient functions for computing common derivative quantities:\n- gradient(): First derivative of scalar function (\u2207f)\n- jacobian(): First derivative of vector function (\u2202F/\u2202x)\n- hessian(): Second derivative of scalar function (\u2207\u00b2f)\n- hess_vec(): Hessian-vector product (\u2207\u00b2f \u00b7 v)\n- jac_vec(): Jacobian-vector product (J \u00b7 v)\n- vec_jac(): Vector-Jacobian product (u^T \u00b7 J)\n\nThese drivers wrap the lower-level forward/reverse interfaces and handle\nmemory allocation and mode selection automatically. All functions require\na pre-recorded tape (via trace_on/trace_off)."
      }
    },
    {
      "from": "automatic_differentiation",
      "to": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Osi/src/Osi/OsiRowCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Row-based cutting plane (linear inequality)\n\nRow cuts are the most common form of cutting planes, representing\na linear inequality constraint: lb <= a'x <= ub"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Osi/src/Osi/OsiCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cutting planes in branch-and-cut\n\nCutting planes are linear inequalities that can be added to an LP\nrelaxation to tighten the formulation without cutting off any\ninteger-feasible solutions."
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cbc/src/CbcModel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main branch-and-cut MIP solver class\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcModel is the central class for COIN-OR branch-and-cut MIP solving.\nKey methods:\n- initialSolve(): Solve LP relaxation\n- branchAndBound(): Run B&C algorithm to optimality\n\nArchitecture:\n- CbcNode/CbcNodeInfo: Subproblem representation in search tree\n- CbcTree: Priority queue of live nodes (heap)\n- CbcCutGenerator: Wrapper for CGL cut generators\n- CbcHeuristic: Primal heuristics for finding solutions\n- CbcBranchingObject: Branching decisions"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cbc/src/CbcBranchCut.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching by adding cuts (split disjunctions)\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchCut and CbcCutBranchingObject: Branch by adding cuts\nrather than tightening variable bounds. Implements split disjunctions\nwhere each branch arm adds a different cut to the LP."
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cgl/src/CglRedSplit/CglRedSplit.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Reduce-and-Split cuts for enhanced Gomory generation"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cgl/src/CglOddHole/CglOddHole.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Odd hole cuts from conflict graphs\n\nGenerates odd hole inequalities based on the method from\nGrotschel, Lovasz, and Schrijver (1988). An odd hole is a\nchordless cycle of odd length in the conflict graph."
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cgl/src/CglCommon/CglCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for all CGL cutting plane generators\n\nDefines the interface that all cut generators must implement. In MIP\nbranch-and-cut, cutting planes tighten the LP relaxation to cut off\nfractional solutions while keeping all integer-feasible points."
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "Cgl/src/CglZeroHalf/CglZeroHalf.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Zero-half ({0,1/2}) cutting planes\n\nGenerates {0,1/2}-cuts by taking mod-2 combinations of constraint rows.\nBased on Andreello, Caprara, Fischetti (INFORMS J. Computing, 2007).\n\nTheory: If we combine constraints with {0, 1/2} multipliers such that\nall LHS coefficients become even, we get a valid cut by dividing by 2\nand rounding down the RHS.\n\nAlgorithm outline:\n1. Convert constraint matrix to integers (scaling)\n2. Reduce coefficients mod 2 (0-1 matrix)\n3. Find combinations where LHS sums to 0 mod 2 per column\n4. These yield valid {0,1/2}-cuts when RHS is odd\n\nInternal representation:\n- mr_, mc_, mnz_: Matrix dimensions and nonzeros\n- mtbeg_, mtcnt_, mtind_, mtval_: Sparse row storage\n- vlb_, vub_: Variable bounds (integer scaled)\n- Cgl012Cut cutInfo_: Separation algorithm state\n\nUses Dijkstra shortest path (cglShortestPath) for separation."
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "SYMPHONY/include/symphony.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main public API for SYMPHONY MILP solver\n\nSYMPHONY is a parallel branch-cut-price framework for solving\nMixed Integer Linear Programs (MILPs). Supports both shared-memory\nand distributed-memory (MPI) parallelism."
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "HiGHS/highs/Highs.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main HiGHS solver class - high-performance LP/MIP/QP optimization\n\nHiGHS (High-performance Interior point and Gradient descent Solvers) is\nan open-source solver for LP, MIP, and convex QP problems.\n\n**Highs Class (Main API):**\nPrimary interface for model input, solving, and solution retrieval:\n- passModel(): Load LP/QP/MIP from HighsModel, HighsLp, or raw arrays\n- run(): Solve the incumbent model\n- getSolution(), getBasis(): Retrieve solution and basis\n- getModelStatus(): Check optimization result\n\n**Solving Capabilities:**\n- LP: Dual/primal simplex (HEkk) or interior point (IPX)\n- MIP: Branch-and-cut with presolve, cuts, and heuristics\n- QP: Convex quadratic programming via interior point or active set\n\n**Model Modification:**\n- addCol/addRow, deleteCols/deleteRows: Incremental model building\n- changeColBounds, changeRowBounds, changeColCost: Hot-start friendly\n- changeCoeff: Modify individual matrix coefficients\n\n**Basis Operations:**\n- getBasisInverseRow/Col: Access B^{-1} for advanced use\n- getBasisSolve/getBasisTransposeSolve: Solve B*x=b or B'*x=b\n- getReducedRow/Col: Compute B^{-1}*A columns\n\n**Options and Info:**\n- setOptionValue/getOptionValue: Configure solver behavior\n- getInfo: Retrieve solve statistics (iterations, time, etc.)"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "HiGHS/highs/mip/HighsMipSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Branch-and-cut MIP solver"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "HiGHS/highs/mip/HighsSeparation.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Cut generation orchestration for MIP solver"
      }
    },
    {
      "from": "Gomory_cuts",
      "to": "HiGHS/highs/mip/HighsSeparator.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for cut separators"
      }
    },
    {
      "from": "McCormick_envelopes",
      "to": "Cbc/src/CbcLinked.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended solver for nonlinear and bilinear problems"
      }
    },
    {
      "from": "McCormick_envelopes",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "McCormick_envelopes",
      "to": "Couenne/src/expression/operators/CouenneExprMul.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
      }
    },
    {
      "from": "FBBT",
      "to": "Cbc/src/CbcSimpleIntegerPseudoCost.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Integer variable with static pseudocosts\nCopyright (C) 2002, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcSimpleIntegerPseudoCost: Extends CbcSimpleInteger with static\npseudocost estimates for branch direction preference:\n- upPseudoCost_: Estimated objective increase per unit ceiling\n- downPseudoCost_: Estimated objective increase per unit floor"
      }
    },
    {
      "from": "FBBT",
      "to": "Couenne/src/branch/CouenneSOSObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Special Ordered Set (SOS) branching for Couenne"
      }
    },
    {
      "from": "FBBT",
      "to": "Couenne/src/bound_tightening/CouenneFixPoint.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fixpoint-based bound tightening via constraint propagation\n\nImplements Feasibility-Based Bound Tightening (FBBT) using fixpoint\niteration. Propagates bounds through expression DAG until no further\ntightening is possible."
      }
    },
    {
      "from": "FBBT",
      "to": "Couenne/src/problem/CouenneProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
      }
    },
    {
      "from": "FBBT",
      "to": "Couenne/src/bound_tightening/twoImpliedBT/CouenneTwoImplied.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bound tightening from pairs of linear constraints"
      }
    },
    {
      "from": "mixed_integer_programming",
      "to": "Cbc/src/CbcBranchAllDifferent.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "All-different constraint for integer variables\nCopyright (C) 2004, IBM Corporation and others. All Rights Reserved.\nThis code is licensed under the terms of the Eclipse Public License (EPL).\n\nCbcBranchAllDifferent: Enforces that a set of integer variables\nmust all have different values. When two variables i,j have the\nsame value, creates branching disjunction:\n  x_i <= x_j - 1  OR  x_i >= x_j + 1"
      }
    },
    {
      "from": "mixed_integer_programming",
      "to": "Cgl/src/CglTwomir/CglTwomir.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Two-step MIR (TMIR) cut generator\n\nGenerates tMIR and 2-step MIR cuts by applying the MIR inequality\nrecursively with different scaling factors. More general than\nsimple Gomory or MIR cuts."
      }
    },
    {
      "from": "mixed_integer_programming",
      "to": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
      }
    },
    {
      "from": "mixed_integer_programming",
      "to": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
      }
    },
    {
      "from": "mixed_integer_programming",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
      }
    },
    {
      "from": "mixed_integer_programming",
      "to": "SHOT/src/MIPSolver/IMIPSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for MIP solver backends\n\nPure virtual interface for dual problem MIP solvers.\n\n**Problem Construction:**\n- initializeProblem(), finalizeProblem(): Setup/teardown\n- addVariable(): With type, bounds, and semi-bounds\n- addLinearTermToObjective/Constraint(): Build incrementally\n- addQuadraticTermToObjective/Constraint(): For MIQP/MIQCQP\n\n**Solution Methods:**\n- solveProblem(): Execute MIP solver\n- repairInfeasibility(): Attempt feasibility repair\n- getObjectiveValue(), getDualObjectiveValue(): Bounds\n- getVariableSolution(), getAllVariableSolutions(): Points\n\n**Hyperplane/Cut Management:**\n- createHyperplane(): Add supporting hyperplane linearization\n- createInteriorHyperplane(): Interior point cuts\n- createIntegerCut(): No-good cuts for integer variables\n\n**Bound Management:**\n- setCutOff(): Objective cutoff for pruning\n- fixVariable(), unfixVariables(): For integer fixing\n- presolveAndUpdateBounds(): Bound tightening\n\n**Implementations:**\n- MIPSolverCplex, MIPSolverGurobi, MIPSolverCbc\n- SingleTree variants for callback-based cut addition"
      }
    },
    {
      "from": "MIR_cuts",
      "to": "Cgl/src/CglTwomir/CglTwomir.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Two-step MIR (TMIR) cut generator\n\nGenerates tMIR and 2-step MIR cuts by applying the MIR inequality\nrecursively with different scaling factors. More general than\nsimple Gomory or MIR cuts."
      }
    },
    {
      "from": "MIR_cuts",
      "to": "Cgl/src/CglMixedIntegerRounding/CglMixedIntegerRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Mixed Integer Rounding (MIR) cuts via Marchand-Wolsey procedure"
      }
    },
    {
      "from": "MIR_cuts",
      "to": "Cgl/src/CglMixedIntegerRounding2/CglMixedIntegerRounding2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Enhanced MIR (Mixed Integer Rounding) cut generator"
      }
    },
    {
      "from": "MIR_cuts",
      "to": "Bonmin/src/Algorithms/QuadCuts/BonLinearCutsGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Composite cut generator managing multiple linear cut generators\nCopyright (C) International Business Machines Corporation 2007.\nAll Rights Reserved.\nThis code is published under the Eclipse Public License."
      }
    },
    {
      "from": "MIR_cuts",
      "to": "HiGHS/highs/mip/HighsModkSeparator.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Class for separating maximally violated mod-k MIR cuts"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonBranchingTQP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP adapter for strong branching in MINLP\nCopyright (C) International Business Machines Corporation and\nCarnegie Mellon University 2006, 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonTMINLP2TNLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Adapter converting TMINLP (MINLP) to TNLP (NLP) for Ipopt"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonStrongBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract base class for strong branching NLP solves"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for NLP solvers used in branch-and-bound"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonTMINLP.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for Mixed-Integer Nonlinear Programs (MINLP)"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/BonBabSetupBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base configuration class for branch-and-bound MINLP solvers\n\nAggregates all components needed to run branch-and-bound: NLP solver,\ncut generators, heuristics, branching rules, and tree traversal strategy.\nServes as the central configuration point for Bonmin algorithms.\n\n**Key components:**\n- nonlinearSolver_: OsiTMINLPInterface for NLP subproblems\n- cutGenerators_: List of CglCutGenerator (OA, ECP, Gomory, etc.)\n- heuristics_: List of CbcHeuristic (feasibility pump, rounding, etc.)\n- branchingMethod_: OsiChooseVariable for variable selection\n\n**Tree search strategies:**\n- NodeComparison: bestBound, DFS, BFS, dynamic, bestGuess\n- TreeTraversal: HeapOnly, DiveFromBest, ProbedDive, DfsDiveFromBest\n\n**Branching strategies (VarSelectStra_Enum):**\n- MOST_FRACTIONAL: Simple, fast, often poor\n- STRONG_BRANCHING: Evaluate candidates via LP/NLP solves\n- RELIABILITY_BRANCHING: Use pseudo-costs when trusted"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/Ipopt/BonIpoptSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Ipopt implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Interfaces/Filter/BonFilterSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "FilterSQP implementation of TNLPSolver for NLP subproblems"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicFPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic for MINLP\n\nImplements the Feasibility Pump algorithm adapted for nonlinear problems.\nAlternates between:\n1. Rounding to nearest integer solution\n2. Projecting back to feasible continuous space via NLP\n\n**Classes:**\n- HeuristicFPump: Main feasibility pump heuristic (CbcHeuristic)\n- RoundingFPump: Helper for intelligent rounding considering constraints"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonLocalSolverBasedHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for heuristics using local NLP/MINLP solves"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonFixAndSolveHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Fix-and-Solve heuristic for MINLP"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicLocalBranching.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Local Branching heuristic for MINLP improvement"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonHeuristicRINS.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Relaxation Induced Neighborhood Search (RINS) heuristic for MINLP"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/CbcBonmin/Heuristics/BonMilpRounding.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "MILP-based rounding heuristic for MINLP"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/Branching/BonQpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "QP-based strong branching solver\n\nImplements strong branching by solving QP approximations of the NLP\nsubproblems. Faster than full NLP but more accurate than LP."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/Branching/BonLpBranchingSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "LP-based strong branching solver using ECP cuts\n\nImplements strong branching by solving LP relaxations enhanced with\nExtended Cutting Plane (ECP) cuts, avoiding full NLP solves."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonFpForMinlp.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump for MINLP via Outer Approximation\nCopyright (C) CNRS 2008. All Rights Reserved.\nThis code is published under the Eclipse Public License.\n\nMinlpFeasPump: Feasibility Pump implementation for MINLP using OA\ndecomposition. Alternates between solving MIP with distance-to-integer\nobjective and NLP with fixed integers to find feasible solutions."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaFeasChecker.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OA-based feasibility checker for MILP solutions\n\nChecks if MILP solution is feasible for original MINLP by evaluating\nnonlinear constraints and generating OA/Benders cuts if infeasible."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOaDecBase.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Base class for Outer Approximation (OA) decomposition algorithms\n\nImplements the foundation for OA-based MINLP algorithms. OA iterates between\nsolving MILP subproblems and NLP subproblems, generating linear outer\napproximations of the nonlinear constraints.\n\n**OA algorithm outline:**\n1. Solve MILP relaxation \u2192 get integer solution x*\n2. Fix integers to x*, solve NLP \u2192 get nonlinear solution y*\n3. Generate linearization cuts at y* (gradient-based)\n4. Add cuts to MILP, repeat until convergence\n\n**Key components:**\n- solverManip: RAII helper to save/restore solver state\n- performOa(): Virtual method implementing specific OA variant\n- post_nlp_solve(): Handle NLP solution and update bounds\n\n**Parameters:**\n- global_: Add cuts globally (valid at all nodes)\n- addOnlyViolated_: Only add cuts violated by current solution\n- maxLocalSearch_: Limit on local search iterations"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonOACutGenerator2.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Classical Outer Approximation cut generator for MINLP\n\nImplements the standard OA algorithm of Duran & Grossmann (1986) for convex\nMINLP. Generates linearization cuts by Taylor expansion of nonlinear\nconstraints at NLP solutions."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/src/Algorithms/QuadCuts/BonOuterApprox.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Concrete outer approximation extractor for MINLP\n\nBuilds linear outer approximations of nonlinear constraints by\nlinearizing at a given point (typically NLP solution)."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Bonmin/experimental/Separable/BonHeuristicInnerApproximation.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Bonmin inner approximation heuristic for MINLP\n\nPrimal heuristic using inner approximation of feasible region.\nGenerates feasible MINLP solutions from LP relaxations."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Couenne/src/branch/CouenneChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection for branching in global optimization"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Couenne/src/branch/CouenneNauty.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Interface to nauty library for symmetry detection\n\nWraps the nauty graph automorphism library to detect symmetries\nin MINLP problems. Symmetry information enables orbital branching\nand isomorphism pruning to reduce the search space."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Couenne/src/branch/CouenneChooseStrong.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Strong branching for global MINLP optimization\n\nExtends Bonmin's strong branching to handle nonconvex constraints\nby evaluating actual LP bound improvement from branching."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Couenne/src/problem/CouenneProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Couenne/src/heuristics/CouenneFeasPump.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Feasibility Pump heuristic for nonconvex MINLP\n\nAlternates between NLP and MILP solves to find feasible solutions:\n- MILP phase: Find integer point closest to NLP solution\n- NLP phase: Find NLP-feasible point closest to integer solution"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP heuristic for near-integer B&B nodes"
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Gravity/include/gravity/solver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Unified solver interface for multiple optimization backends\n\nDispatches Gravity models to various solver implementations."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "Gravity/include/gravity/model.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Main optimization model class combining variables, constraints, objective\n\nThe Model class is the central container for building optimization problems."
      }
    },
    {
      "from": "mixed_integer_nonlinear_programming",
      "to": "SHOT/src/DualSolver.h",
      "type": "implemented_in",
      "meta": {
        "brief": "MIP-based dual bound computation via supporting hyperplanes\n\nManages the linearization-based dual problem."
      }
    },
    {
      "from": "nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonTNLPSolver.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Abstract interface for NLP solvers used in branch-and-bound"
      }
    },
    {
      "from": "nonlinear_programming",
      "to": "Bonmin/src/Interfaces/BonOsiTMINLPInterface.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "OsiSolverInterface wrapper for TMINLP problems"
      }
    },
    {
      "from": "nonlinear_programming",
      "to": "Bonmin/src/Algorithms/BonBonminSetup.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main Bonmin algorithm configuration and initialization\n\nExtends BabSetupBase with Bonmin-specific algorithm selection and\ninitialization for all MINLP algorithms.\n\n**Algorithm enum:**\n- B_BB (0): NLP-based branch-and-bound\n- B_OA (1): Pure Outer Approximation decomposition\n- B_QG (2): Quesada-Grossmann branch-and-cut\n- B_Hyb (3): Hybrid OA with NLP at nodes (default)\n- B_Ecp (4): Extended Cutting Plane (FilMINT-style)\n- B_IFP (5): Iterated Feasibility Pump\n\n**Initialization:**\n- initializeBBB(): Pure B&B with NLP at every node\n- initializeBHyb(): Hybrid with OA cuts + occasional NLP"
      }
    },
    {
      "from": "nonlinear_programming",
      "to": "Couenne/src/heuristics/BonNlpHeuristic.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "NLP heuristic for near-integer B&B nodes"
      }
    },
    {
      "from": "nonlinear_programming",
      "to": "SHOT/src/Model/Problem.h",
      "type": "implemented_in",
      "meta": {
        "brief": "Core problem representation with variables, constraints, and objective\n\nCentral data structure holding the optimization problem definition.\n\n**ProblemProperties Struct:**\n- Convexity classification (Convex, Nonconvex, NotSet)\n- Problem type flags (MINLP, MIQP, MILP, NLP, etc.)\n- Variable counts by type (real, binary, integer, auxiliary)\n- Constraint counts by type (linear, quadratic, nonlinear)\n\n**SpecialOrderedSet Struct:**\n- SOS1 (at most one variable nonzero) or SOS2 (contiguous nonzeros)\n- Variables and optional weights\n\n**Problem Class:**\n- allVariables, realVariables, binaryVariables, etc.\n- linearConstraints, quadraticConstraints, nonlinearConstraints\n- objectiveFunction (linear, quadratic, or nonlinear)\n- Sparsity patterns for Jacobian and Hessian\n- Feasibility bound propagation (FBBT) for tightening bounds\n\n**Key Methods:**\n- add(): Add variables, constraints, objective\n- finalize(): Compute properties and sparsity patterns\n- getMostDeviatingNumericConstraint(): Find worst violation\n- createCopy(): Clone for reformulation"
      }
    },
    {
      "from": "convexification",
      "to": "Bonmin/src/Algorithms/OaGenerators/BonEcpCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Extended Cutting Plane (ECP) cut generator for MINLP\n\nGenerates OA cuts iteratively at LP solution points, refining the\nlinear approximation without requiring NLP solves at every iteration."
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/disjunctive/CouenneDisjCuts.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Disjunctive cut generator for nonconvex MINLP\n\nGenerates lift-and-project style disjunctive cuts by solving a\nCut-Generating Linear Program (CGLP) for each disjunction."
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Three-way spatial branching for continuous variables"
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/branch/CouenneBranchingObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Spatial branching object for continuous and integer variables\n\nExecutes branching on a variable (which may be continuous) to\npartition the domain and tighten the convex relaxation."
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/branch/CouenneObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Branching object for auxiliary variables w = f(x)\n\nDefines branching for auxiliary variables based on their infeasibility\n|w - f(x)|. Creates branches to restore feasibility of the relation."
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Orbital branching object using symmetry"
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/branch/CouenneSOSObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Special Ordered Set (SOS) branching for Couenne"
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/problem/CouenneProblem.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Central MINLP problem representation with expression DAG\n\nThe heart of Couenne's global optimization approach. Represents MINLPs\nsymbolically as expression trees, enabling automatic convexification,\nbound propagation, and reformulation.\n\n**Key data structures:**\n- variables_: Original, auxiliary, and defined variables\n- objectives_/constraints_: Symbolic expressions\n- graph_: Dependency graph for evaluation ordering\n- auxSet_: Set of auxiliary variables w = f(x) for linearization\n\n**Bound tightening methods:**\n- FBBT (doFBBT_): Feasibility-based bound tightening via constraint propagation\n- OBBT (doOBBT_): Optimality-based bound tightening via LP solves\n- RCBT (doRCBT_): Reduced-cost bound tightening\n- ABT (doABT_): Aggressive bound tightening via domain partitioning\n\n**Reformulation (standardize()):**\nConverts nonlinear expressions into auxiliary variable definitions\nw = f(x), enabling generation of convex relaxations for each operator.\n\n**Symmetry handling:**\nUses nauty library for graph automorphism detection and orbital branching."
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/expression/operators/CouenneExprPow.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Power expression w = x^k with convexification"
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/expression/operators/CouenneExprMul.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "N-ary multiplication expression with McCormick convexification\n\nRepresents products of the form w = x1 * x2 * ... * xn.\nDuring standardization, n-ary products are decomposed into\nbinary products: w1 = x1*x2, w2 = w1*x3, etc."
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/expression/operators/CouenneExprQuad.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Quadratic expression with alpha-convexification"
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/expression/operators/CouenneExprTrilinear.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Trilinear product expression w = x*y*z"
      }
    },
    {
      "from": "convexification",
      "to": "Couenne/src/cut/crossconv/CouenneCrossConv.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Cuts from redundant relationships between auxiliary variables"
      }
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "Couenne/src/branch/CouenneChooseVariable.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable selection for branching in global optimization"
      }
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "Couenne/src/branch/CouenneThreeWayBranchObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Three-way spatial branching for continuous variables"
      }
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "Couenne/src/branch/CouenneVarObject.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Variable-based branching object for MINLP"
      }
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "Couenne/src/branch/CouenneOrbitBranchingObj.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Orbital branching object using symmetry"
      }
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "Couenne/src/convex/CouenneCutGenerator.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Main convexification cut generator for global MINLP optimization\n\nGenerates linear outer approximation cuts to build convex relaxations\nof nonconvex MINLPs. Works with the symbolic CouenneProblem representation.\n\n**Cut generation (generateCuts):**\n1. For each auxiliary variable w = f(x), generate linearization cuts\n2. Cuts are based on expression type (convex envelope, secants, tangents)\n3. Uses current LP solution as linearization point\n\n**Convexification types (conv_type):**\n- Current-point linearization (most common)\n- Multi-point sampling for tighter relaxations\n\n**Cut types generated:**\n- Tangent cuts for convex functions\n- Secant cuts for concave functions\n- McCormick envelope cuts for bilinear terms\n- Specialized cuts for sin, cos, exp, log, etc.\n\n**Helper methods:**\n- addEnvelope(): Generate convex/concave envelope for univariate function\n- addSegment(): Add secant line between two points\n- addTangent(): Add tangent at given point\n- createCut(): Build and validate OsiRowCut"
      }
    },
    {
      "from": "spatial_branch_and_bound",
      "to": "SHOT/ThirdParty/mc++/include/tmodel.hpp",
      "type": "implemented_in",
      "meta": {
        "brief": "Taylor Model Arithmetic for Rigorous Bound Propagation"
      }
    }
  ],
  "stats": {
    "concept_count": 41,
    "relationship_count": 1471
  }
}